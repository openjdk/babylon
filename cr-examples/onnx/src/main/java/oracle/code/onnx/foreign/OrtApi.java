// Generated by jextract

package oracle.code.onnx.foreign;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.util.function.*;

import static java.lang.foreign.MemoryLayout.PathElement.*;

/**
 * {@snippet lang=c :
 * struct OrtApi {
 *     OrtStatus *(*CreateStatus)(OrtErrorCode, const char *);
 *     OrtErrorCode (*GetErrorCode)(const OrtStatus *);
 *     const char *(*GetErrorMessage)(const OrtStatus *);
 *     OrtStatusPtr (*CreateEnv)(OrtLoggingLevel, const char *, OrtEnv **);
 *     OrtStatusPtr (*CreateEnvWithCustomLogger)(OrtLoggingFunction, void *, OrtLoggingLevel, const char *, OrtEnv **);
 *     OrtStatusPtr (*EnableTelemetryEvents)(const OrtEnv *);
 *     OrtStatusPtr (*DisableTelemetryEvents)(const OrtEnv *);
 *     OrtStatusPtr (*CreateSession)(const OrtEnv *, const char *, const OrtSessionOptions *, OrtSession **);
 *     OrtStatusPtr (*CreateSessionFromArray)(const OrtEnv *, const void *, size_t, const OrtSessionOptions *, OrtSession **);
 *     OrtStatusPtr (*Run)(OrtSession *, const OrtRunOptions *, const char *const *, const OrtValue *const *, size_t, const char *const *, size_t, OrtValue **);
 *     OrtStatusPtr (*CreateSessionOptions)(OrtSessionOptions **);
 *     OrtStatusPtr (*SetOptimizedModelFilePath)(OrtSessionOptions *, const char *);
 *     OrtStatusPtr (*CloneSessionOptions)(const OrtSessionOptions *, OrtSessionOptions **);
 *     OrtStatusPtr (*SetSessionExecutionMode)(OrtSessionOptions *, ExecutionMode);
 *     OrtStatusPtr (*EnableProfiling)(OrtSessionOptions *, const char *);
 *     OrtStatusPtr (*DisableProfiling)(OrtSessionOptions *);
 *     OrtStatusPtr (*EnableMemPattern)(OrtSessionOptions *);
 *     OrtStatusPtr (*DisableMemPattern)(OrtSessionOptions *);
 *     OrtStatusPtr (*EnableCpuMemArena)(OrtSessionOptions *);
 *     OrtStatusPtr (*DisableCpuMemArena)(OrtSessionOptions *);
 *     OrtStatusPtr (*SetSessionLogId)(OrtSessionOptions *, const char *);
 *     OrtStatusPtr (*SetSessionLogVerbosityLevel)(OrtSessionOptions *, int);
 *     OrtStatusPtr (*SetSessionLogSeverityLevel)(OrtSessionOptions *, int);
 *     OrtStatusPtr (*SetSessionGraphOptimizationLevel)(OrtSessionOptions *, GraphOptimizationLevel);
 *     OrtStatusPtr (*SetIntraOpNumThreads)(OrtSessionOptions *, int);
 *     OrtStatusPtr (*SetInterOpNumThreads)(OrtSessionOptions *, int);
 *     OrtStatusPtr (*CreateCustomOpDomain)(const char *, OrtCustomOpDomain **);
 *     OrtStatusPtr (*CustomOpDomain_Add)(OrtCustomOpDomain *, const OrtCustomOp *);
 *     OrtStatusPtr (*AddCustomOpDomain)(OrtSessionOptions *, OrtCustomOpDomain *);
 *     OrtStatusPtr (*RegisterCustomOpsLibrary)(OrtSessionOptions *, const char *, void **);
 *     OrtStatusPtr (*SessionGetInputCount)(const OrtSession *, size_t *);
 *     OrtStatusPtr (*SessionGetOutputCount)(const OrtSession *, size_t *);
 *     OrtStatusPtr (*SessionGetOverridableInitializerCount)(const OrtSession *, size_t *);
 *     OrtStatusPtr (*SessionGetInputTypeInfo)(const OrtSession *, size_t, OrtTypeInfo **);
 *     OrtStatusPtr (*SessionGetOutputTypeInfo)(const OrtSession *, size_t, OrtTypeInfo **);
 *     OrtStatusPtr (*SessionGetOverridableInitializerTypeInfo)(const OrtSession *, size_t, OrtTypeInfo **);
 *     OrtStatusPtr (*SessionGetInputName)(const OrtSession *, size_t, OrtAllocator *, char **);
 *     OrtStatusPtr (*SessionGetOutputName)(const OrtSession *, size_t, OrtAllocator *, char **);
 *     OrtStatusPtr (*SessionGetOverridableInitializerName)(const OrtSession *, size_t, OrtAllocator *, char **);
 *     OrtStatusPtr (*CreateRunOptions)(OrtRunOptions **);
 *     OrtStatusPtr (*RunOptionsSetRunLogVerbosityLevel)(OrtRunOptions *, int);
 *     OrtStatusPtr (*RunOptionsSetRunLogSeverityLevel)(OrtRunOptions *, int);
 *     OrtStatusPtr (*RunOptionsSetRunTag)(OrtRunOptions *, const char *);
 *     OrtStatusPtr (*RunOptionsGetRunLogVerbosityLevel)(const OrtRunOptions *, int *);
 *     OrtStatusPtr (*RunOptionsGetRunLogSeverityLevel)(const OrtRunOptions *, int *);
 *     OrtStatusPtr (*RunOptionsGetRunTag)(const OrtRunOptions *, const char **);
 *     OrtStatusPtr (*RunOptionsSetTerminate)(OrtRunOptions *);
 *     OrtStatusPtr (*RunOptionsUnsetTerminate)(OrtRunOptions *);
 *     OrtStatusPtr (*CreateTensorAsOrtValue)(OrtAllocator *, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **);
 *     OrtStatusPtr (*CreateTensorWithDataAsOrtValue)(const OrtMemoryInfo *, void *, size_t, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **);
 *     OrtStatusPtr (*IsTensor)(const OrtValue *, int *);
 *     OrtStatusPtr (*GetTensorMutableData)(OrtValue *, void **);
 *     OrtStatusPtr (*FillStringTensor)(OrtValue *, const char *const *, size_t);
 *     OrtStatusPtr (*GetStringTensorDataLength)(const OrtValue *, size_t *);
 *     OrtStatusPtr (*GetStringTensorContent)(const OrtValue *, void *, size_t, size_t *, size_t);
 *     OrtStatusPtr (*CastTypeInfoToTensorInfo)(const OrtTypeInfo *, const OrtTensorTypeAndShapeInfo **);
 *     OrtStatusPtr (*GetOnnxTypeFromTypeInfo)(const OrtTypeInfo *, enum ONNXType *);
 *     OrtStatusPtr (*CreateTensorTypeAndShapeInfo)(OrtTensorTypeAndShapeInfo **);
 *     OrtStatusPtr (*SetTensorElementType)(OrtTensorTypeAndShapeInfo *, enum ONNXTensorElementDataType);
 *     OrtStatusPtr (*SetDimensions)(OrtTensorTypeAndShapeInfo *, const int64_t *, size_t);
 *     OrtStatusPtr (*GetTensorElementType)(const OrtTensorTypeAndShapeInfo *, enum ONNXTensorElementDataType *);
 *     OrtStatusPtr (*GetDimensionsCount)(const OrtTensorTypeAndShapeInfo *, size_t *);
 *     OrtStatusPtr (*GetDimensions)(const OrtTensorTypeAndShapeInfo *, int64_t *, size_t);
 *     OrtStatusPtr (*GetSymbolicDimensions)(const OrtTensorTypeAndShapeInfo *, const char **, size_t);
 *     OrtStatusPtr (*GetTensorShapeElementCount)(const OrtTensorTypeAndShapeInfo *, size_t *);
 *     OrtStatusPtr (*GetTensorTypeAndShape)(const OrtValue *, OrtTensorTypeAndShapeInfo **);
 *     OrtStatusPtr (*GetTypeInfo)(const OrtValue *, OrtTypeInfo **);
 *     OrtStatusPtr (*GetValueType)(const OrtValue *, enum ONNXType *);
 *     OrtStatusPtr (*CreateMemoryInfo)(const char *, enum OrtAllocatorType, int, enum OrtMemType, OrtMemoryInfo **);
 *     OrtStatusPtr (*CreateCpuMemoryInfo)(enum OrtAllocatorType, enum OrtMemType, OrtMemoryInfo **);
 *     OrtStatusPtr (*CompareMemoryInfo)(const OrtMemoryInfo *, const OrtMemoryInfo *, int *);
 *     OrtStatusPtr (*MemoryInfoGetName)(const OrtMemoryInfo *, const char **);
 *     OrtStatusPtr (*MemoryInfoGetId)(const OrtMemoryInfo *, int *);
 *     OrtStatusPtr (*MemoryInfoGetMemType)(const OrtMemoryInfo *, OrtMemType *);
 *     OrtStatusPtr (*MemoryInfoGetType)(const OrtMemoryInfo *, OrtAllocatorType *);
 *     OrtStatusPtr (*AllocatorAlloc)(OrtAllocator *, size_t, void **);
 *     OrtStatusPtr (*AllocatorFree)(OrtAllocator *, void *);
 *     OrtStatusPtr (*AllocatorGetInfo)(const OrtAllocator *, const struct OrtMemoryInfo **);
 *     OrtStatusPtr (*GetAllocatorWithDefaultOptions)(OrtAllocator **);
 *     OrtStatusPtr (*AddFreeDimensionOverride)(OrtSessionOptions *, const char *, int64_t);
 *     OrtStatusPtr (*GetValue)(const OrtValue *, int, OrtAllocator *, OrtValue **);
 *     OrtStatusPtr (*GetValueCount)(const OrtValue *, size_t *);
 *     OrtStatusPtr (*CreateValue)(const OrtValue *const *, size_t, enum ONNXType, OrtValue **);
 *     OrtStatusPtr (*CreateOpaqueValue)(const char *, const char *, const void *, size_t, OrtValue **);
 *     OrtStatusPtr (*GetOpaqueValue)(const char *, const char *, const OrtValue *, void *, size_t);
 *     OrtStatusPtr (*KernelInfoGetAttribute_float)(const OrtKernelInfo *, const char *, float *);
 *     OrtStatusPtr (*KernelInfoGetAttribute_int64)(const OrtKernelInfo *, const char *, int64_t *);
 *     OrtStatusPtr (*KernelInfoGetAttribute_string)(const OrtKernelInfo *, const char *, char *, size_t *);
 *     OrtStatusPtr (*KernelContext_GetInputCount)(const OrtKernelContext *, size_t *);
 *     OrtStatusPtr (*KernelContext_GetOutputCount)(const OrtKernelContext *, size_t *);
 *     OrtStatusPtr (*KernelContext_GetInput)(const OrtKernelContext *, size_t, const OrtValue **);
 *     OrtStatusPtr (*KernelContext_GetOutput)(OrtKernelContext *, size_t, const int64_t *, size_t, OrtValue **);
 *     void (*ReleaseEnv)(OrtEnv *);
 *     void (*ReleaseStatus)(OrtStatus *);
 *     void (*ReleaseMemoryInfo)(OrtMemoryInfo *);
 *     void (*ReleaseSession)(OrtSession *);
 *     void (*ReleaseValue)(OrtValue *);
 *     void (*ReleaseRunOptions)(OrtRunOptions *);
 *     void (*ReleaseTypeInfo)(OrtTypeInfo *);
 *     void (*ReleaseTensorTypeAndShapeInfo)(OrtTensorTypeAndShapeInfo *);
 *     void (*ReleaseSessionOptions)(OrtSessionOptions *);
 *     void (*ReleaseCustomOpDomain)(OrtCustomOpDomain *);
 *     OrtStatusPtr (*GetDenotationFromTypeInfo)(const OrtTypeInfo *, const char **const, size_t *);
 *     OrtStatusPtr (*CastTypeInfoToMapTypeInfo)(const OrtTypeInfo *, const OrtMapTypeInfo **);
 *     OrtStatusPtr (*CastTypeInfoToSequenceTypeInfo)(const OrtTypeInfo *, const OrtSequenceTypeInfo **);
 *     OrtStatusPtr (*GetMapKeyType)(const OrtMapTypeInfo *, enum ONNXTensorElementDataType *);
 *     OrtStatusPtr (*GetMapValueType)(const OrtMapTypeInfo *, OrtTypeInfo **);
 *     OrtStatusPtr (*GetSequenceElementType)(const OrtSequenceTypeInfo *, OrtTypeInfo **);
 *     void (*ReleaseMapTypeInfo)(OrtMapTypeInfo *);
 *     void (*ReleaseSequenceTypeInfo)(OrtSequenceTypeInfo *);
 *     OrtStatusPtr (*SessionEndProfiling)(OrtSession *, OrtAllocator *, char **);
 *     OrtStatusPtr (*SessionGetModelMetadata)(const OrtSession *, OrtModelMetadata **);
 *     OrtStatusPtr (*ModelMetadataGetProducerName)(const OrtModelMetadata *, OrtAllocator *, char **);
 *     OrtStatusPtr (*ModelMetadataGetGraphName)(const OrtModelMetadata *, OrtAllocator *, char **);
 *     OrtStatusPtr (*ModelMetadataGetDomain)(const OrtModelMetadata *, OrtAllocator *, char **);
 *     OrtStatusPtr (*ModelMetadataGetDescription)(const OrtModelMetadata *, OrtAllocator *, char **);
 *     OrtStatusPtr (*ModelMetadataLookupCustomMetadataMap)(const OrtModelMetadata *, OrtAllocator *, const char *, char **);
 *     OrtStatusPtr (*ModelMetadataGetVersion)(const OrtModelMetadata *, int64_t *);
 *     void (*ReleaseModelMetadata)(OrtModelMetadata *);
 *     OrtStatusPtr (*CreateEnvWithGlobalThreadPools)(OrtLoggingLevel, const char *, const OrtThreadingOptions *, OrtEnv **);
 *     OrtStatusPtr (*DisablePerSessionThreads)(OrtSessionOptions *);
 *     OrtStatusPtr (*CreateThreadingOptions)(OrtThreadingOptions **);
 *     void (*ReleaseThreadingOptions)(OrtThreadingOptions *);
 *     OrtStatusPtr (*ModelMetadataGetCustomMetadataMapKeys)(const OrtModelMetadata *, OrtAllocator *, char ***, int64_t *);
 *     OrtStatusPtr (*AddFreeDimensionOverrideByName)(OrtSessionOptions *, const char *, int64_t);
 *     OrtStatusPtr (*GetAvailableProviders)(char ***, int *);
 *     OrtStatusPtr (*ReleaseAvailableProviders)(char **, int);
 *     OrtStatusPtr (*GetStringTensorElementLength)(const OrtValue *, size_t, size_t *);
 *     OrtStatusPtr (*GetStringTensorElement)(const OrtValue *, size_t, size_t, void *);
 *     OrtStatusPtr (*FillStringTensorElement)(OrtValue *, const char *, size_t);
 *     OrtStatusPtr (*AddSessionConfigEntry)(OrtSessionOptions *, const char *, const char *);
 *     OrtStatusPtr (*CreateAllocator)(const OrtSession *, const OrtMemoryInfo *, OrtAllocator **);
 *     void (*ReleaseAllocator)(OrtAllocator *);
 *     OrtStatusPtr (*RunWithBinding)(OrtSession *, const OrtRunOptions *, const OrtIoBinding *);
 *     OrtStatusPtr (*CreateIoBinding)(OrtSession *, OrtIoBinding **);
 *     void (*ReleaseIoBinding)(OrtIoBinding *);
 *     OrtStatusPtr (*BindInput)(OrtIoBinding *, const char *, const OrtValue *);
 *     OrtStatusPtr (*BindOutput)(OrtIoBinding *, const char *, const OrtValue *);
 *     OrtStatusPtr (*BindOutputToDevice)(OrtIoBinding *, const char *, const OrtMemoryInfo *);
 *     OrtStatusPtr (*GetBoundOutputNames)(const OrtIoBinding *, OrtAllocator *, char **, size_t **, size_t *);
 *     OrtStatusPtr (*GetBoundOutputValues)(const OrtIoBinding *, OrtAllocator *, OrtValue ***, size_t *);
 *     void (*ClearBoundInputs)(OrtIoBinding *);
 *     void (*ClearBoundOutputs)(OrtIoBinding *);
 *     OrtStatusPtr (*TensorAt)(OrtValue *, const int64_t *, size_t, void **);
 *     OrtStatusPtr (*CreateAndRegisterAllocator)(OrtEnv *, const OrtMemoryInfo *, const OrtArenaCfg *);
 *     OrtStatusPtr (*SetLanguageProjection)(const OrtEnv *, OrtLanguageProjection);
 *     OrtStatusPtr (*SessionGetProfilingStartTimeNs)(const OrtSession *, uint64_t *);
 *     OrtStatusPtr (*SetGlobalIntraOpNumThreads)(OrtThreadingOptions *, int);
 *     OrtStatusPtr (*SetGlobalInterOpNumThreads)(OrtThreadingOptions *, int);
 *     OrtStatusPtr (*SetGlobalSpinControl)(OrtThreadingOptions *, int);
 *     OrtStatusPtr (*AddInitializer)(OrtSessionOptions *, const char *, const OrtValue *);
 *     OrtStatusPtr (*CreateEnvWithCustomLoggerAndGlobalThreadPools)(OrtLoggingFunction, void *, OrtLoggingLevel, const char *, const struct OrtThreadingOptions *, OrtEnv **);
 *     OrtStatusPtr (*SessionOptionsAppendExecutionProvider_CUDA)(OrtSessionOptions *, const OrtCUDAProviderOptions *);
 *     OrtStatusPtr (*SessionOptionsAppendExecutionProvider_ROCM)(OrtSessionOptions *, const OrtROCMProviderOptions *);
 *     OrtStatusPtr (*SessionOptionsAppendExecutionProvider_OpenVINO)(OrtSessionOptions *, const OrtOpenVINOProviderOptions *);
 *     OrtStatusPtr (*SetGlobalDenormalAsZero)(OrtThreadingOptions *);
 *     OrtStatusPtr (*CreateArenaCfg)(size_t, int, int, int, OrtArenaCfg **);
 *     void (*ReleaseArenaCfg)(OrtArenaCfg *);
 *     OrtStatusPtr (*ModelMetadataGetGraphDescription)(const OrtModelMetadata *, OrtAllocator *, char **);
 *     OrtStatusPtr (*SessionOptionsAppendExecutionProvider_TensorRT)(OrtSessionOptions *, const OrtTensorRTProviderOptions *);
 *     OrtStatusPtr (*SetCurrentGpuDeviceId)(int);
 *     OrtStatusPtr (*GetCurrentGpuDeviceId)(int *);
 *     OrtStatusPtr (*KernelInfoGetAttributeArray_float)(const OrtKernelInfo *, const char *, float *, size_t *);
 *     OrtStatusPtr (*KernelInfoGetAttributeArray_int64)(const OrtKernelInfo *, const char *, int64_t *, size_t *);
 *     OrtStatusPtr (*CreateArenaCfgV2)(const char *const *, const size_t *, size_t, OrtArenaCfg **);
 *     OrtStatusPtr (*AddRunConfigEntry)(OrtRunOptions *, const char *, const char *);
 *     OrtStatusPtr (*CreatePrepackedWeightsContainer)(OrtPrepackedWeightsContainer **);
 *     void (*ReleasePrepackedWeightsContainer)(OrtPrepackedWeightsContainer *);
 *     OrtStatusPtr (*CreateSessionWithPrepackedWeightsContainer)(const OrtEnv *, const char *, const OrtSessionOptions *, OrtPrepackedWeightsContainer *, OrtSession **);
 *     OrtStatusPtr (*CreateSessionFromArrayWithPrepackedWeightsContainer)(const OrtEnv *, const void *, size_t, const OrtSessionOptions *, OrtPrepackedWeightsContainer *, OrtSession **);
 *     OrtStatusPtr (*SessionOptionsAppendExecutionProvider_TensorRT_V2)(OrtSessionOptions *, const OrtTensorRTProviderOptionsV2 *);
 *     OrtStatusPtr (*CreateTensorRTProviderOptions)(OrtTensorRTProviderOptionsV2 **);
 *     OrtStatusPtr (*UpdateTensorRTProviderOptions)(OrtTensorRTProviderOptionsV2 *, const char *const *, const char *const *, size_t);
 *     OrtStatusPtr (*GetTensorRTProviderOptionsAsString)(const OrtTensorRTProviderOptionsV2 *, OrtAllocator *, char **);
 *     void (*ReleaseTensorRTProviderOptions)(OrtTensorRTProviderOptionsV2 *);
 *     OrtStatusPtr (*EnableOrtCustomOps)(OrtSessionOptions *);
 *     OrtStatusPtr (*RegisterAllocator)(OrtEnv *, OrtAllocator *);
 *     OrtStatusPtr (*UnregisterAllocator)(OrtEnv *, const OrtMemoryInfo *);
 *     OrtStatusPtr (*IsSparseTensor)(const OrtValue *, int *);
 *     OrtStatusPtr (*CreateSparseTensorAsOrtValue)(OrtAllocator *, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **);
 *     OrtStatusPtr (*FillSparseTensorCoo)(OrtValue *, const OrtMemoryInfo *, const int64_t *, size_t, const void *, const int64_t *, size_t);
 *     OrtStatusPtr (*FillSparseTensorCsr)(OrtValue *, const OrtMemoryInfo *, const int64_t *, size_t, const void *, const int64_t *, size_t, const int64_t *, size_t);
 *     OrtStatusPtr (*FillSparseTensorBlockSparse)(OrtValue *, const OrtMemoryInfo *, const int64_t *, size_t, const void *, const int64_t *, size_t, const int32_t *);
 *     OrtStatusPtr (*CreateSparseTensorWithValuesAsOrtValue)(const OrtMemoryInfo *, void *, const int64_t *, size_t, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **);
 *     OrtStatusPtr (*UseCooIndices)(OrtValue *, int64_t *, size_t);
 *     OrtStatusPtr (*UseCsrIndices)(OrtValue *, int64_t *, size_t, int64_t *, size_t);
 *     OrtStatusPtr (*UseBlockSparseIndices)(OrtValue *, const int64_t *, size_t, int32_t *);
 *     OrtStatusPtr (*GetSparseTensorFormat)(const OrtValue *, enum OrtSparseFormat *);
 *     OrtStatusPtr (*GetSparseTensorValuesTypeAndShape)(const OrtValue *, OrtTensorTypeAndShapeInfo **);
 *     OrtStatusPtr (*GetSparseTensorValues)(const OrtValue *, const void **);
 *     OrtStatusPtr (*GetSparseTensorIndicesTypeShape)(const OrtValue *, enum OrtSparseIndicesFormat, OrtTensorTypeAndShapeInfo **);
 *     OrtStatusPtr (*GetSparseTensorIndices)(const OrtValue *, enum OrtSparseIndicesFormat, size_t *, const void **);
 *     OrtStatusPtr (*HasValue)(const OrtValue *, int *);
 *     OrtStatusPtr (*KernelContext_GetGPUComputeStream)(const OrtKernelContext *, void **);
 *     OrtStatusPtr (*GetTensorMemoryInfo)(const OrtValue *, const OrtMemoryInfo **);
 *     OrtStatusPtr (*GetExecutionProviderApi)(const char *, uint32_t, const void **);
 *     OrtStatusPtr (*SessionOptionsSetCustomCreateThreadFn)(OrtSessionOptions *, OrtCustomCreateThreadFn);
 *     OrtStatusPtr (*SessionOptionsSetCustomThreadCreationOptions)(OrtSessionOptions *, void *);
 *     OrtStatusPtr (*SessionOptionsSetCustomJoinThreadFn)(OrtSessionOptions *, OrtCustomJoinThreadFn);
 *     OrtStatusPtr (*SetGlobalCustomCreateThreadFn)(OrtThreadingOptions *, OrtCustomCreateThreadFn);
 *     OrtStatusPtr (*SetGlobalCustomThreadCreationOptions)(OrtThreadingOptions *, void *);
 *     OrtStatusPtr (*SetGlobalCustomJoinThreadFn)(OrtThreadingOptions *, OrtCustomJoinThreadFn);
 *     OrtStatusPtr (*SynchronizeBoundInputs)(OrtIoBinding *);
 *     OrtStatusPtr (*SynchronizeBoundOutputs)(OrtIoBinding *);
 *     OrtStatusPtr (*SessionOptionsAppendExecutionProvider_CUDA_V2)(OrtSessionOptions *, const OrtCUDAProviderOptionsV2 *);
 *     OrtStatusPtr (*CreateCUDAProviderOptions)(OrtCUDAProviderOptionsV2 **);
 *     OrtStatusPtr (*UpdateCUDAProviderOptions)(OrtCUDAProviderOptionsV2 *, const char *const *, const char *const *, size_t);
 *     OrtStatusPtr (*GetCUDAProviderOptionsAsString)(const OrtCUDAProviderOptionsV2 *, OrtAllocator *, char **);
 *     void (*ReleaseCUDAProviderOptions)(OrtCUDAProviderOptionsV2 *);
 *     OrtStatusPtr (*SessionOptionsAppendExecutionProvider_MIGraphX)(OrtSessionOptions *, const OrtMIGraphXProviderOptions *);
 *     OrtStatusPtr (*AddExternalInitializers)(OrtSessionOptions *, const char *const *, const OrtValue *const *, size_t);
 *     OrtStatusPtr (*CreateOpAttr)(const char *, const void *, int, OrtOpAttrType, OrtOpAttr **);
 *     void (*ReleaseOpAttr)(OrtOpAttr *);
 *     OrtStatusPtr (*CreateOp)(const OrtKernelInfo *, const char *, const char *, int, const char **, const ONNXTensorElementDataType *, int, const OrtOpAttr *const *, int, int, int, OrtOp **);
 *     OrtStatusPtr (*InvokeOp)(const OrtKernelContext *, const OrtOp *, const OrtValue *const *, int, OrtValue *const *, int);
 *     void (*ReleaseOp)(OrtOp *);
 *     OrtStatusPtr (*SessionOptionsAppendExecutionProvider)(OrtSessionOptions *, const char *, const char *const *, const char *const *, size_t);
 *     OrtStatusPtr (*CopyKernelInfo)(const OrtKernelInfo *, OrtKernelInfo **);
 *     void (*ReleaseKernelInfo)(OrtKernelInfo *);
 *     const OrtTrainingApi *(*GetTrainingApi)(uint32_t);
 *     OrtStatusPtr (*SessionOptionsAppendExecutionProvider_CANN)(OrtSessionOptions *, const OrtCANNProviderOptions *);
 *     OrtStatusPtr (*CreateCANNProviderOptions)(OrtCANNProviderOptions **);
 *     OrtStatusPtr (*UpdateCANNProviderOptions)(OrtCANNProviderOptions *, const char *const *, const char *const *, size_t);
 *     OrtStatusPtr (*GetCANNProviderOptionsAsString)(const OrtCANNProviderOptions *, OrtAllocator *, char **);
 *     void (*ReleaseCANNProviderOptions)(OrtCANNProviderOptions *);
 *     void (*MemoryInfoGetDeviceType)(const OrtMemoryInfo *, OrtMemoryInfoDeviceType *);
 *     OrtStatusPtr (*UpdateEnvWithCustomLogLevel)(OrtEnv *, OrtLoggingLevel);
 *     OrtStatusPtr (*SetGlobalIntraOpThreadAffinity)(OrtThreadingOptions *, const char *);
 *     OrtStatusPtr (*RegisterCustomOpsLibrary_V2)(OrtSessionOptions *, const char *);
 *     OrtStatusPtr (*RegisterCustomOpsUsingFunction)(OrtSessionOptions *, const char *);
 *     OrtStatusPtr (*KernelInfo_GetInputCount)(const OrtKernelInfo *, size_t *);
 *     OrtStatusPtr (*KernelInfo_GetOutputCount)(const OrtKernelInfo *, size_t *);
 *     OrtStatusPtr (*KernelInfo_GetInputName)(const OrtKernelInfo *, size_t, char *, size_t *);
 *     OrtStatusPtr (*KernelInfo_GetOutputName)(const OrtKernelInfo *, size_t, char *, size_t *);
 *     OrtStatusPtr (*KernelInfo_GetInputTypeInfo)(const OrtKernelInfo *, size_t, OrtTypeInfo **);
 *     OrtStatusPtr (*KernelInfo_GetOutputTypeInfo)(const OrtKernelInfo *, size_t, OrtTypeInfo **);
 *     OrtStatusPtr (*KernelInfoGetAttribute_tensor)(const OrtKernelInfo *, const char *, OrtAllocator *, OrtValue **);
 *     OrtStatusPtr (*HasSessionConfigEntry)(const OrtSessionOptions *, const char *, int *);
 *     OrtStatusPtr (*GetSessionConfigEntry)(const OrtSessionOptions *, const char *, char *, size_t *);
 *     OrtStatusPtr (*SessionOptionsAppendExecutionProvider_Dnnl)(OrtSessionOptions *, const OrtDnnlProviderOptions *);
 *     OrtStatusPtr (*CreateDnnlProviderOptions)(OrtDnnlProviderOptions **);
 *     OrtStatusPtr (*UpdateDnnlProviderOptions)(OrtDnnlProviderOptions *, const char *const *, const char *const *, size_t);
 *     OrtStatusPtr (*GetDnnlProviderOptionsAsString)(const OrtDnnlProviderOptions *, OrtAllocator *, char **);
 *     void (*ReleaseDnnlProviderOptions)(OrtDnnlProviderOptions *);
 *     OrtStatusPtr (*KernelInfo_GetNodeName)(const OrtKernelInfo *, char *, size_t *);
 *     OrtStatusPtr (*KernelInfo_GetLogger)(const OrtKernelInfo *, const OrtLogger **);
 *     OrtStatusPtr (*KernelContext_GetLogger)(const OrtKernelContext *, const OrtLogger **);
 *     OrtStatusPtr (*Logger_LogMessage)(const OrtLogger *, OrtLoggingLevel, const char *, const char *, int, const char *);
 *     OrtStatusPtr (*Logger_GetLoggingSeverityLevel)(const OrtLogger *, OrtLoggingLevel *);
 *     OrtStatusPtr (*KernelInfoGetConstantInput_tensor)(const OrtKernelInfo *, size_t, int *, const OrtValue **);
 *     OrtStatusPtr (*CastTypeInfoToOptionalTypeInfo)(const OrtTypeInfo *, const OrtOptionalTypeInfo **);
 *     OrtStatusPtr (*GetOptionalContainedTypeInfo)(const OrtOptionalTypeInfo *, OrtTypeInfo **);
 *     OrtStatusPtr (*GetResizedStringTensorElementBuffer)(OrtValue *, size_t, size_t, char **);
 *     OrtStatusPtr (*KernelContext_GetAllocator)(const OrtKernelContext *, const OrtMemoryInfo *, OrtAllocator **);
 *     const char *(*GetBuildInfoString)(void);
 *     OrtStatusPtr (*CreateROCMProviderOptions)(OrtROCMProviderOptions **);
 *     OrtStatusPtr (*UpdateROCMProviderOptions)(OrtROCMProviderOptions *, const char *const *, const char *const *, size_t);
 *     OrtStatusPtr (*GetROCMProviderOptionsAsString)(const OrtROCMProviderOptions *, OrtAllocator *, char **);
 *     void (*ReleaseROCMProviderOptions)(OrtROCMProviderOptions *);
 *     OrtStatusPtr (*CreateAndRegisterAllocatorV2)(OrtEnv *, const char *, const OrtMemoryInfo *, const OrtArenaCfg *, const char *const *, const char *const *, size_t);
 *     OrtStatusPtr (*RunAsync)(OrtSession *, const OrtRunOptions *, const char *const *, const OrtValue *const *, size_t, const char *const *, size_t, OrtValue **, RunAsyncCallbackFn, void *);
 *     OrtStatusPtr (*UpdateTensorRTProviderOptionsWithValue)(OrtTensorRTProviderOptionsV2 *, const char *, void *);
 *     OrtStatusPtr (*GetTensorRTProviderOptionsByName)(const OrtTensorRTProviderOptionsV2 *, const char *, void **);
 *     OrtStatusPtr (*UpdateCUDAProviderOptionsWithValue)(OrtCUDAProviderOptionsV2 *, const char *, void *);
 *     OrtStatusPtr (*GetCUDAProviderOptionsByName)(const OrtCUDAProviderOptionsV2 *, const char *, void **);
 *     OrtStatusPtr (*KernelContext_GetResource)(const OrtKernelContext *, int, int, void **);
 *     OrtStatusPtr (*SetUserLoggingFunction)(OrtSessionOptions *, OrtLoggingFunction, void *);
 *     OrtStatusPtr (*ShapeInferContext_GetInputCount)(const OrtShapeInferContext *, size_t *);
 *     OrtStatusPtr (*ShapeInferContext_GetInputTypeShape)(const OrtShapeInferContext *, size_t, OrtTensorTypeAndShapeInfo **);
 *     OrtStatusPtr (*ShapeInferContext_GetAttribute)(const OrtShapeInferContext *, const char *, const OrtOpAttr **);
 *     OrtStatusPtr (*ShapeInferContext_SetOutputTypeShape)(const OrtShapeInferContext *, size_t, const OrtTensorTypeAndShapeInfo *);
 *     OrtStatusPtr (*SetSymbolicDimensions)(OrtTensorTypeAndShapeInfo *, const char **, size_t);
 *     OrtStatusPtr (*ReadOpAttr)(const OrtOpAttr *, OrtOpAttrType, void *, size_t, size_t *);
 *     OrtStatusPtr (*SetDeterministicCompute)(OrtSessionOptions *, bool);
 *     OrtStatusPtr (*KernelContext_ParallelFor)(const OrtKernelContext *, void (*)(void *, size_t), size_t, size_t, void *);
 *     OrtStatusPtr (*SessionOptionsAppendExecutionProvider_OpenVINO_V2)(OrtSessionOptions *, const char *const *, const char *const *, size_t);
 *     OrtStatusPtr (*SessionOptionsAppendExecutionProvider_VitisAI)(OrtSessionOptions *, const char *const *, const char *const *, size_t);
 *     OrtStatusPtr (*KernelContext_GetScratchBuffer)(const OrtKernelContext *, const OrtMemoryInfo *, size_t, void **);
 *     OrtStatusPtr (*KernelInfoGetAllocator)(const OrtKernelInfo *, OrtMemType, OrtAllocator **);
 *     OrtStatusPtr (*AddExternalInitializersFromFilesInMemory)(OrtSessionOptions *, const char *const *, char *const *, const size_t *, size_t);
 *     OrtStatusPtr (*CreateLoraAdapter)(const char *, OrtAllocator *, OrtLoraAdapter **);
 *     OrtStatusPtr (*CreateLoraAdapterFromArray)(const void *, size_t, OrtAllocator *, OrtLoraAdapter **);
 *     void (*ReleaseLoraAdapter)(OrtLoraAdapter *);
 *     OrtStatusPtr (*RunOptionsAddActiveLoraAdapter)(OrtRunOptions *, const OrtLoraAdapter *);
 *     OrtStatusPtr (*SetEpDynamicOptions)(OrtSession *, const char *const *, const char *const *, size_t);
 * }
 * }
 */
public class OrtApi {

    OrtApi() {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
        onnxruntime_c_api_h.C_POINTER.withName("CreateStatus"),
        onnxruntime_c_api_h.C_POINTER.withName("GetErrorCode"),
        onnxruntime_c_api_h.C_POINTER.withName("GetErrorMessage"),
        onnxruntime_c_api_h.C_POINTER.withName("CreateEnv"),
        onnxruntime_c_api_h.C_POINTER.withName("CreateEnvWithCustomLogger"),
        onnxruntime_c_api_h.C_POINTER.withName("EnableTelemetryEvents"),
        onnxruntime_c_api_h.C_POINTER.withName("DisableTelemetryEvents"),
        onnxruntime_c_api_h.C_POINTER.withName("CreateSession"),
        onnxruntime_c_api_h.C_POINTER.withName("CreateSessionFromArray"),
        onnxruntime_c_api_h.C_POINTER.withName("Run"),
        onnxruntime_c_api_h.C_POINTER.withName("CreateSessionOptions"),
        onnxruntime_c_api_h.C_POINTER.withName("SetOptimizedModelFilePath"),
        onnxruntime_c_api_h.C_POINTER.withName("CloneSessionOptions"),
        onnxruntime_c_api_h.C_POINTER.withName("SetSessionExecutionMode"),
        onnxruntime_c_api_h.C_POINTER.withName("EnableProfiling"),
        onnxruntime_c_api_h.C_POINTER.withName("DisableProfiling"),
        onnxruntime_c_api_h.C_POINTER.withName("EnableMemPattern"),
        onnxruntime_c_api_h.C_POINTER.withName("DisableMemPattern"),
        onnxruntime_c_api_h.C_POINTER.withName("EnableCpuMemArena"),
        onnxruntime_c_api_h.C_POINTER.withName("DisableCpuMemArena"),
        onnxruntime_c_api_h.C_POINTER.withName("SetSessionLogId"),
        onnxruntime_c_api_h.C_POINTER.withName("SetSessionLogVerbosityLevel"),
        onnxruntime_c_api_h.C_POINTER.withName("SetSessionLogSeverityLevel"),
        onnxruntime_c_api_h.C_POINTER.withName("SetSessionGraphOptimizationLevel"),
        onnxruntime_c_api_h.C_POINTER.withName("SetIntraOpNumThreads"),
        onnxruntime_c_api_h.C_POINTER.withName("SetInterOpNumThreads"),
        onnxruntime_c_api_h.C_POINTER.withName("CreateCustomOpDomain"),
        onnxruntime_c_api_h.C_POINTER.withName("CustomOpDomain_Add"),
        onnxruntime_c_api_h.C_POINTER.withName("AddCustomOpDomain"),
        onnxruntime_c_api_h.C_POINTER.withName("RegisterCustomOpsLibrary"),
        onnxruntime_c_api_h.C_POINTER.withName("SessionGetInputCount"),
        onnxruntime_c_api_h.C_POINTER.withName("SessionGetOutputCount"),
        onnxruntime_c_api_h.C_POINTER.withName("SessionGetOverridableInitializerCount"),
        onnxruntime_c_api_h.C_POINTER.withName("SessionGetInputTypeInfo"),
        onnxruntime_c_api_h.C_POINTER.withName("SessionGetOutputTypeInfo"),
        onnxruntime_c_api_h.C_POINTER.withName("SessionGetOverridableInitializerTypeInfo"),
        onnxruntime_c_api_h.C_POINTER.withName("SessionGetInputName"),
        onnxruntime_c_api_h.C_POINTER.withName("SessionGetOutputName"),
        onnxruntime_c_api_h.C_POINTER.withName("SessionGetOverridableInitializerName"),
        onnxruntime_c_api_h.C_POINTER.withName("CreateRunOptions"),
        onnxruntime_c_api_h.C_POINTER.withName("RunOptionsSetRunLogVerbosityLevel"),
        onnxruntime_c_api_h.C_POINTER.withName("RunOptionsSetRunLogSeverityLevel"),
        onnxruntime_c_api_h.C_POINTER.withName("RunOptionsSetRunTag"),
        onnxruntime_c_api_h.C_POINTER.withName("RunOptionsGetRunLogVerbosityLevel"),
        onnxruntime_c_api_h.C_POINTER.withName("RunOptionsGetRunLogSeverityLevel"),
        onnxruntime_c_api_h.C_POINTER.withName("RunOptionsGetRunTag"),
        onnxruntime_c_api_h.C_POINTER.withName("RunOptionsSetTerminate"),
        onnxruntime_c_api_h.C_POINTER.withName("RunOptionsUnsetTerminate"),
        onnxruntime_c_api_h.C_POINTER.withName("CreateTensorAsOrtValue"),
        onnxruntime_c_api_h.C_POINTER.withName("CreateTensorWithDataAsOrtValue"),
        onnxruntime_c_api_h.C_POINTER.withName("IsTensor"),
        onnxruntime_c_api_h.C_POINTER.withName("GetTensorMutableData"),
        onnxruntime_c_api_h.C_POINTER.withName("FillStringTensor"),
        onnxruntime_c_api_h.C_POINTER.withName("GetStringTensorDataLength"),
        onnxruntime_c_api_h.C_POINTER.withName("GetStringTensorContent"),
        onnxruntime_c_api_h.C_POINTER.withName("CastTypeInfoToTensorInfo"),
        onnxruntime_c_api_h.C_POINTER.withName("GetOnnxTypeFromTypeInfo"),
        onnxruntime_c_api_h.C_POINTER.withName("CreateTensorTypeAndShapeInfo"),
        onnxruntime_c_api_h.C_POINTER.withName("SetTensorElementType"),
        onnxruntime_c_api_h.C_POINTER.withName("SetDimensions"),
        onnxruntime_c_api_h.C_POINTER.withName("GetTensorElementType"),
        onnxruntime_c_api_h.C_POINTER.withName("GetDimensionsCount"),
        onnxruntime_c_api_h.C_POINTER.withName("GetDimensions"),
        onnxruntime_c_api_h.C_POINTER.withName("GetSymbolicDimensions"),
        onnxruntime_c_api_h.C_POINTER.withName("GetTensorShapeElementCount"),
        onnxruntime_c_api_h.C_POINTER.withName("GetTensorTypeAndShape"),
        onnxruntime_c_api_h.C_POINTER.withName("GetTypeInfo"),
        onnxruntime_c_api_h.C_POINTER.withName("GetValueType"),
        onnxruntime_c_api_h.C_POINTER.withName("CreateMemoryInfo"),
        onnxruntime_c_api_h.C_POINTER.withName("CreateCpuMemoryInfo"),
        onnxruntime_c_api_h.C_POINTER.withName("CompareMemoryInfo"),
        onnxruntime_c_api_h.C_POINTER.withName("MemoryInfoGetName"),
        onnxruntime_c_api_h.C_POINTER.withName("MemoryInfoGetId"),
        onnxruntime_c_api_h.C_POINTER.withName("MemoryInfoGetMemType"),
        onnxruntime_c_api_h.C_POINTER.withName("MemoryInfoGetType"),
        onnxruntime_c_api_h.C_POINTER.withName("AllocatorAlloc"),
        onnxruntime_c_api_h.C_POINTER.withName("AllocatorFree"),
        onnxruntime_c_api_h.C_POINTER.withName("AllocatorGetInfo"),
        onnxruntime_c_api_h.C_POINTER.withName("GetAllocatorWithDefaultOptions"),
        onnxruntime_c_api_h.C_POINTER.withName("AddFreeDimensionOverride"),
        onnxruntime_c_api_h.C_POINTER.withName("GetValue"),
        onnxruntime_c_api_h.C_POINTER.withName("GetValueCount"),
        onnxruntime_c_api_h.C_POINTER.withName("CreateValue"),
        onnxruntime_c_api_h.C_POINTER.withName("CreateOpaqueValue"),
        onnxruntime_c_api_h.C_POINTER.withName("GetOpaqueValue"),
        onnxruntime_c_api_h.C_POINTER.withName("KernelInfoGetAttribute_float"),
        onnxruntime_c_api_h.C_POINTER.withName("KernelInfoGetAttribute_int64"),
        onnxruntime_c_api_h.C_POINTER.withName("KernelInfoGetAttribute_string"),
        onnxruntime_c_api_h.C_POINTER.withName("KernelContext_GetInputCount"),
        onnxruntime_c_api_h.C_POINTER.withName("KernelContext_GetOutputCount"),
        onnxruntime_c_api_h.C_POINTER.withName("KernelContext_GetInput"),
        onnxruntime_c_api_h.C_POINTER.withName("KernelContext_GetOutput"),
        onnxruntime_c_api_h.C_POINTER.withName("ReleaseEnv"),
        onnxruntime_c_api_h.C_POINTER.withName("ReleaseStatus"),
        onnxruntime_c_api_h.C_POINTER.withName("ReleaseMemoryInfo"),
        onnxruntime_c_api_h.C_POINTER.withName("ReleaseSession"),
        onnxruntime_c_api_h.C_POINTER.withName("ReleaseValue"),
        onnxruntime_c_api_h.C_POINTER.withName("ReleaseRunOptions"),
        onnxruntime_c_api_h.C_POINTER.withName("ReleaseTypeInfo"),
        onnxruntime_c_api_h.C_POINTER.withName("ReleaseTensorTypeAndShapeInfo"),
        onnxruntime_c_api_h.C_POINTER.withName("ReleaseSessionOptions"),
        onnxruntime_c_api_h.C_POINTER.withName("ReleaseCustomOpDomain"),
        onnxruntime_c_api_h.C_POINTER.withName("GetDenotationFromTypeInfo"),
        onnxruntime_c_api_h.C_POINTER.withName("CastTypeInfoToMapTypeInfo"),
        onnxruntime_c_api_h.C_POINTER.withName("CastTypeInfoToSequenceTypeInfo"),
        onnxruntime_c_api_h.C_POINTER.withName("GetMapKeyType"),
        onnxruntime_c_api_h.C_POINTER.withName("GetMapValueType"),
        onnxruntime_c_api_h.C_POINTER.withName("GetSequenceElementType"),
        onnxruntime_c_api_h.C_POINTER.withName("ReleaseMapTypeInfo"),
        onnxruntime_c_api_h.C_POINTER.withName("ReleaseSequenceTypeInfo"),
        onnxruntime_c_api_h.C_POINTER.withName("SessionEndProfiling"),
        onnxruntime_c_api_h.C_POINTER.withName("SessionGetModelMetadata"),
        onnxruntime_c_api_h.C_POINTER.withName("ModelMetadataGetProducerName"),
        onnxruntime_c_api_h.C_POINTER.withName("ModelMetadataGetGraphName"),
        onnxruntime_c_api_h.C_POINTER.withName("ModelMetadataGetDomain"),
        onnxruntime_c_api_h.C_POINTER.withName("ModelMetadataGetDescription"),
        onnxruntime_c_api_h.C_POINTER.withName("ModelMetadataLookupCustomMetadataMap"),
        onnxruntime_c_api_h.C_POINTER.withName("ModelMetadataGetVersion"),
        onnxruntime_c_api_h.C_POINTER.withName("ReleaseModelMetadata"),
        onnxruntime_c_api_h.C_POINTER.withName("CreateEnvWithGlobalThreadPools"),
        onnxruntime_c_api_h.C_POINTER.withName("DisablePerSessionThreads"),
        onnxruntime_c_api_h.C_POINTER.withName("CreateThreadingOptions"),
        onnxruntime_c_api_h.C_POINTER.withName("ReleaseThreadingOptions"),
        onnxruntime_c_api_h.C_POINTER.withName("ModelMetadataGetCustomMetadataMapKeys"),
        onnxruntime_c_api_h.C_POINTER.withName("AddFreeDimensionOverrideByName"),
        onnxruntime_c_api_h.C_POINTER.withName("GetAvailableProviders"),
        onnxruntime_c_api_h.C_POINTER.withName("ReleaseAvailableProviders"),
        onnxruntime_c_api_h.C_POINTER.withName("GetStringTensorElementLength"),
        onnxruntime_c_api_h.C_POINTER.withName("GetStringTensorElement"),
        onnxruntime_c_api_h.C_POINTER.withName("FillStringTensorElement"),
        onnxruntime_c_api_h.C_POINTER.withName("AddSessionConfigEntry"),
        onnxruntime_c_api_h.C_POINTER.withName("CreateAllocator"),
        onnxruntime_c_api_h.C_POINTER.withName("ReleaseAllocator"),
        onnxruntime_c_api_h.C_POINTER.withName("RunWithBinding"),
        onnxruntime_c_api_h.C_POINTER.withName("CreateIoBinding"),
        onnxruntime_c_api_h.C_POINTER.withName("ReleaseIoBinding"),
        onnxruntime_c_api_h.C_POINTER.withName("BindInput"),
        onnxruntime_c_api_h.C_POINTER.withName("BindOutput"),
        onnxruntime_c_api_h.C_POINTER.withName("BindOutputToDevice"),
        onnxruntime_c_api_h.C_POINTER.withName("GetBoundOutputNames"),
        onnxruntime_c_api_h.C_POINTER.withName("GetBoundOutputValues"),
        onnxruntime_c_api_h.C_POINTER.withName("ClearBoundInputs"),
        onnxruntime_c_api_h.C_POINTER.withName("ClearBoundOutputs"),
        onnxruntime_c_api_h.C_POINTER.withName("TensorAt"),
        onnxruntime_c_api_h.C_POINTER.withName("CreateAndRegisterAllocator"),
        onnxruntime_c_api_h.C_POINTER.withName("SetLanguageProjection"),
        onnxruntime_c_api_h.C_POINTER.withName("SessionGetProfilingStartTimeNs"),
        onnxruntime_c_api_h.C_POINTER.withName("SetGlobalIntraOpNumThreads"),
        onnxruntime_c_api_h.C_POINTER.withName("SetGlobalInterOpNumThreads"),
        onnxruntime_c_api_h.C_POINTER.withName("SetGlobalSpinControl"),
        onnxruntime_c_api_h.C_POINTER.withName("AddInitializer"),
        onnxruntime_c_api_h.C_POINTER.withName("CreateEnvWithCustomLoggerAndGlobalThreadPools"),
        onnxruntime_c_api_h.C_POINTER.withName("SessionOptionsAppendExecutionProvider_CUDA"),
        onnxruntime_c_api_h.C_POINTER.withName("SessionOptionsAppendExecutionProvider_ROCM"),
        onnxruntime_c_api_h.C_POINTER.withName("SessionOptionsAppendExecutionProvider_OpenVINO"),
        onnxruntime_c_api_h.C_POINTER.withName("SetGlobalDenormalAsZero"),
        onnxruntime_c_api_h.C_POINTER.withName("CreateArenaCfg"),
        onnxruntime_c_api_h.C_POINTER.withName("ReleaseArenaCfg"),
        onnxruntime_c_api_h.C_POINTER.withName("ModelMetadataGetGraphDescription"),
        onnxruntime_c_api_h.C_POINTER.withName("SessionOptionsAppendExecutionProvider_TensorRT"),
        onnxruntime_c_api_h.C_POINTER.withName("SetCurrentGpuDeviceId"),
        onnxruntime_c_api_h.C_POINTER.withName("GetCurrentGpuDeviceId"),
        onnxruntime_c_api_h.C_POINTER.withName("KernelInfoGetAttributeArray_float"),
        onnxruntime_c_api_h.C_POINTER.withName("KernelInfoGetAttributeArray_int64"),
        onnxruntime_c_api_h.C_POINTER.withName("CreateArenaCfgV2"),
        onnxruntime_c_api_h.C_POINTER.withName("AddRunConfigEntry"),
        onnxruntime_c_api_h.C_POINTER.withName("CreatePrepackedWeightsContainer"),
        onnxruntime_c_api_h.C_POINTER.withName("ReleasePrepackedWeightsContainer"),
        onnxruntime_c_api_h.C_POINTER.withName("CreateSessionWithPrepackedWeightsContainer"),
        onnxruntime_c_api_h.C_POINTER.withName("CreateSessionFromArrayWithPrepackedWeightsContainer"),
        onnxruntime_c_api_h.C_POINTER.withName("SessionOptionsAppendExecutionProvider_TensorRT_V2"),
        onnxruntime_c_api_h.C_POINTER.withName("CreateTensorRTProviderOptions"),
        onnxruntime_c_api_h.C_POINTER.withName("UpdateTensorRTProviderOptions"),
        onnxruntime_c_api_h.C_POINTER.withName("GetTensorRTProviderOptionsAsString"),
        onnxruntime_c_api_h.C_POINTER.withName("ReleaseTensorRTProviderOptions"),
        onnxruntime_c_api_h.C_POINTER.withName("EnableOrtCustomOps"),
        onnxruntime_c_api_h.C_POINTER.withName("RegisterAllocator"),
        onnxruntime_c_api_h.C_POINTER.withName("UnregisterAllocator"),
        onnxruntime_c_api_h.C_POINTER.withName("IsSparseTensor"),
        onnxruntime_c_api_h.C_POINTER.withName("CreateSparseTensorAsOrtValue"),
        onnxruntime_c_api_h.C_POINTER.withName("FillSparseTensorCoo"),
        onnxruntime_c_api_h.C_POINTER.withName("FillSparseTensorCsr"),
        onnxruntime_c_api_h.C_POINTER.withName("FillSparseTensorBlockSparse"),
        onnxruntime_c_api_h.C_POINTER.withName("CreateSparseTensorWithValuesAsOrtValue"),
        onnxruntime_c_api_h.C_POINTER.withName("UseCooIndices"),
        onnxruntime_c_api_h.C_POINTER.withName("UseCsrIndices"),
        onnxruntime_c_api_h.C_POINTER.withName("UseBlockSparseIndices"),
        onnxruntime_c_api_h.C_POINTER.withName("GetSparseTensorFormat"),
        onnxruntime_c_api_h.C_POINTER.withName("GetSparseTensorValuesTypeAndShape"),
        onnxruntime_c_api_h.C_POINTER.withName("GetSparseTensorValues"),
        onnxruntime_c_api_h.C_POINTER.withName("GetSparseTensorIndicesTypeShape"),
        onnxruntime_c_api_h.C_POINTER.withName("GetSparseTensorIndices"),
        onnxruntime_c_api_h.C_POINTER.withName("HasValue"),
        onnxruntime_c_api_h.C_POINTER.withName("KernelContext_GetGPUComputeStream"),
        onnxruntime_c_api_h.C_POINTER.withName("GetTensorMemoryInfo"),
        onnxruntime_c_api_h.C_POINTER.withName("GetExecutionProviderApi"),
        onnxruntime_c_api_h.C_POINTER.withName("SessionOptionsSetCustomCreateThreadFn"),
        onnxruntime_c_api_h.C_POINTER.withName("SessionOptionsSetCustomThreadCreationOptions"),
        onnxruntime_c_api_h.C_POINTER.withName("SessionOptionsSetCustomJoinThreadFn"),
        onnxruntime_c_api_h.C_POINTER.withName("SetGlobalCustomCreateThreadFn"),
        onnxruntime_c_api_h.C_POINTER.withName("SetGlobalCustomThreadCreationOptions"),
        onnxruntime_c_api_h.C_POINTER.withName("SetGlobalCustomJoinThreadFn"),
        onnxruntime_c_api_h.C_POINTER.withName("SynchronizeBoundInputs"),
        onnxruntime_c_api_h.C_POINTER.withName("SynchronizeBoundOutputs"),
        onnxruntime_c_api_h.C_POINTER.withName("SessionOptionsAppendExecutionProvider_CUDA_V2"),
        onnxruntime_c_api_h.C_POINTER.withName("CreateCUDAProviderOptions"),
        onnxruntime_c_api_h.C_POINTER.withName("UpdateCUDAProviderOptions"),
        onnxruntime_c_api_h.C_POINTER.withName("GetCUDAProviderOptionsAsString"),
        onnxruntime_c_api_h.C_POINTER.withName("ReleaseCUDAProviderOptions"),
        onnxruntime_c_api_h.C_POINTER.withName("SessionOptionsAppendExecutionProvider_MIGraphX"),
        onnxruntime_c_api_h.C_POINTER.withName("AddExternalInitializers"),
        onnxruntime_c_api_h.C_POINTER.withName("CreateOpAttr"),
        onnxruntime_c_api_h.C_POINTER.withName("ReleaseOpAttr"),
        onnxruntime_c_api_h.C_POINTER.withName("CreateOp"),
        onnxruntime_c_api_h.C_POINTER.withName("InvokeOp"),
        onnxruntime_c_api_h.C_POINTER.withName("ReleaseOp"),
        onnxruntime_c_api_h.C_POINTER.withName("SessionOptionsAppendExecutionProvider"),
        onnxruntime_c_api_h.C_POINTER.withName("CopyKernelInfo"),
        onnxruntime_c_api_h.C_POINTER.withName("ReleaseKernelInfo"),
        onnxruntime_c_api_h.C_POINTER.withName("GetTrainingApi"),
        onnxruntime_c_api_h.C_POINTER.withName("SessionOptionsAppendExecutionProvider_CANN"),
        onnxruntime_c_api_h.C_POINTER.withName("CreateCANNProviderOptions"),
        onnxruntime_c_api_h.C_POINTER.withName("UpdateCANNProviderOptions"),
        onnxruntime_c_api_h.C_POINTER.withName("GetCANNProviderOptionsAsString"),
        onnxruntime_c_api_h.C_POINTER.withName("ReleaseCANNProviderOptions"),
        onnxruntime_c_api_h.C_POINTER.withName("MemoryInfoGetDeviceType"),
        onnxruntime_c_api_h.C_POINTER.withName("UpdateEnvWithCustomLogLevel"),
        onnxruntime_c_api_h.C_POINTER.withName("SetGlobalIntraOpThreadAffinity"),
        onnxruntime_c_api_h.C_POINTER.withName("RegisterCustomOpsLibrary_V2"),
        onnxruntime_c_api_h.C_POINTER.withName("RegisterCustomOpsUsingFunction"),
        onnxruntime_c_api_h.C_POINTER.withName("KernelInfo_GetInputCount"),
        onnxruntime_c_api_h.C_POINTER.withName("KernelInfo_GetOutputCount"),
        onnxruntime_c_api_h.C_POINTER.withName("KernelInfo_GetInputName"),
        onnxruntime_c_api_h.C_POINTER.withName("KernelInfo_GetOutputName"),
        onnxruntime_c_api_h.C_POINTER.withName("KernelInfo_GetInputTypeInfo"),
        onnxruntime_c_api_h.C_POINTER.withName("KernelInfo_GetOutputTypeInfo"),
        onnxruntime_c_api_h.C_POINTER.withName("KernelInfoGetAttribute_tensor"),
        onnxruntime_c_api_h.C_POINTER.withName("HasSessionConfigEntry"),
        onnxruntime_c_api_h.C_POINTER.withName("GetSessionConfigEntry"),
        onnxruntime_c_api_h.C_POINTER.withName("SessionOptionsAppendExecutionProvider_Dnnl"),
        onnxruntime_c_api_h.C_POINTER.withName("CreateDnnlProviderOptions"),
        onnxruntime_c_api_h.C_POINTER.withName("UpdateDnnlProviderOptions"),
        onnxruntime_c_api_h.C_POINTER.withName("GetDnnlProviderOptionsAsString"),
        onnxruntime_c_api_h.C_POINTER.withName("ReleaseDnnlProviderOptions"),
        onnxruntime_c_api_h.C_POINTER.withName("KernelInfo_GetNodeName"),
        onnxruntime_c_api_h.C_POINTER.withName("KernelInfo_GetLogger"),
        onnxruntime_c_api_h.C_POINTER.withName("KernelContext_GetLogger"),
        onnxruntime_c_api_h.C_POINTER.withName("Logger_LogMessage"),
        onnxruntime_c_api_h.C_POINTER.withName("Logger_GetLoggingSeverityLevel"),
        onnxruntime_c_api_h.C_POINTER.withName("KernelInfoGetConstantInput_tensor"),
        onnxruntime_c_api_h.C_POINTER.withName("CastTypeInfoToOptionalTypeInfo"),
        onnxruntime_c_api_h.C_POINTER.withName("GetOptionalContainedTypeInfo"),
        onnxruntime_c_api_h.C_POINTER.withName("GetResizedStringTensorElementBuffer"),
        onnxruntime_c_api_h.C_POINTER.withName("KernelContext_GetAllocator"),
        onnxruntime_c_api_h.C_POINTER.withName("GetBuildInfoString"),
        onnxruntime_c_api_h.C_POINTER.withName("CreateROCMProviderOptions"),
        onnxruntime_c_api_h.C_POINTER.withName("UpdateROCMProviderOptions"),
        onnxruntime_c_api_h.C_POINTER.withName("GetROCMProviderOptionsAsString"),
        onnxruntime_c_api_h.C_POINTER.withName("ReleaseROCMProviderOptions"),
        onnxruntime_c_api_h.C_POINTER.withName("CreateAndRegisterAllocatorV2"),
        onnxruntime_c_api_h.C_POINTER.withName("RunAsync"),
        onnxruntime_c_api_h.C_POINTER.withName("UpdateTensorRTProviderOptionsWithValue"),
        onnxruntime_c_api_h.C_POINTER.withName("GetTensorRTProviderOptionsByName"),
        onnxruntime_c_api_h.C_POINTER.withName("UpdateCUDAProviderOptionsWithValue"),
        onnxruntime_c_api_h.C_POINTER.withName("GetCUDAProviderOptionsByName"),
        onnxruntime_c_api_h.C_POINTER.withName("KernelContext_GetResource"),
        onnxruntime_c_api_h.C_POINTER.withName("SetUserLoggingFunction"),
        onnxruntime_c_api_h.C_POINTER.withName("ShapeInferContext_GetInputCount"),
        onnxruntime_c_api_h.C_POINTER.withName("ShapeInferContext_GetInputTypeShape"),
        onnxruntime_c_api_h.C_POINTER.withName("ShapeInferContext_GetAttribute"),
        onnxruntime_c_api_h.C_POINTER.withName("ShapeInferContext_SetOutputTypeShape"),
        onnxruntime_c_api_h.C_POINTER.withName("SetSymbolicDimensions"),
        onnxruntime_c_api_h.C_POINTER.withName("ReadOpAttr"),
        onnxruntime_c_api_h.C_POINTER.withName("SetDeterministicCompute"),
        onnxruntime_c_api_h.C_POINTER.withName("KernelContext_ParallelFor"),
        onnxruntime_c_api_h.C_POINTER.withName("SessionOptionsAppendExecutionProvider_OpenVINO_V2"),
        onnxruntime_c_api_h.C_POINTER.withName("SessionOptionsAppendExecutionProvider_VitisAI"),
        onnxruntime_c_api_h.C_POINTER.withName("KernelContext_GetScratchBuffer"),
        onnxruntime_c_api_h.C_POINTER.withName("KernelInfoGetAllocator"),
        onnxruntime_c_api_h.C_POINTER.withName("AddExternalInitializersFromFilesInMemory"),
        onnxruntime_c_api_h.C_POINTER.withName("CreateLoraAdapter"),
        onnxruntime_c_api_h.C_POINTER.withName("CreateLoraAdapterFromArray"),
        onnxruntime_c_api_h.C_POINTER.withName("ReleaseLoraAdapter"),
        onnxruntime_c_api_h.C_POINTER.withName("RunOptionsAddActiveLoraAdapter"),
        onnxruntime_c_api_h.C_POINTER.withName("SetEpDynamicOptions")
    ).withName("OrtApi");

    /**
     * The layout of this struct
     */
    public static final GroupLayout layout() {
        return $LAYOUT;
    }

    /**
     * {@snippet lang=c :
     * OrtStatus *(*CreateStatus)(OrtErrorCode, const char *)
     * }
     */
    private static class CreateStatus {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_INT,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,int _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CreateStatus$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CreateStatus"));

    private static final long CreateStatus$OFFSET = $LAYOUT.byteOffset(groupElement("CreateStatus"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatus *(*CreateStatus)(OrtErrorCode, const char *)
     * }
     */
    public static MemorySegment CreateStatus(MemorySegment struct, int _x0, MemorySegment _x1) {
        var funcPtr = struct.get(CreateStatus$LAYOUT, CreateStatus$OFFSET);
        return CreateStatus.invoke(funcPtr, _x0, _x1);
    }

    /**
     * {@snippet lang=c :
     * OrtErrorCode (*GetErrorCode)(const OrtStatus *)
     * }
     */
    private static class GetErrorCode {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_INT,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetErrorCode$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetErrorCode"));

    private static final long GetErrorCode$OFFSET = $LAYOUT.byteOffset(groupElement("GetErrorCode"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtErrorCode (*GetErrorCode)(const OrtStatus *)
     * }
     */
    public static int GetErrorCode(MemorySegment struct, MemorySegment _x0) {
        var funcPtr = struct.get(GetErrorCode$LAYOUT, GetErrorCode$OFFSET);
        return GetErrorCode.invoke(funcPtr, _x0);
    }

    /**
     * {@snippet lang=c :
     * const char *(*GetErrorMessage)(const OrtStatus *)
     * }
     */
    private static class GetErrorMessage {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetErrorMessage$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetErrorMessage"));

    private static final long GetErrorMessage$OFFSET = $LAYOUT.byteOffset(groupElement("GetErrorMessage"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * const char *(*GetErrorMessage)(const OrtStatus *)
     * }
     */
    public static MemorySegment GetErrorMessage(MemorySegment struct, MemorySegment _x0) {
        var funcPtr = struct.get(GetErrorMessage$LAYOUT, GetErrorMessage$OFFSET);
        return GetErrorMessage.invoke(funcPtr, _x0);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateEnv)(OrtLoggingLevel, const char *, OrtEnv **)
     * }
     */
    private static class CreateEnv {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_INT,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,int _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CreateEnv$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CreateEnv"));

    private static final long CreateEnv$OFFSET = $LAYOUT.byteOffset(groupElement("CreateEnv"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateEnv)(OrtLoggingLevel, const char *, OrtEnv **)
     * }
     */
    public static MemorySegment CreateEnv(MemorySegment struct, int _x0, MemorySegment _x1, MemorySegment _x2) {
        var funcPtr = struct.get(CreateEnv$LAYOUT, CreateEnv$OFFSET);
        return CreateEnv.invoke(funcPtr, _x0, _x1, _x2);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateEnvWithCustomLogger)(OrtLoggingFunction, void *, OrtLoggingLevel, const char *, OrtEnv **)
     * }
     */
    private static class CreateEnvWithCustomLogger {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_INT,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, int _x2, MemorySegment _x3, MemorySegment _x4) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CreateEnvWithCustomLogger$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CreateEnvWithCustomLogger"));

    private static final long CreateEnvWithCustomLogger$OFFSET = $LAYOUT.byteOffset(groupElement("CreateEnvWithCustomLogger"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateEnvWithCustomLogger)(OrtLoggingFunction, void *, OrtLoggingLevel, const char *, OrtEnv **)
     * }
     */
    public static MemorySegment CreateEnvWithCustomLogger(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, int _x2, MemorySegment _x3, MemorySegment _x4) {
        var funcPtr = struct.get(CreateEnvWithCustomLogger$LAYOUT, CreateEnvWithCustomLogger$OFFSET);
        return CreateEnvWithCustomLogger.invoke(funcPtr, _x0, _x1, _x2, _x3, _x4);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*EnableTelemetryEvents)(const OrtEnv *)
     * }
     */
    private static class EnableTelemetryEvents {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout EnableTelemetryEvents$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("EnableTelemetryEvents"));

    private static final long EnableTelemetryEvents$OFFSET = $LAYOUT.byteOffset(groupElement("EnableTelemetryEvents"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*EnableTelemetryEvents)(const OrtEnv *)
     * }
     */
    public static MemorySegment EnableTelemetryEvents(MemorySegment struct, MemorySegment _x0) {
        var funcPtr = struct.get(EnableTelemetryEvents$LAYOUT, EnableTelemetryEvents$OFFSET);
        return EnableTelemetryEvents.invoke(funcPtr, _x0);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*DisableTelemetryEvents)(const OrtEnv *)
     * }
     */
    private static class DisableTelemetryEvents {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout DisableTelemetryEvents$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("DisableTelemetryEvents"));

    private static final long DisableTelemetryEvents$OFFSET = $LAYOUT.byteOffset(groupElement("DisableTelemetryEvents"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*DisableTelemetryEvents)(const OrtEnv *)
     * }
     */
    public static MemorySegment DisableTelemetryEvents(MemorySegment struct, MemorySegment _x0) {
        var funcPtr = struct.get(DisableTelemetryEvents$LAYOUT, DisableTelemetryEvents$OFFSET);
        return DisableTelemetryEvents.invoke(funcPtr, _x0);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSession)(const OrtEnv *, const char *, const OrtSessionOptions *, OrtSession **)
     * }
     */
    private static class CreateSession {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CreateSession$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CreateSession"));

    private static final long CreateSession$OFFSET = $LAYOUT.byteOffset(groupElement("CreateSession"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSession)(const OrtEnv *, const char *, const OrtSessionOptions *, OrtSession **)
     * }
     */
    public static MemorySegment CreateSession(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
        var funcPtr = struct.get(CreateSession$LAYOUT, CreateSession$OFFSET);
        return CreateSession.invoke(funcPtr, _x0, _x1, _x2, _x3);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSessionFromArray)(const OrtEnv *, const void *, size_t, const OrtSessionOptions *, OrtSession **)
     * }
     */
    private static class CreateSessionFromArray {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3, MemorySegment _x4) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CreateSessionFromArray$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CreateSessionFromArray"));

    private static final long CreateSessionFromArray$OFFSET = $LAYOUT.byteOffset(groupElement("CreateSessionFromArray"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSessionFromArray)(const OrtEnv *, const void *, size_t, const OrtSessionOptions *, OrtSession **)
     * }
     */
    public static MemorySegment CreateSessionFromArray(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3, MemorySegment _x4) {
        var funcPtr = struct.get(CreateSessionFromArray$LAYOUT, CreateSessionFromArray$OFFSET);
        return CreateSessionFromArray.invoke(funcPtr, _x0, _x1, _x2, _x3, _x4);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*Run)(OrtSession *, const OrtRunOptions *, const char *const *, const OrtValue *const *, size_t, const char *const *, size_t, OrtValue **)
     * }
     */
    private static class Run {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, long _x4, MemorySegment _x5, long _x6, MemorySegment _x7) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6, _x7);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout Run$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("Run"));

    private static final long Run$OFFSET = $LAYOUT.byteOffset(groupElement("Run"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Run)(OrtSession *, const OrtRunOptions *, const char *const *, const OrtValue *const *, size_t, const char *const *, size_t, OrtValue **)
     * }
     */
    public static MemorySegment Run(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, long _x4, MemorySegment _x5, long _x6, MemorySegment _x7) {
        var funcPtr = struct.get(Run$LAYOUT, Run$OFFSET);
        return Run.invoke(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6, _x7);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSessionOptions)(OrtSessionOptions **)
     * }
     */
    private static class CreateSessionOptions {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CreateSessionOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CreateSessionOptions"));

    private static final long CreateSessionOptions$OFFSET = $LAYOUT.byteOffset(groupElement("CreateSessionOptions"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSessionOptions)(OrtSessionOptions **)
     * }
     */
    public static MemorySegment CreateSessionOptions(MemorySegment struct, MemorySegment _x0) {
        var funcPtr = struct.get(CreateSessionOptions$LAYOUT, CreateSessionOptions$OFFSET);
        return CreateSessionOptions.invoke(funcPtr, _x0);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SetOptimizedModelFilePath)(OrtSessionOptions *, const char *)
     * }
     */
    private static class SetOptimizedModelFilePath {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SetOptimizedModelFilePath$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SetOptimizedModelFilePath"));

    private static final long SetOptimizedModelFilePath$OFFSET = $LAYOUT.byteOffset(groupElement("SetOptimizedModelFilePath"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetOptimizedModelFilePath)(OrtSessionOptions *, const char *)
     * }
     */
    public static MemorySegment SetOptimizedModelFilePath(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {
        var funcPtr = struct.get(SetOptimizedModelFilePath$LAYOUT, SetOptimizedModelFilePath$OFFSET);
        return SetOptimizedModelFilePath.invoke(funcPtr, _x0, _x1);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CloneSessionOptions)(const OrtSessionOptions *, OrtSessionOptions **)
     * }
     */
    private static class CloneSessionOptions {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CloneSessionOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CloneSessionOptions"));

    private static final long CloneSessionOptions$OFFSET = $LAYOUT.byteOffset(groupElement("CloneSessionOptions"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CloneSessionOptions)(const OrtSessionOptions *, OrtSessionOptions **)
     * }
     */
    public static MemorySegment CloneSessionOptions(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {
        var funcPtr = struct.get(CloneSessionOptions$LAYOUT, CloneSessionOptions$OFFSET);
        return CloneSessionOptions.invoke(funcPtr, _x0, _x1);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SetSessionExecutionMode)(OrtSessionOptions *, ExecutionMode)
     * }
     */
    private static class SetSessionExecutionMode {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_INT
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SetSessionExecutionMode$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SetSessionExecutionMode"));

    private static final long SetSessionExecutionMode$OFFSET = $LAYOUT.byteOffset(groupElement("SetSessionExecutionMode"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetSessionExecutionMode)(OrtSessionOptions *, ExecutionMode)
     * }
     */
    public static MemorySegment SetSessionExecutionMode(MemorySegment struct, MemorySegment _x0, int _x1) {
        var funcPtr = struct.get(SetSessionExecutionMode$LAYOUT, SetSessionExecutionMode$OFFSET);
        return SetSessionExecutionMode.invoke(funcPtr, _x0, _x1);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*EnableProfiling)(OrtSessionOptions *, const char *)
     * }
     */
    private static class EnableProfiling {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout EnableProfiling$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("EnableProfiling"));

    private static final long EnableProfiling$OFFSET = $LAYOUT.byteOffset(groupElement("EnableProfiling"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*EnableProfiling)(OrtSessionOptions *, const char *)
     * }
     */
    public static MemorySegment EnableProfiling(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {
        var funcPtr = struct.get(EnableProfiling$LAYOUT, EnableProfiling$OFFSET);
        return EnableProfiling.invoke(funcPtr, _x0, _x1);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*DisableProfiling)(OrtSessionOptions *)
     * }
     */
    private static class DisableProfiling {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout DisableProfiling$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("DisableProfiling"));

    private static final long DisableProfiling$OFFSET = $LAYOUT.byteOffset(groupElement("DisableProfiling"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*DisableProfiling)(OrtSessionOptions *)
     * }
     */
    public static MemorySegment DisableProfiling(MemorySegment struct, MemorySegment _x0) {
        var funcPtr = struct.get(DisableProfiling$LAYOUT, DisableProfiling$OFFSET);
        return DisableProfiling.invoke(funcPtr, _x0);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*EnableMemPattern)(OrtSessionOptions *)
     * }
     */
    private static class EnableMemPattern {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout EnableMemPattern$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("EnableMemPattern"));

    private static final long EnableMemPattern$OFFSET = $LAYOUT.byteOffset(groupElement("EnableMemPattern"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*EnableMemPattern)(OrtSessionOptions *)
     * }
     */
    public static MemorySegment EnableMemPattern(MemorySegment struct, MemorySegment _x0) {
        var funcPtr = struct.get(EnableMemPattern$LAYOUT, EnableMemPattern$OFFSET);
        return EnableMemPattern.invoke(funcPtr, _x0);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*DisableMemPattern)(OrtSessionOptions *)
     * }
     */
    private static class DisableMemPattern {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout DisableMemPattern$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("DisableMemPattern"));

    private static final long DisableMemPattern$OFFSET = $LAYOUT.byteOffset(groupElement("DisableMemPattern"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*DisableMemPattern)(OrtSessionOptions *)
     * }
     */
    public static MemorySegment DisableMemPattern(MemorySegment struct, MemorySegment _x0) {
        var funcPtr = struct.get(DisableMemPattern$LAYOUT, DisableMemPattern$OFFSET);
        return DisableMemPattern.invoke(funcPtr, _x0);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*EnableCpuMemArena)(OrtSessionOptions *)
     * }
     */
    private static class EnableCpuMemArena {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout EnableCpuMemArena$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("EnableCpuMemArena"));

    private static final long EnableCpuMemArena$OFFSET = $LAYOUT.byteOffset(groupElement("EnableCpuMemArena"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*EnableCpuMemArena)(OrtSessionOptions *)
     * }
     */
    public static MemorySegment EnableCpuMemArena(MemorySegment struct, MemorySegment _x0) {
        var funcPtr = struct.get(EnableCpuMemArena$LAYOUT, EnableCpuMemArena$OFFSET);
        return EnableCpuMemArena.invoke(funcPtr, _x0);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*DisableCpuMemArena)(OrtSessionOptions *)
     * }
     */
    private static class DisableCpuMemArena {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout DisableCpuMemArena$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("DisableCpuMemArena"));

    private static final long DisableCpuMemArena$OFFSET = $LAYOUT.byteOffset(groupElement("DisableCpuMemArena"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*DisableCpuMemArena)(OrtSessionOptions *)
     * }
     */
    public static MemorySegment DisableCpuMemArena(MemorySegment struct, MemorySegment _x0) {
        var funcPtr = struct.get(DisableCpuMemArena$LAYOUT, DisableCpuMemArena$OFFSET);
        return DisableCpuMemArena.invoke(funcPtr, _x0);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SetSessionLogId)(OrtSessionOptions *, const char *)
     * }
     */
    private static class SetSessionLogId {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SetSessionLogId$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SetSessionLogId"));

    private static final long SetSessionLogId$OFFSET = $LAYOUT.byteOffset(groupElement("SetSessionLogId"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetSessionLogId)(OrtSessionOptions *, const char *)
     * }
     */
    public static MemorySegment SetSessionLogId(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {
        var funcPtr = struct.get(SetSessionLogId$LAYOUT, SetSessionLogId$OFFSET);
        return SetSessionLogId.invoke(funcPtr, _x0, _x1);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SetSessionLogVerbosityLevel)(OrtSessionOptions *, int)
     * }
     */
    private static class SetSessionLogVerbosityLevel {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_INT
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SetSessionLogVerbosityLevel$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SetSessionLogVerbosityLevel"));

    private static final long SetSessionLogVerbosityLevel$OFFSET = $LAYOUT.byteOffset(groupElement("SetSessionLogVerbosityLevel"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetSessionLogVerbosityLevel)(OrtSessionOptions *, int)
     * }
     */
    public static MemorySegment SetSessionLogVerbosityLevel(MemorySegment struct, MemorySegment _x0, int _x1) {
        var funcPtr = struct.get(SetSessionLogVerbosityLevel$LAYOUT, SetSessionLogVerbosityLevel$OFFSET);
        return SetSessionLogVerbosityLevel.invoke(funcPtr, _x0, _x1);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SetSessionLogSeverityLevel)(OrtSessionOptions *, int)
     * }
     */
    private static class SetSessionLogSeverityLevel {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_INT
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SetSessionLogSeverityLevel$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SetSessionLogSeverityLevel"));

    private static final long SetSessionLogSeverityLevel$OFFSET = $LAYOUT.byteOffset(groupElement("SetSessionLogSeverityLevel"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetSessionLogSeverityLevel)(OrtSessionOptions *, int)
     * }
     */
    public static MemorySegment SetSessionLogSeverityLevel(MemorySegment struct, MemorySegment _x0, int _x1) {
        var funcPtr = struct.get(SetSessionLogSeverityLevel$LAYOUT, SetSessionLogSeverityLevel$OFFSET);
        return SetSessionLogSeverityLevel.invoke(funcPtr, _x0, _x1);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SetSessionGraphOptimizationLevel)(OrtSessionOptions *, GraphOptimizationLevel)
     * }
     */
    private static class SetSessionGraphOptimizationLevel {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_INT
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SetSessionGraphOptimizationLevel$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SetSessionGraphOptimizationLevel"));

    private static final long SetSessionGraphOptimizationLevel$OFFSET = $LAYOUT.byteOffset(groupElement("SetSessionGraphOptimizationLevel"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetSessionGraphOptimizationLevel)(OrtSessionOptions *, GraphOptimizationLevel)
     * }
     */
    public static MemorySegment SetSessionGraphOptimizationLevel(MemorySegment struct, MemorySegment _x0, int _x1) {
        var funcPtr = struct.get(SetSessionGraphOptimizationLevel$LAYOUT, SetSessionGraphOptimizationLevel$OFFSET);
        return SetSessionGraphOptimizationLevel.invoke(funcPtr, _x0, _x1);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SetIntraOpNumThreads)(OrtSessionOptions *, int)
     * }
     */
    private static class SetIntraOpNumThreads {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_INT
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SetIntraOpNumThreads$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SetIntraOpNumThreads"));

    private static final long SetIntraOpNumThreads$OFFSET = $LAYOUT.byteOffset(groupElement("SetIntraOpNumThreads"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetIntraOpNumThreads)(OrtSessionOptions *, int)
     * }
     */
    public static MemorySegment SetIntraOpNumThreads(MemorySegment struct, MemorySegment _x0, int _x1) {
        var funcPtr = struct.get(SetIntraOpNumThreads$LAYOUT, SetIntraOpNumThreads$OFFSET);
        return SetIntraOpNumThreads.invoke(funcPtr, _x0, _x1);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SetInterOpNumThreads)(OrtSessionOptions *, int)
     * }
     */
    private static class SetInterOpNumThreads {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_INT
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SetInterOpNumThreads$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SetInterOpNumThreads"));

    private static final long SetInterOpNumThreads$OFFSET = $LAYOUT.byteOffset(groupElement("SetInterOpNumThreads"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetInterOpNumThreads)(OrtSessionOptions *, int)
     * }
     */
    public static MemorySegment SetInterOpNumThreads(MemorySegment struct, MemorySegment _x0, int _x1) {
        var funcPtr = struct.get(SetInterOpNumThreads$LAYOUT, SetInterOpNumThreads$OFFSET);
        return SetInterOpNumThreads.invoke(funcPtr, _x0, _x1);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateCustomOpDomain)(const char *, OrtCustomOpDomain **)
     * }
     */
    private static class CreateCustomOpDomain {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CreateCustomOpDomain$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CreateCustomOpDomain"));

    private static final long CreateCustomOpDomain$OFFSET = $LAYOUT.byteOffset(groupElement("CreateCustomOpDomain"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateCustomOpDomain)(const char *, OrtCustomOpDomain **)
     * }
     */
    public static MemorySegment CreateCustomOpDomain(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {
        var funcPtr = struct.get(CreateCustomOpDomain$LAYOUT, CreateCustomOpDomain$OFFSET);
        return CreateCustomOpDomain.invoke(funcPtr, _x0, _x1);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CustomOpDomain_Add)(OrtCustomOpDomain *, const OrtCustomOp *)
     * }
     */
    private static class CustomOpDomain_Add {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CustomOpDomain_Add$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CustomOpDomain_Add"));

    private static final long CustomOpDomain_Add$OFFSET = $LAYOUT.byteOffset(groupElement("CustomOpDomain_Add"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CustomOpDomain_Add)(OrtCustomOpDomain *, const OrtCustomOp *)
     * }
     */
    public static MemorySegment CustomOpDomain_Add(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {
        var funcPtr = struct.get(CustomOpDomain_Add$LAYOUT, CustomOpDomain_Add$OFFSET);
        return CustomOpDomain_Add.invoke(funcPtr, _x0, _x1);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*AddCustomOpDomain)(OrtSessionOptions *, OrtCustomOpDomain *)
     * }
     */
    private static class AddCustomOpDomain {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout AddCustomOpDomain$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("AddCustomOpDomain"));

    private static final long AddCustomOpDomain$OFFSET = $LAYOUT.byteOffset(groupElement("AddCustomOpDomain"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AddCustomOpDomain)(OrtSessionOptions *, OrtCustomOpDomain *)
     * }
     */
    public static MemorySegment AddCustomOpDomain(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {
        var funcPtr = struct.get(AddCustomOpDomain$LAYOUT, AddCustomOpDomain$OFFSET);
        return AddCustomOpDomain.invoke(funcPtr, _x0, _x1);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*RegisterCustomOpsLibrary)(OrtSessionOptions *, const char *, void **)
     * }
     */
    private static class RegisterCustomOpsLibrary {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout RegisterCustomOpsLibrary$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("RegisterCustomOpsLibrary"));

    private static final long RegisterCustomOpsLibrary$OFFSET = $LAYOUT.byteOffset(groupElement("RegisterCustomOpsLibrary"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RegisterCustomOpsLibrary)(OrtSessionOptions *, const char *, void **)
     * }
     */
    public static MemorySegment RegisterCustomOpsLibrary(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
        var funcPtr = struct.get(RegisterCustomOpsLibrary$LAYOUT, RegisterCustomOpsLibrary$OFFSET);
        return RegisterCustomOpsLibrary.invoke(funcPtr, _x0, _x1, _x2);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetInputCount)(const OrtSession *, size_t *)
     * }
     */
    private static class SessionGetInputCount {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SessionGetInputCount$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SessionGetInputCount"));

    private static final long SessionGetInputCount$OFFSET = $LAYOUT.byteOffset(groupElement("SessionGetInputCount"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetInputCount)(const OrtSession *, size_t *)
     * }
     */
    public static MemorySegment SessionGetInputCount(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {
        var funcPtr = struct.get(SessionGetInputCount$LAYOUT, SessionGetInputCount$OFFSET);
        return SessionGetInputCount.invoke(funcPtr, _x0, _x1);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetOutputCount)(const OrtSession *, size_t *)
     * }
     */
    private static class SessionGetOutputCount {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SessionGetOutputCount$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SessionGetOutputCount"));

    private static final long SessionGetOutputCount$OFFSET = $LAYOUT.byteOffset(groupElement("SessionGetOutputCount"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetOutputCount)(const OrtSession *, size_t *)
     * }
     */
    public static MemorySegment SessionGetOutputCount(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {
        var funcPtr = struct.get(SessionGetOutputCount$LAYOUT, SessionGetOutputCount$OFFSET);
        return SessionGetOutputCount.invoke(funcPtr, _x0, _x1);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetOverridableInitializerCount)(const OrtSession *, size_t *)
     * }
     */
    private static class SessionGetOverridableInitializerCount {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SessionGetOverridableInitializerCount$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SessionGetOverridableInitializerCount"));

    private static final long SessionGetOverridableInitializerCount$OFFSET = $LAYOUT.byteOffset(groupElement("SessionGetOverridableInitializerCount"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetOverridableInitializerCount)(const OrtSession *, size_t *)
     * }
     */
    public static MemorySegment SessionGetOverridableInitializerCount(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {
        var funcPtr = struct.get(SessionGetOverridableInitializerCount$LAYOUT, SessionGetOverridableInitializerCount$OFFSET);
        return SessionGetOverridableInitializerCount.invoke(funcPtr, _x0, _x1);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetInputTypeInfo)(const OrtSession *, size_t, OrtTypeInfo **)
     * }
     */
    private static class SessionGetInputTypeInfo {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, long _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SessionGetInputTypeInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SessionGetInputTypeInfo"));

    private static final long SessionGetInputTypeInfo$OFFSET = $LAYOUT.byteOffset(groupElement("SessionGetInputTypeInfo"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetInputTypeInfo)(const OrtSession *, size_t, OrtTypeInfo **)
     * }
     */
    public static MemorySegment SessionGetInputTypeInfo(MemorySegment struct, MemorySegment _x0, long _x1, MemorySegment _x2) {
        var funcPtr = struct.get(SessionGetInputTypeInfo$LAYOUT, SessionGetInputTypeInfo$OFFSET);
        return SessionGetInputTypeInfo.invoke(funcPtr, _x0, _x1, _x2);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetOutputTypeInfo)(const OrtSession *, size_t, OrtTypeInfo **)
     * }
     */
    private static class SessionGetOutputTypeInfo {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, long _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SessionGetOutputTypeInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SessionGetOutputTypeInfo"));

    private static final long SessionGetOutputTypeInfo$OFFSET = $LAYOUT.byteOffset(groupElement("SessionGetOutputTypeInfo"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetOutputTypeInfo)(const OrtSession *, size_t, OrtTypeInfo **)
     * }
     */
    public static MemorySegment SessionGetOutputTypeInfo(MemorySegment struct, MemorySegment _x0, long _x1, MemorySegment _x2) {
        var funcPtr = struct.get(SessionGetOutputTypeInfo$LAYOUT, SessionGetOutputTypeInfo$OFFSET);
        return SessionGetOutputTypeInfo.invoke(funcPtr, _x0, _x1, _x2);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetOverridableInitializerTypeInfo)(const OrtSession *, size_t, OrtTypeInfo **)
     * }
     */
    private static class SessionGetOverridableInitializerTypeInfo {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, long _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SessionGetOverridableInitializerTypeInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SessionGetOverridableInitializerTypeInfo"));

    private static final long SessionGetOverridableInitializerTypeInfo$OFFSET = $LAYOUT.byteOffset(groupElement("SessionGetOverridableInitializerTypeInfo"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetOverridableInitializerTypeInfo)(const OrtSession *, size_t, OrtTypeInfo **)
     * }
     */
    public static MemorySegment SessionGetOverridableInitializerTypeInfo(MemorySegment struct, MemorySegment _x0, long _x1, MemorySegment _x2) {
        var funcPtr = struct.get(SessionGetOverridableInitializerTypeInfo$LAYOUT, SessionGetOverridableInitializerTypeInfo$OFFSET);
        return SessionGetOverridableInitializerTypeInfo.invoke(funcPtr, _x0, _x1, _x2);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetInputName)(const OrtSession *, size_t, OrtAllocator *, char **)
     * }
     */
    private static class SessionGetInputName {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, long _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SessionGetInputName$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SessionGetInputName"));

    private static final long SessionGetInputName$OFFSET = $LAYOUT.byteOffset(groupElement("SessionGetInputName"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetInputName)(const OrtSession *, size_t, OrtAllocator *, char **)
     * }
     */
    public static MemorySegment SessionGetInputName(MemorySegment struct, MemorySegment _x0, long _x1, MemorySegment _x2, MemorySegment _x3) {
        var funcPtr = struct.get(SessionGetInputName$LAYOUT, SessionGetInputName$OFFSET);
        return SessionGetInputName.invoke(funcPtr, _x0, _x1, _x2, _x3);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetOutputName)(const OrtSession *, size_t, OrtAllocator *, char **)
     * }
     */
    private static class SessionGetOutputName {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, long _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SessionGetOutputName$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SessionGetOutputName"));

    private static final long SessionGetOutputName$OFFSET = $LAYOUT.byteOffset(groupElement("SessionGetOutputName"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetOutputName)(const OrtSession *, size_t, OrtAllocator *, char **)
     * }
     */
    public static MemorySegment SessionGetOutputName(MemorySegment struct, MemorySegment _x0, long _x1, MemorySegment _x2, MemorySegment _x3) {
        var funcPtr = struct.get(SessionGetOutputName$LAYOUT, SessionGetOutputName$OFFSET);
        return SessionGetOutputName.invoke(funcPtr, _x0, _x1, _x2, _x3);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetOverridableInitializerName)(const OrtSession *, size_t, OrtAllocator *, char **)
     * }
     */
    private static class SessionGetOverridableInitializerName {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, long _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SessionGetOverridableInitializerName$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SessionGetOverridableInitializerName"));

    private static final long SessionGetOverridableInitializerName$OFFSET = $LAYOUT.byteOffset(groupElement("SessionGetOverridableInitializerName"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetOverridableInitializerName)(const OrtSession *, size_t, OrtAllocator *, char **)
     * }
     */
    public static MemorySegment SessionGetOverridableInitializerName(MemorySegment struct, MemorySegment _x0, long _x1, MemorySegment _x2, MemorySegment _x3) {
        var funcPtr = struct.get(SessionGetOverridableInitializerName$LAYOUT, SessionGetOverridableInitializerName$OFFSET);
        return SessionGetOverridableInitializerName.invoke(funcPtr, _x0, _x1, _x2, _x3);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateRunOptions)(OrtRunOptions **)
     * }
     */
    private static class CreateRunOptions {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CreateRunOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CreateRunOptions"));

    private static final long CreateRunOptions$OFFSET = $LAYOUT.byteOffset(groupElement("CreateRunOptions"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateRunOptions)(OrtRunOptions **)
     * }
     */
    public static MemorySegment CreateRunOptions(MemorySegment struct, MemorySegment _x0) {
        var funcPtr = struct.get(CreateRunOptions$LAYOUT, CreateRunOptions$OFFSET);
        return CreateRunOptions.invoke(funcPtr, _x0);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsSetRunLogVerbosityLevel)(OrtRunOptions *, int)
     * }
     */
    private static class RunOptionsSetRunLogVerbosityLevel {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_INT
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout RunOptionsSetRunLogVerbosityLevel$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("RunOptionsSetRunLogVerbosityLevel"));

    private static final long RunOptionsSetRunLogVerbosityLevel$OFFSET = $LAYOUT.byteOffset(groupElement("RunOptionsSetRunLogVerbosityLevel"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsSetRunLogVerbosityLevel)(OrtRunOptions *, int)
     * }
     */
    public static MemorySegment RunOptionsSetRunLogVerbosityLevel(MemorySegment struct, MemorySegment _x0, int _x1) {
        var funcPtr = struct.get(RunOptionsSetRunLogVerbosityLevel$LAYOUT, RunOptionsSetRunLogVerbosityLevel$OFFSET);
        return RunOptionsSetRunLogVerbosityLevel.invoke(funcPtr, _x0, _x1);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsSetRunLogSeverityLevel)(OrtRunOptions *, int)
     * }
     */
    private static class RunOptionsSetRunLogSeverityLevel {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_INT
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout RunOptionsSetRunLogSeverityLevel$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("RunOptionsSetRunLogSeverityLevel"));

    private static final long RunOptionsSetRunLogSeverityLevel$OFFSET = $LAYOUT.byteOffset(groupElement("RunOptionsSetRunLogSeverityLevel"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsSetRunLogSeverityLevel)(OrtRunOptions *, int)
     * }
     */
    public static MemorySegment RunOptionsSetRunLogSeverityLevel(MemorySegment struct, MemorySegment _x0, int _x1) {
        var funcPtr = struct.get(RunOptionsSetRunLogSeverityLevel$LAYOUT, RunOptionsSetRunLogSeverityLevel$OFFSET);
        return RunOptionsSetRunLogSeverityLevel.invoke(funcPtr, _x0, _x1);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsSetRunTag)(OrtRunOptions *, const char *)
     * }
     */
    private static class RunOptionsSetRunTag {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout RunOptionsSetRunTag$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("RunOptionsSetRunTag"));

    private static final long RunOptionsSetRunTag$OFFSET = $LAYOUT.byteOffset(groupElement("RunOptionsSetRunTag"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsSetRunTag)(OrtRunOptions *, const char *)
     * }
     */
    public static MemorySegment RunOptionsSetRunTag(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {
        var funcPtr = struct.get(RunOptionsSetRunTag$LAYOUT, RunOptionsSetRunTag$OFFSET);
        return RunOptionsSetRunTag.invoke(funcPtr, _x0, _x1);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsGetRunLogVerbosityLevel)(const OrtRunOptions *, int *)
     * }
     */
    private static class RunOptionsGetRunLogVerbosityLevel {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout RunOptionsGetRunLogVerbosityLevel$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("RunOptionsGetRunLogVerbosityLevel"));

    private static final long RunOptionsGetRunLogVerbosityLevel$OFFSET = $LAYOUT.byteOffset(groupElement("RunOptionsGetRunLogVerbosityLevel"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsGetRunLogVerbosityLevel)(const OrtRunOptions *, int *)
     * }
     */
    public static MemorySegment RunOptionsGetRunLogVerbosityLevel(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {
        var funcPtr = struct.get(RunOptionsGetRunLogVerbosityLevel$LAYOUT, RunOptionsGetRunLogVerbosityLevel$OFFSET);
        return RunOptionsGetRunLogVerbosityLevel.invoke(funcPtr, _x0, _x1);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsGetRunLogSeverityLevel)(const OrtRunOptions *, int *)
     * }
     */
    private static class RunOptionsGetRunLogSeverityLevel {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout RunOptionsGetRunLogSeverityLevel$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("RunOptionsGetRunLogSeverityLevel"));

    private static final long RunOptionsGetRunLogSeverityLevel$OFFSET = $LAYOUT.byteOffset(groupElement("RunOptionsGetRunLogSeverityLevel"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsGetRunLogSeverityLevel)(const OrtRunOptions *, int *)
     * }
     */
    public static MemorySegment RunOptionsGetRunLogSeverityLevel(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {
        var funcPtr = struct.get(RunOptionsGetRunLogSeverityLevel$LAYOUT, RunOptionsGetRunLogSeverityLevel$OFFSET);
        return RunOptionsGetRunLogSeverityLevel.invoke(funcPtr, _x0, _x1);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsGetRunTag)(const OrtRunOptions *, const char **)
     * }
     */
    private static class RunOptionsGetRunTag {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout RunOptionsGetRunTag$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("RunOptionsGetRunTag"));

    private static final long RunOptionsGetRunTag$OFFSET = $LAYOUT.byteOffset(groupElement("RunOptionsGetRunTag"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsGetRunTag)(const OrtRunOptions *, const char **)
     * }
     */
    public static MemorySegment RunOptionsGetRunTag(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {
        var funcPtr = struct.get(RunOptionsGetRunTag$LAYOUT, RunOptionsGetRunTag$OFFSET);
        return RunOptionsGetRunTag.invoke(funcPtr, _x0, _x1);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsSetTerminate)(OrtRunOptions *)
     * }
     */
    private static class RunOptionsSetTerminate {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout RunOptionsSetTerminate$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("RunOptionsSetTerminate"));

    private static final long RunOptionsSetTerminate$OFFSET = $LAYOUT.byteOffset(groupElement("RunOptionsSetTerminate"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsSetTerminate)(OrtRunOptions *)
     * }
     */
    public static MemorySegment RunOptionsSetTerminate(MemorySegment struct, MemorySegment _x0) {
        var funcPtr = struct.get(RunOptionsSetTerminate$LAYOUT, RunOptionsSetTerminate$OFFSET);
        return RunOptionsSetTerminate.invoke(funcPtr, _x0);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsUnsetTerminate)(OrtRunOptions *)
     * }
     */
    private static class RunOptionsUnsetTerminate {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout RunOptionsUnsetTerminate$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("RunOptionsUnsetTerminate"));

    private static final long RunOptionsUnsetTerminate$OFFSET = $LAYOUT.byteOffset(groupElement("RunOptionsUnsetTerminate"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsUnsetTerminate)(OrtRunOptions *)
     * }
     */
    public static MemorySegment RunOptionsUnsetTerminate(MemorySegment struct, MemorySegment _x0) {
        var funcPtr = struct.get(RunOptionsUnsetTerminate$LAYOUT, RunOptionsUnsetTerminate$OFFSET);
        return RunOptionsUnsetTerminate.invoke(funcPtr, _x0);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateTensorAsOrtValue)(OrtAllocator *, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **)
     * }
     */
    private static class CreateTensorAsOrtValue {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_INT,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2, int _x3, MemorySegment _x4) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CreateTensorAsOrtValue$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CreateTensorAsOrtValue"));

    private static final long CreateTensorAsOrtValue$OFFSET = $LAYOUT.byteOffset(groupElement("CreateTensorAsOrtValue"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateTensorAsOrtValue)(OrtAllocator *, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **)
     * }
     */
    public static MemorySegment CreateTensorAsOrtValue(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, long _x2, int _x3, MemorySegment _x4) {
        var funcPtr = struct.get(CreateTensorAsOrtValue$LAYOUT, CreateTensorAsOrtValue$OFFSET);
        return CreateTensorAsOrtValue.invoke(funcPtr, _x0, _x1, _x2, _x3, _x4);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateTensorWithDataAsOrtValue)(const OrtMemoryInfo *, void *, size_t, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **)
     * }
     */
    private static class CreateTensorWithDataAsOrtValue {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_INT,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3, long _x4, int _x5, MemorySegment _x6) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CreateTensorWithDataAsOrtValue$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CreateTensorWithDataAsOrtValue"));

    private static final long CreateTensorWithDataAsOrtValue$OFFSET = $LAYOUT.byteOffset(groupElement("CreateTensorWithDataAsOrtValue"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateTensorWithDataAsOrtValue)(const OrtMemoryInfo *, void *, size_t, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **)
     * }
     */
    public static MemorySegment CreateTensorWithDataAsOrtValue(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3, long _x4, int _x5, MemorySegment _x6) {
        var funcPtr = struct.get(CreateTensorWithDataAsOrtValue$LAYOUT, CreateTensorWithDataAsOrtValue$OFFSET);
        return CreateTensorWithDataAsOrtValue.invoke(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*IsTensor)(const OrtValue *, int *)
     * }
     */
    private static class IsTensor {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout IsTensor$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("IsTensor"));

    private static final long IsTensor$OFFSET = $LAYOUT.byteOffset(groupElement("IsTensor"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*IsTensor)(const OrtValue *, int *)
     * }
     */
    public static MemorySegment IsTensor(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {
        var funcPtr = struct.get(IsTensor$LAYOUT, IsTensor$OFFSET);
        return IsTensor.invoke(funcPtr, _x0, _x1);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTensorMutableData)(OrtValue *, void **)
     * }
     */
    private static class GetTensorMutableData {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetTensorMutableData$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetTensorMutableData"));

    private static final long GetTensorMutableData$OFFSET = $LAYOUT.byteOffset(groupElement("GetTensorMutableData"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTensorMutableData)(OrtValue *, void **)
     * }
     */
    public static MemorySegment GetTensorMutableData(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {
        var funcPtr = struct.get(GetTensorMutableData$LAYOUT, GetTensorMutableData$OFFSET);
        return GetTensorMutableData.invoke(funcPtr, _x0, _x1);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*FillStringTensor)(OrtValue *, const char *const *, size_t)
     * }
     */
    private static class FillStringTensor {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout FillStringTensor$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("FillStringTensor"));

    private static final long FillStringTensor$OFFSET = $LAYOUT.byteOffset(groupElement("FillStringTensor"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*FillStringTensor)(OrtValue *, const char *const *, size_t)
     * }
     */
    public static MemorySegment FillStringTensor(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, long _x2) {
        var funcPtr = struct.get(FillStringTensor$LAYOUT, FillStringTensor$OFFSET);
        return FillStringTensor.invoke(funcPtr, _x0, _x1, _x2);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetStringTensorDataLength)(const OrtValue *, size_t *)
     * }
     */
    private static class GetStringTensorDataLength {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetStringTensorDataLength$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetStringTensorDataLength"));

    private static final long GetStringTensorDataLength$OFFSET = $LAYOUT.byteOffset(groupElement("GetStringTensorDataLength"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetStringTensorDataLength)(const OrtValue *, size_t *)
     * }
     */
    public static MemorySegment GetStringTensorDataLength(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {
        var funcPtr = struct.get(GetStringTensorDataLength$LAYOUT, GetStringTensorDataLength$OFFSET);
        return GetStringTensorDataLength.invoke(funcPtr, _x0, _x1);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetStringTensorContent)(const OrtValue *, void *, size_t, size_t *, size_t)
     * }
     */
    private static class GetStringTensorContent {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3, long _x4) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetStringTensorContent$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetStringTensorContent"));

    private static final long GetStringTensorContent$OFFSET = $LAYOUT.byteOffset(groupElement("GetStringTensorContent"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetStringTensorContent)(const OrtValue *, void *, size_t, size_t *, size_t)
     * }
     */
    public static MemorySegment GetStringTensorContent(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3, long _x4) {
        var funcPtr = struct.get(GetStringTensorContent$LAYOUT, GetStringTensorContent$OFFSET);
        return GetStringTensorContent.invoke(funcPtr, _x0, _x1, _x2, _x3, _x4);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CastTypeInfoToTensorInfo)(const OrtTypeInfo *, const OrtTensorTypeAndShapeInfo **)
     * }
     */
    private static class CastTypeInfoToTensorInfo {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CastTypeInfoToTensorInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CastTypeInfoToTensorInfo"));

    private static final long CastTypeInfoToTensorInfo$OFFSET = $LAYOUT.byteOffset(groupElement("CastTypeInfoToTensorInfo"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CastTypeInfoToTensorInfo)(const OrtTypeInfo *, const OrtTensorTypeAndShapeInfo **)
     * }
     */
    public static MemorySegment CastTypeInfoToTensorInfo(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {
        var funcPtr = struct.get(CastTypeInfoToTensorInfo$LAYOUT, CastTypeInfoToTensorInfo$OFFSET);
        return CastTypeInfoToTensorInfo.invoke(funcPtr, _x0, _x1);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetOnnxTypeFromTypeInfo)(const OrtTypeInfo *, enum ONNXType *)
     * }
     */
    private static class GetOnnxTypeFromTypeInfo {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetOnnxTypeFromTypeInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetOnnxTypeFromTypeInfo"));

    private static final long GetOnnxTypeFromTypeInfo$OFFSET = $LAYOUT.byteOffset(groupElement("GetOnnxTypeFromTypeInfo"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetOnnxTypeFromTypeInfo)(const OrtTypeInfo *, enum ONNXType *)
     * }
     */
    public static MemorySegment GetOnnxTypeFromTypeInfo(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {
        var funcPtr = struct.get(GetOnnxTypeFromTypeInfo$LAYOUT, GetOnnxTypeFromTypeInfo$OFFSET);
        return GetOnnxTypeFromTypeInfo.invoke(funcPtr, _x0, _x1);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateTensorTypeAndShapeInfo)(OrtTensorTypeAndShapeInfo **)
     * }
     */
    private static class CreateTensorTypeAndShapeInfo {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CreateTensorTypeAndShapeInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CreateTensorTypeAndShapeInfo"));

    private static final long CreateTensorTypeAndShapeInfo$OFFSET = $LAYOUT.byteOffset(groupElement("CreateTensorTypeAndShapeInfo"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateTensorTypeAndShapeInfo)(OrtTensorTypeAndShapeInfo **)
     * }
     */
    public static MemorySegment CreateTensorTypeAndShapeInfo(MemorySegment struct, MemorySegment _x0) {
        var funcPtr = struct.get(CreateTensorTypeAndShapeInfo$LAYOUT, CreateTensorTypeAndShapeInfo$OFFSET);
        return CreateTensorTypeAndShapeInfo.invoke(funcPtr, _x0);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SetTensorElementType)(OrtTensorTypeAndShapeInfo *, enum ONNXTensorElementDataType)
     * }
     */
    private static class SetTensorElementType {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_INT
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SetTensorElementType$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SetTensorElementType"));

    private static final long SetTensorElementType$OFFSET = $LAYOUT.byteOffset(groupElement("SetTensorElementType"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetTensorElementType)(OrtTensorTypeAndShapeInfo *, enum ONNXTensorElementDataType)
     * }
     */
    public static MemorySegment SetTensorElementType(MemorySegment struct, MemorySegment _x0, int _x1) {
        var funcPtr = struct.get(SetTensorElementType$LAYOUT, SetTensorElementType$OFFSET);
        return SetTensorElementType.invoke(funcPtr, _x0, _x1);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SetDimensions)(OrtTensorTypeAndShapeInfo *, const int64_t *, size_t)
     * }
     */
    private static class SetDimensions {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SetDimensions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SetDimensions"));

    private static final long SetDimensions$OFFSET = $LAYOUT.byteOffset(groupElement("SetDimensions"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetDimensions)(OrtTensorTypeAndShapeInfo *, const int64_t *, size_t)
     * }
     */
    public static MemorySegment SetDimensions(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, long _x2) {
        var funcPtr = struct.get(SetDimensions$LAYOUT, SetDimensions$OFFSET);
        return SetDimensions.invoke(funcPtr, _x0, _x1, _x2);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTensorElementType)(const OrtTensorTypeAndShapeInfo *, enum ONNXTensorElementDataType *)
     * }
     */
    private static class GetTensorElementType {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetTensorElementType$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetTensorElementType"));

    private static final long GetTensorElementType$OFFSET = $LAYOUT.byteOffset(groupElement("GetTensorElementType"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTensorElementType)(const OrtTensorTypeAndShapeInfo *, enum ONNXTensorElementDataType *)
     * }
     */
    public static MemorySegment GetTensorElementType(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {
        var funcPtr = struct.get(GetTensorElementType$LAYOUT, GetTensorElementType$OFFSET);
        return GetTensorElementType.invoke(funcPtr, _x0, _x1);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetDimensionsCount)(const OrtTensorTypeAndShapeInfo *, size_t *)
     * }
     */
    private static class GetDimensionsCount {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetDimensionsCount$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetDimensionsCount"));

    private static final long GetDimensionsCount$OFFSET = $LAYOUT.byteOffset(groupElement("GetDimensionsCount"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetDimensionsCount)(const OrtTensorTypeAndShapeInfo *, size_t *)
     * }
     */
    public static MemorySegment GetDimensionsCount(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {
        var funcPtr = struct.get(GetDimensionsCount$LAYOUT, GetDimensionsCount$OFFSET);
        return GetDimensionsCount.invoke(funcPtr, _x0, _x1);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetDimensions)(const OrtTensorTypeAndShapeInfo *, int64_t *, size_t)
     * }
     */
    private static class GetDimensions {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetDimensions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetDimensions"));

    private static final long GetDimensions$OFFSET = $LAYOUT.byteOffset(groupElement("GetDimensions"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetDimensions)(const OrtTensorTypeAndShapeInfo *, int64_t *, size_t)
     * }
     */
    public static MemorySegment GetDimensions(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, long _x2) {
        var funcPtr = struct.get(GetDimensions$LAYOUT, GetDimensions$OFFSET);
        return GetDimensions.invoke(funcPtr, _x0, _x1, _x2);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSymbolicDimensions)(const OrtTensorTypeAndShapeInfo *, const char **, size_t)
     * }
     */
    private static class GetSymbolicDimensions {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetSymbolicDimensions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetSymbolicDimensions"));

    private static final long GetSymbolicDimensions$OFFSET = $LAYOUT.byteOffset(groupElement("GetSymbolicDimensions"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSymbolicDimensions)(const OrtTensorTypeAndShapeInfo *, const char **, size_t)
     * }
     */
    public static MemorySegment GetSymbolicDimensions(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, long _x2) {
        var funcPtr = struct.get(GetSymbolicDimensions$LAYOUT, GetSymbolicDimensions$OFFSET);
        return GetSymbolicDimensions.invoke(funcPtr, _x0, _x1, _x2);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTensorShapeElementCount)(const OrtTensorTypeAndShapeInfo *, size_t *)
     * }
     */
    private static class GetTensorShapeElementCount {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetTensorShapeElementCount$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetTensorShapeElementCount"));

    private static final long GetTensorShapeElementCount$OFFSET = $LAYOUT.byteOffset(groupElement("GetTensorShapeElementCount"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTensorShapeElementCount)(const OrtTensorTypeAndShapeInfo *, size_t *)
     * }
     */
    public static MemorySegment GetTensorShapeElementCount(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {
        var funcPtr = struct.get(GetTensorShapeElementCount$LAYOUT, GetTensorShapeElementCount$OFFSET);
        return GetTensorShapeElementCount.invoke(funcPtr, _x0, _x1);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTensorTypeAndShape)(const OrtValue *, OrtTensorTypeAndShapeInfo **)
     * }
     */
    private static class GetTensorTypeAndShape {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetTensorTypeAndShape$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetTensorTypeAndShape"));

    private static final long GetTensorTypeAndShape$OFFSET = $LAYOUT.byteOffset(groupElement("GetTensorTypeAndShape"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTensorTypeAndShape)(const OrtValue *, OrtTensorTypeAndShapeInfo **)
     * }
     */
    public static MemorySegment GetTensorTypeAndShape(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {
        var funcPtr = struct.get(GetTensorTypeAndShape$LAYOUT, GetTensorTypeAndShape$OFFSET);
        return GetTensorTypeAndShape.invoke(funcPtr, _x0, _x1);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTypeInfo)(const OrtValue *, OrtTypeInfo **)
     * }
     */
    private static class GetTypeInfo {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetTypeInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetTypeInfo"));

    private static final long GetTypeInfo$OFFSET = $LAYOUT.byteOffset(groupElement("GetTypeInfo"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTypeInfo)(const OrtValue *, OrtTypeInfo **)
     * }
     */
    public static MemorySegment GetTypeInfo(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {
        var funcPtr = struct.get(GetTypeInfo$LAYOUT, GetTypeInfo$OFFSET);
        return GetTypeInfo.invoke(funcPtr, _x0, _x1);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetValueType)(const OrtValue *, enum ONNXType *)
     * }
     */
    private static class GetValueType {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetValueType$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetValueType"));

    private static final long GetValueType$OFFSET = $LAYOUT.byteOffset(groupElement("GetValueType"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetValueType)(const OrtValue *, enum ONNXType *)
     * }
     */
    public static MemorySegment GetValueType(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {
        var funcPtr = struct.get(GetValueType$LAYOUT, GetValueType$OFFSET);
        return GetValueType.invoke(funcPtr, _x0, _x1);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateMemoryInfo)(const char *, enum OrtAllocatorType, int, enum OrtMemType, OrtMemoryInfo **)
     * }
     */
    private static class CreateMemoryInfo {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_INT,
            onnxruntime_c_api_h.C_INT,
            onnxruntime_c_api_h.C_INT,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, int _x2, int _x3, MemorySegment _x4) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CreateMemoryInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CreateMemoryInfo"));

    private static final long CreateMemoryInfo$OFFSET = $LAYOUT.byteOffset(groupElement("CreateMemoryInfo"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateMemoryInfo)(const char *, enum OrtAllocatorType, int, enum OrtMemType, OrtMemoryInfo **)
     * }
     */
    public static MemorySegment CreateMemoryInfo(MemorySegment struct, MemorySegment _x0, int _x1, int _x2, int _x3, MemorySegment _x4) {
        var funcPtr = struct.get(CreateMemoryInfo$LAYOUT, CreateMemoryInfo$OFFSET);
        return CreateMemoryInfo.invoke(funcPtr, _x0, _x1, _x2, _x3, _x4);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateCpuMemoryInfo)(enum OrtAllocatorType, enum OrtMemType, OrtMemoryInfo **)
     * }
     */
    private static class CreateCpuMemoryInfo {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_INT,
            onnxruntime_c_api_h.C_INT,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,int _x0, int _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CreateCpuMemoryInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CreateCpuMemoryInfo"));

    private static final long CreateCpuMemoryInfo$OFFSET = $LAYOUT.byteOffset(groupElement("CreateCpuMemoryInfo"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateCpuMemoryInfo)(enum OrtAllocatorType, enum OrtMemType, OrtMemoryInfo **)
     * }
     */
    public static MemorySegment CreateCpuMemoryInfo(MemorySegment struct, int _x0, int _x1, MemorySegment _x2) {
        var funcPtr = struct.get(CreateCpuMemoryInfo$LAYOUT, CreateCpuMemoryInfo$OFFSET);
        return CreateCpuMemoryInfo.invoke(funcPtr, _x0, _x1, _x2);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CompareMemoryInfo)(const OrtMemoryInfo *, const OrtMemoryInfo *, int *)
     * }
     */
    private static class CompareMemoryInfo {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CompareMemoryInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CompareMemoryInfo"));

    private static final long CompareMemoryInfo$OFFSET = $LAYOUT.byteOffset(groupElement("CompareMemoryInfo"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CompareMemoryInfo)(const OrtMemoryInfo *, const OrtMemoryInfo *, int *)
     * }
     */
    public static MemorySegment CompareMemoryInfo(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
        var funcPtr = struct.get(CompareMemoryInfo$LAYOUT, CompareMemoryInfo$OFFSET);
        return CompareMemoryInfo.invoke(funcPtr, _x0, _x1, _x2);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*MemoryInfoGetName)(const OrtMemoryInfo *, const char **)
     * }
     */
    private static class MemoryInfoGetName {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout MemoryInfoGetName$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("MemoryInfoGetName"));

    private static final long MemoryInfoGetName$OFFSET = $LAYOUT.byteOffset(groupElement("MemoryInfoGetName"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*MemoryInfoGetName)(const OrtMemoryInfo *, const char **)
     * }
     */
    public static MemorySegment MemoryInfoGetName(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {
        var funcPtr = struct.get(MemoryInfoGetName$LAYOUT, MemoryInfoGetName$OFFSET);
        return MemoryInfoGetName.invoke(funcPtr, _x0, _x1);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*MemoryInfoGetId)(const OrtMemoryInfo *, int *)
     * }
     */
    private static class MemoryInfoGetId {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout MemoryInfoGetId$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("MemoryInfoGetId"));

    private static final long MemoryInfoGetId$OFFSET = $LAYOUT.byteOffset(groupElement("MemoryInfoGetId"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*MemoryInfoGetId)(const OrtMemoryInfo *, int *)
     * }
     */
    public static MemorySegment MemoryInfoGetId(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {
        var funcPtr = struct.get(MemoryInfoGetId$LAYOUT, MemoryInfoGetId$OFFSET);
        return MemoryInfoGetId.invoke(funcPtr, _x0, _x1);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*MemoryInfoGetMemType)(const OrtMemoryInfo *, OrtMemType *)
     * }
     */
    private static class MemoryInfoGetMemType {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout MemoryInfoGetMemType$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("MemoryInfoGetMemType"));

    private static final long MemoryInfoGetMemType$OFFSET = $LAYOUT.byteOffset(groupElement("MemoryInfoGetMemType"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*MemoryInfoGetMemType)(const OrtMemoryInfo *, OrtMemType *)
     * }
     */
    public static MemorySegment MemoryInfoGetMemType(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {
        var funcPtr = struct.get(MemoryInfoGetMemType$LAYOUT, MemoryInfoGetMemType$OFFSET);
        return MemoryInfoGetMemType.invoke(funcPtr, _x0, _x1);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*MemoryInfoGetType)(const OrtMemoryInfo *, OrtAllocatorType *)
     * }
     */
    private static class MemoryInfoGetType {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout MemoryInfoGetType$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("MemoryInfoGetType"));

    private static final long MemoryInfoGetType$OFFSET = $LAYOUT.byteOffset(groupElement("MemoryInfoGetType"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*MemoryInfoGetType)(const OrtMemoryInfo *, OrtAllocatorType *)
     * }
     */
    public static MemorySegment MemoryInfoGetType(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {
        var funcPtr = struct.get(MemoryInfoGetType$LAYOUT, MemoryInfoGetType$OFFSET);
        return MemoryInfoGetType.invoke(funcPtr, _x0, _x1);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*AllocatorAlloc)(OrtAllocator *, size_t, void **)
     * }
     */
    private static class AllocatorAlloc {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, long _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout AllocatorAlloc$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("AllocatorAlloc"));

    private static final long AllocatorAlloc$OFFSET = $LAYOUT.byteOffset(groupElement("AllocatorAlloc"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AllocatorAlloc)(OrtAllocator *, size_t, void **)
     * }
     */
    public static MemorySegment AllocatorAlloc(MemorySegment struct, MemorySegment _x0, long _x1, MemorySegment _x2) {
        var funcPtr = struct.get(AllocatorAlloc$LAYOUT, AllocatorAlloc$OFFSET);
        return AllocatorAlloc.invoke(funcPtr, _x0, _x1, _x2);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*AllocatorFree)(OrtAllocator *, void *)
     * }
     */
    private static class AllocatorFree {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout AllocatorFree$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("AllocatorFree"));

    private static final long AllocatorFree$OFFSET = $LAYOUT.byteOffset(groupElement("AllocatorFree"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AllocatorFree)(OrtAllocator *, void *)
     * }
     */
    public static MemorySegment AllocatorFree(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {
        var funcPtr = struct.get(AllocatorFree$LAYOUT, AllocatorFree$OFFSET);
        return AllocatorFree.invoke(funcPtr, _x0, _x1);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*AllocatorGetInfo)(const OrtAllocator *, const struct OrtMemoryInfo **)
     * }
     */
    private static class AllocatorGetInfo {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout AllocatorGetInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("AllocatorGetInfo"));

    private static final long AllocatorGetInfo$OFFSET = $LAYOUT.byteOffset(groupElement("AllocatorGetInfo"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AllocatorGetInfo)(const OrtAllocator *, const struct OrtMemoryInfo **)
     * }
     */
    public static MemorySegment AllocatorGetInfo(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {
        var funcPtr = struct.get(AllocatorGetInfo$LAYOUT, AllocatorGetInfo$OFFSET);
        return AllocatorGetInfo.invoke(funcPtr, _x0, _x1);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetAllocatorWithDefaultOptions)(OrtAllocator **)
     * }
     */
    private static class GetAllocatorWithDefaultOptions {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetAllocatorWithDefaultOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetAllocatorWithDefaultOptions"));

    private static final long GetAllocatorWithDefaultOptions$OFFSET = $LAYOUT.byteOffset(groupElement("GetAllocatorWithDefaultOptions"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetAllocatorWithDefaultOptions)(OrtAllocator **)
     * }
     */
    public static MemorySegment GetAllocatorWithDefaultOptions(MemorySegment struct, MemorySegment _x0) {
        var funcPtr = struct.get(GetAllocatorWithDefaultOptions$LAYOUT, GetAllocatorWithDefaultOptions$OFFSET);
        return GetAllocatorWithDefaultOptions.invoke(funcPtr, _x0);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*AddFreeDimensionOverride)(OrtSessionOptions *, const char *, int64_t)
     * }
     */
    private static class AddFreeDimensionOverride {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout AddFreeDimensionOverride$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("AddFreeDimensionOverride"));

    private static final long AddFreeDimensionOverride$OFFSET = $LAYOUT.byteOffset(groupElement("AddFreeDimensionOverride"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AddFreeDimensionOverride)(OrtSessionOptions *, const char *, int64_t)
     * }
     */
    public static MemorySegment AddFreeDimensionOverride(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, long _x2) {
        var funcPtr = struct.get(AddFreeDimensionOverride$LAYOUT, AddFreeDimensionOverride$OFFSET);
        return AddFreeDimensionOverride.invoke(funcPtr, _x0, _x1, _x2);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetValue)(const OrtValue *, int, OrtAllocator *, OrtValue **)
     * }
     */
    private static class GetValue {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_INT,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetValue$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetValue"));

    private static final long GetValue$OFFSET = $LAYOUT.byteOffset(groupElement("GetValue"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetValue)(const OrtValue *, int, OrtAllocator *, OrtValue **)
     * }
     */
    public static MemorySegment GetValue(MemorySegment struct, MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3) {
        var funcPtr = struct.get(GetValue$LAYOUT, GetValue$OFFSET);
        return GetValue.invoke(funcPtr, _x0, _x1, _x2, _x3);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetValueCount)(const OrtValue *, size_t *)
     * }
     */
    private static class GetValueCount {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetValueCount$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetValueCount"));

    private static final long GetValueCount$OFFSET = $LAYOUT.byteOffset(groupElement("GetValueCount"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetValueCount)(const OrtValue *, size_t *)
     * }
     */
    public static MemorySegment GetValueCount(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {
        var funcPtr = struct.get(GetValueCount$LAYOUT, GetValueCount$OFFSET);
        return GetValueCount.invoke(funcPtr, _x0, _x1);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateValue)(const OrtValue *const *, size_t, enum ONNXType, OrtValue **)
     * }
     */
    private static class CreateValue {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_INT,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, long _x1, int _x2, MemorySegment _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CreateValue$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CreateValue"));

    private static final long CreateValue$OFFSET = $LAYOUT.byteOffset(groupElement("CreateValue"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateValue)(const OrtValue *const *, size_t, enum ONNXType, OrtValue **)
     * }
     */
    public static MemorySegment CreateValue(MemorySegment struct, MemorySegment _x0, long _x1, int _x2, MemorySegment _x3) {
        var funcPtr = struct.get(CreateValue$LAYOUT, CreateValue$OFFSET);
        return CreateValue.invoke(funcPtr, _x0, _x1, _x2, _x3);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateOpaqueValue)(const char *, const char *, const void *, size_t, OrtValue **)
     * }
     */
    private static class CreateOpaqueValue {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3, MemorySegment _x4) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CreateOpaqueValue$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CreateOpaqueValue"));

    private static final long CreateOpaqueValue$OFFSET = $LAYOUT.byteOffset(groupElement("CreateOpaqueValue"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateOpaqueValue)(const char *, const char *, const void *, size_t, OrtValue **)
     * }
     */
    public static MemorySegment CreateOpaqueValue(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3, MemorySegment _x4) {
        var funcPtr = struct.get(CreateOpaqueValue$LAYOUT, CreateOpaqueValue$OFFSET);
        return CreateOpaqueValue.invoke(funcPtr, _x0, _x1, _x2, _x3, _x4);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetOpaqueValue)(const char *, const char *, const OrtValue *, void *, size_t)
     * }
     */
    private static class GetOpaqueValue {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, long _x4) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetOpaqueValue$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetOpaqueValue"));

    private static final long GetOpaqueValue$OFFSET = $LAYOUT.byteOffset(groupElement("GetOpaqueValue"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetOpaqueValue)(const char *, const char *, const OrtValue *, void *, size_t)
     * }
     */
    public static MemorySegment GetOpaqueValue(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, long _x4) {
        var funcPtr = struct.get(GetOpaqueValue$LAYOUT, GetOpaqueValue$OFFSET);
        return GetOpaqueValue.invoke(funcPtr, _x0, _x1, _x2, _x3, _x4);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfoGetAttribute_float)(const OrtKernelInfo *, const char *, float *)
     * }
     */
    private static class KernelInfoGetAttribute_float {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout KernelInfoGetAttribute_float$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("KernelInfoGetAttribute_float"));

    private static final long KernelInfoGetAttribute_float$OFFSET = $LAYOUT.byteOffset(groupElement("KernelInfoGetAttribute_float"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfoGetAttribute_float)(const OrtKernelInfo *, const char *, float *)
     * }
     */
    public static MemorySegment KernelInfoGetAttribute_float(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
        var funcPtr = struct.get(KernelInfoGetAttribute_float$LAYOUT, KernelInfoGetAttribute_float$OFFSET);
        return KernelInfoGetAttribute_float.invoke(funcPtr, _x0, _x1, _x2);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfoGetAttribute_int64)(const OrtKernelInfo *, const char *, int64_t *)
     * }
     */
    private static class KernelInfoGetAttribute_int64 {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout KernelInfoGetAttribute_int64$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("KernelInfoGetAttribute_int64"));

    private static final long KernelInfoGetAttribute_int64$OFFSET = $LAYOUT.byteOffset(groupElement("KernelInfoGetAttribute_int64"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfoGetAttribute_int64)(const OrtKernelInfo *, const char *, int64_t *)
     * }
     */
    public static MemorySegment KernelInfoGetAttribute_int64(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
        var funcPtr = struct.get(KernelInfoGetAttribute_int64$LAYOUT, KernelInfoGetAttribute_int64$OFFSET);
        return KernelInfoGetAttribute_int64.invoke(funcPtr, _x0, _x1, _x2);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfoGetAttribute_string)(const OrtKernelInfo *, const char *, char *, size_t *)
     * }
     */
    private static class KernelInfoGetAttribute_string {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout KernelInfoGetAttribute_string$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("KernelInfoGetAttribute_string"));

    private static final long KernelInfoGetAttribute_string$OFFSET = $LAYOUT.byteOffset(groupElement("KernelInfoGetAttribute_string"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfoGetAttribute_string)(const OrtKernelInfo *, const char *, char *, size_t *)
     * }
     */
    public static MemorySegment KernelInfoGetAttribute_string(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
        var funcPtr = struct.get(KernelInfoGetAttribute_string$LAYOUT, KernelInfoGetAttribute_string$OFFSET);
        return KernelInfoGetAttribute_string.invoke(funcPtr, _x0, _x1, _x2, _x3);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetInputCount)(const OrtKernelContext *, size_t *)
     * }
     */
    private static class KernelContext_GetInputCount {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout KernelContext_GetInputCount$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("KernelContext_GetInputCount"));

    private static final long KernelContext_GetInputCount$OFFSET = $LAYOUT.byteOffset(groupElement("KernelContext_GetInputCount"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetInputCount)(const OrtKernelContext *, size_t *)
     * }
     */
    public static MemorySegment KernelContext_GetInputCount(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {
        var funcPtr = struct.get(KernelContext_GetInputCount$LAYOUT, KernelContext_GetInputCount$OFFSET);
        return KernelContext_GetInputCount.invoke(funcPtr, _x0, _x1);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetOutputCount)(const OrtKernelContext *, size_t *)
     * }
     */
    private static class KernelContext_GetOutputCount {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout KernelContext_GetOutputCount$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("KernelContext_GetOutputCount"));

    private static final long KernelContext_GetOutputCount$OFFSET = $LAYOUT.byteOffset(groupElement("KernelContext_GetOutputCount"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetOutputCount)(const OrtKernelContext *, size_t *)
     * }
     */
    public static MemorySegment KernelContext_GetOutputCount(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {
        var funcPtr = struct.get(KernelContext_GetOutputCount$LAYOUT, KernelContext_GetOutputCount$OFFSET);
        return KernelContext_GetOutputCount.invoke(funcPtr, _x0, _x1);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetInput)(const OrtKernelContext *, size_t, const OrtValue **)
     * }
     */
    private static class KernelContext_GetInput {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, long _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout KernelContext_GetInput$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("KernelContext_GetInput"));

    private static final long KernelContext_GetInput$OFFSET = $LAYOUT.byteOffset(groupElement("KernelContext_GetInput"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetInput)(const OrtKernelContext *, size_t, const OrtValue **)
     * }
     */
    public static MemorySegment KernelContext_GetInput(MemorySegment struct, MemorySegment _x0, long _x1, MemorySegment _x2) {
        var funcPtr = struct.get(KernelContext_GetInput$LAYOUT, KernelContext_GetInput$OFFSET);
        return KernelContext_GetInput.invoke(funcPtr, _x0, _x1, _x2);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetOutput)(OrtKernelContext *, size_t, const int64_t *, size_t, OrtValue **)
     * }
     */
    private static class KernelContext_GetOutput {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, long _x1, MemorySegment _x2, long _x3, MemorySegment _x4) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout KernelContext_GetOutput$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("KernelContext_GetOutput"));

    private static final long KernelContext_GetOutput$OFFSET = $LAYOUT.byteOffset(groupElement("KernelContext_GetOutput"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetOutput)(OrtKernelContext *, size_t, const int64_t *, size_t, OrtValue **)
     * }
     */
    public static MemorySegment KernelContext_GetOutput(MemorySegment struct, MemorySegment _x0, long _x1, MemorySegment _x2, long _x3, MemorySegment _x4) {
        var funcPtr = struct.get(KernelContext_GetOutput$LAYOUT, KernelContext_GetOutput$OFFSET);
        return KernelContext_GetOutput.invoke(funcPtr, _x0, _x1, _x2, _x3, _x4);
    }

    /**
     * {@snippet lang=c :
     * void (*ReleaseEnv)(OrtEnv *)
     * }
     */
    private static class ReleaseEnv {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ReleaseEnv$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ReleaseEnv"));

    private static final long ReleaseEnv$OFFSET = $LAYOUT.byteOffset(groupElement("ReleaseEnv"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * void (*ReleaseEnv)(OrtEnv *)
     * }
     */
    public static void ReleaseEnv(MemorySegment struct, MemorySegment _x0) {
        var funcPtr = struct.get(ReleaseEnv$LAYOUT, ReleaseEnv$OFFSET);
        ReleaseEnv.invoke(funcPtr, _x0);
    }

    /**
     * {@snippet lang=c :
     * void (*ReleaseStatus)(OrtStatus *)
     * }
     */
    private static class ReleaseStatus {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ReleaseStatus$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ReleaseStatus"));

    private static final long ReleaseStatus$OFFSET = $LAYOUT.byteOffset(groupElement("ReleaseStatus"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * void (*ReleaseStatus)(OrtStatus *)
     * }
     */
    public static void ReleaseStatus(MemorySegment struct, MemorySegment _x0) {
        var funcPtr = struct.get(ReleaseStatus$LAYOUT, ReleaseStatus$OFFSET);
        ReleaseStatus.invoke(funcPtr, _x0);
    }

    /**
     * {@snippet lang=c :
     * void (*ReleaseMemoryInfo)(OrtMemoryInfo *)
     * }
     */
    private static class ReleaseMemoryInfo {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ReleaseMemoryInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ReleaseMemoryInfo"));

    private static final long ReleaseMemoryInfo$OFFSET = $LAYOUT.byteOffset(groupElement("ReleaseMemoryInfo"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * void (*ReleaseMemoryInfo)(OrtMemoryInfo *)
     * }
     */
    public static void ReleaseMemoryInfo(MemorySegment struct, MemorySegment _x0) {
        var funcPtr = struct.get(ReleaseMemoryInfo$LAYOUT, ReleaseMemoryInfo$OFFSET);
        ReleaseMemoryInfo.invoke(funcPtr, _x0);
    }

    /**
     * {@snippet lang=c :
     * void (*ReleaseSession)(OrtSession *)
     * }
     */
    private static class ReleaseSession {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ReleaseSession$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ReleaseSession"));

    private static final long ReleaseSession$OFFSET = $LAYOUT.byteOffset(groupElement("ReleaseSession"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * void (*ReleaseSession)(OrtSession *)
     * }
     */
    public static void ReleaseSession(MemorySegment struct, MemorySegment _x0) {
        var funcPtr = struct.get(ReleaseSession$LAYOUT, ReleaseSession$OFFSET);
        ReleaseSession.invoke(funcPtr, _x0);
    }

    /**
     * {@snippet lang=c :
     * void (*ReleaseValue)(OrtValue *)
     * }
     */
    private static class ReleaseValue {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ReleaseValue$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ReleaseValue"));

    private static final long ReleaseValue$OFFSET = $LAYOUT.byteOffset(groupElement("ReleaseValue"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * void (*ReleaseValue)(OrtValue *)
     * }
     */
    public static void ReleaseValue(MemorySegment struct, MemorySegment _x0) {
        var funcPtr = struct.get(ReleaseValue$LAYOUT, ReleaseValue$OFFSET);
        ReleaseValue.invoke(funcPtr, _x0);
    }

    /**
     * {@snippet lang=c :
     * void (*ReleaseRunOptions)(OrtRunOptions *)
     * }
     */
    private static class ReleaseRunOptions {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ReleaseRunOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ReleaseRunOptions"));

    private static final long ReleaseRunOptions$OFFSET = $LAYOUT.byteOffset(groupElement("ReleaseRunOptions"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * void (*ReleaseRunOptions)(OrtRunOptions *)
     * }
     */
    public static void ReleaseRunOptions(MemorySegment struct, MemorySegment _x0) {
        var funcPtr = struct.get(ReleaseRunOptions$LAYOUT, ReleaseRunOptions$OFFSET);
        ReleaseRunOptions.invoke(funcPtr, _x0);
    }

    /**
     * {@snippet lang=c :
     * void (*ReleaseTypeInfo)(OrtTypeInfo *)
     * }
     */
    private static class ReleaseTypeInfo {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ReleaseTypeInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ReleaseTypeInfo"));

    private static final long ReleaseTypeInfo$OFFSET = $LAYOUT.byteOffset(groupElement("ReleaseTypeInfo"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * void (*ReleaseTypeInfo)(OrtTypeInfo *)
     * }
     */
    public static void ReleaseTypeInfo(MemorySegment struct, MemorySegment _x0) {
        var funcPtr = struct.get(ReleaseTypeInfo$LAYOUT, ReleaseTypeInfo$OFFSET);
        ReleaseTypeInfo.invoke(funcPtr, _x0);
    }

    /**
     * {@snippet lang=c :
     * void (*ReleaseTensorTypeAndShapeInfo)(OrtTensorTypeAndShapeInfo *)
     * }
     */
    private static class ReleaseTensorTypeAndShapeInfo {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ReleaseTensorTypeAndShapeInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ReleaseTensorTypeAndShapeInfo"));

    private static final long ReleaseTensorTypeAndShapeInfo$OFFSET = $LAYOUT.byteOffset(groupElement("ReleaseTensorTypeAndShapeInfo"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * void (*ReleaseTensorTypeAndShapeInfo)(OrtTensorTypeAndShapeInfo *)
     * }
     */
    public static void ReleaseTensorTypeAndShapeInfo(MemorySegment struct, MemorySegment _x0) {
        var funcPtr = struct.get(ReleaseTensorTypeAndShapeInfo$LAYOUT, ReleaseTensorTypeAndShapeInfo$OFFSET);
        ReleaseTensorTypeAndShapeInfo.invoke(funcPtr, _x0);
    }

    /**
     * {@snippet lang=c :
     * void (*ReleaseSessionOptions)(OrtSessionOptions *)
     * }
     */
    private static class ReleaseSessionOptions {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ReleaseSessionOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ReleaseSessionOptions"));

    private static final long ReleaseSessionOptions$OFFSET = $LAYOUT.byteOffset(groupElement("ReleaseSessionOptions"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * void (*ReleaseSessionOptions)(OrtSessionOptions *)
     * }
     */
    public static void ReleaseSessionOptions(MemorySegment struct, MemorySegment _x0) {
        var funcPtr = struct.get(ReleaseSessionOptions$LAYOUT, ReleaseSessionOptions$OFFSET);
        ReleaseSessionOptions.invoke(funcPtr, _x0);
    }

    /**
     * {@snippet lang=c :
     * void (*ReleaseCustomOpDomain)(OrtCustomOpDomain *)
     * }
     */
    private static class ReleaseCustomOpDomain {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ReleaseCustomOpDomain$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ReleaseCustomOpDomain"));

    private static final long ReleaseCustomOpDomain$OFFSET = $LAYOUT.byteOffset(groupElement("ReleaseCustomOpDomain"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * void (*ReleaseCustomOpDomain)(OrtCustomOpDomain *)
     * }
     */
    public static void ReleaseCustomOpDomain(MemorySegment struct, MemorySegment _x0) {
        var funcPtr = struct.get(ReleaseCustomOpDomain$LAYOUT, ReleaseCustomOpDomain$OFFSET);
        ReleaseCustomOpDomain.invoke(funcPtr, _x0);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetDenotationFromTypeInfo)(const OrtTypeInfo *, const char **const, size_t *)
     * }
     */
    private static class GetDenotationFromTypeInfo {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetDenotationFromTypeInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetDenotationFromTypeInfo"));

    private static final long GetDenotationFromTypeInfo$OFFSET = $LAYOUT.byteOffset(groupElement("GetDenotationFromTypeInfo"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetDenotationFromTypeInfo)(const OrtTypeInfo *, const char **const, size_t *)
     * }
     */
    public static MemorySegment GetDenotationFromTypeInfo(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
        var funcPtr = struct.get(GetDenotationFromTypeInfo$LAYOUT, GetDenotationFromTypeInfo$OFFSET);
        return GetDenotationFromTypeInfo.invoke(funcPtr, _x0, _x1, _x2);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CastTypeInfoToMapTypeInfo)(const OrtTypeInfo *, const OrtMapTypeInfo **)
     * }
     */
    private static class CastTypeInfoToMapTypeInfo {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CastTypeInfoToMapTypeInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CastTypeInfoToMapTypeInfo"));

    private static final long CastTypeInfoToMapTypeInfo$OFFSET = $LAYOUT.byteOffset(groupElement("CastTypeInfoToMapTypeInfo"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CastTypeInfoToMapTypeInfo)(const OrtTypeInfo *, const OrtMapTypeInfo **)
     * }
     */
    public static MemorySegment CastTypeInfoToMapTypeInfo(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {
        var funcPtr = struct.get(CastTypeInfoToMapTypeInfo$LAYOUT, CastTypeInfoToMapTypeInfo$OFFSET);
        return CastTypeInfoToMapTypeInfo.invoke(funcPtr, _x0, _x1);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CastTypeInfoToSequenceTypeInfo)(const OrtTypeInfo *, const OrtSequenceTypeInfo **)
     * }
     */
    private static class CastTypeInfoToSequenceTypeInfo {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CastTypeInfoToSequenceTypeInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CastTypeInfoToSequenceTypeInfo"));

    private static final long CastTypeInfoToSequenceTypeInfo$OFFSET = $LAYOUT.byteOffset(groupElement("CastTypeInfoToSequenceTypeInfo"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CastTypeInfoToSequenceTypeInfo)(const OrtTypeInfo *, const OrtSequenceTypeInfo **)
     * }
     */
    public static MemorySegment CastTypeInfoToSequenceTypeInfo(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {
        var funcPtr = struct.get(CastTypeInfoToSequenceTypeInfo$LAYOUT, CastTypeInfoToSequenceTypeInfo$OFFSET);
        return CastTypeInfoToSequenceTypeInfo.invoke(funcPtr, _x0, _x1);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetMapKeyType)(const OrtMapTypeInfo *, enum ONNXTensorElementDataType *)
     * }
     */
    private static class GetMapKeyType {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetMapKeyType$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetMapKeyType"));

    private static final long GetMapKeyType$OFFSET = $LAYOUT.byteOffset(groupElement("GetMapKeyType"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetMapKeyType)(const OrtMapTypeInfo *, enum ONNXTensorElementDataType *)
     * }
     */
    public static MemorySegment GetMapKeyType(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {
        var funcPtr = struct.get(GetMapKeyType$LAYOUT, GetMapKeyType$OFFSET);
        return GetMapKeyType.invoke(funcPtr, _x0, _x1);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetMapValueType)(const OrtMapTypeInfo *, OrtTypeInfo **)
     * }
     */
    private static class GetMapValueType {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetMapValueType$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetMapValueType"));

    private static final long GetMapValueType$OFFSET = $LAYOUT.byteOffset(groupElement("GetMapValueType"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetMapValueType)(const OrtMapTypeInfo *, OrtTypeInfo **)
     * }
     */
    public static MemorySegment GetMapValueType(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {
        var funcPtr = struct.get(GetMapValueType$LAYOUT, GetMapValueType$OFFSET);
        return GetMapValueType.invoke(funcPtr, _x0, _x1);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSequenceElementType)(const OrtSequenceTypeInfo *, OrtTypeInfo **)
     * }
     */
    private static class GetSequenceElementType {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetSequenceElementType$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetSequenceElementType"));

    private static final long GetSequenceElementType$OFFSET = $LAYOUT.byteOffset(groupElement("GetSequenceElementType"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSequenceElementType)(const OrtSequenceTypeInfo *, OrtTypeInfo **)
     * }
     */
    public static MemorySegment GetSequenceElementType(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {
        var funcPtr = struct.get(GetSequenceElementType$LAYOUT, GetSequenceElementType$OFFSET);
        return GetSequenceElementType.invoke(funcPtr, _x0, _x1);
    }

    /**
     * {@snippet lang=c :
     * void (*ReleaseMapTypeInfo)(OrtMapTypeInfo *)
     * }
     */
    private static class ReleaseMapTypeInfo {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ReleaseMapTypeInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ReleaseMapTypeInfo"));

    private static final long ReleaseMapTypeInfo$OFFSET = $LAYOUT.byteOffset(groupElement("ReleaseMapTypeInfo"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * void (*ReleaseMapTypeInfo)(OrtMapTypeInfo *)
     * }
     */
    public static void ReleaseMapTypeInfo(MemorySegment struct, MemorySegment _x0) {
        var funcPtr = struct.get(ReleaseMapTypeInfo$LAYOUT, ReleaseMapTypeInfo$OFFSET);
        ReleaseMapTypeInfo.invoke(funcPtr, _x0);
    }

    /**
     * {@snippet lang=c :
     * void (*ReleaseSequenceTypeInfo)(OrtSequenceTypeInfo *)
     * }
     */
    private static class ReleaseSequenceTypeInfo {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ReleaseSequenceTypeInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ReleaseSequenceTypeInfo"));

    private static final long ReleaseSequenceTypeInfo$OFFSET = $LAYOUT.byteOffset(groupElement("ReleaseSequenceTypeInfo"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * void (*ReleaseSequenceTypeInfo)(OrtSequenceTypeInfo *)
     * }
     */
    public static void ReleaseSequenceTypeInfo(MemorySegment struct, MemorySegment _x0) {
        var funcPtr = struct.get(ReleaseSequenceTypeInfo$LAYOUT, ReleaseSequenceTypeInfo$OFFSET);
        ReleaseSequenceTypeInfo.invoke(funcPtr, _x0);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionEndProfiling)(OrtSession *, OrtAllocator *, char **)
     * }
     */
    private static class SessionEndProfiling {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SessionEndProfiling$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SessionEndProfiling"));

    private static final long SessionEndProfiling$OFFSET = $LAYOUT.byteOffset(groupElement("SessionEndProfiling"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionEndProfiling)(OrtSession *, OrtAllocator *, char **)
     * }
     */
    public static MemorySegment SessionEndProfiling(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
        var funcPtr = struct.get(SessionEndProfiling$LAYOUT, SessionEndProfiling$OFFSET);
        return SessionEndProfiling.invoke(funcPtr, _x0, _x1, _x2);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetModelMetadata)(const OrtSession *, OrtModelMetadata **)
     * }
     */
    private static class SessionGetModelMetadata {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SessionGetModelMetadata$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SessionGetModelMetadata"));

    private static final long SessionGetModelMetadata$OFFSET = $LAYOUT.byteOffset(groupElement("SessionGetModelMetadata"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetModelMetadata)(const OrtSession *, OrtModelMetadata **)
     * }
     */
    public static MemorySegment SessionGetModelMetadata(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {
        var funcPtr = struct.get(SessionGetModelMetadata$LAYOUT, SessionGetModelMetadata$OFFSET);
        return SessionGetModelMetadata.invoke(funcPtr, _x0, _x1);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*ModelMetadataGetProducerName)(const OrtModelMetadata *, OrtAllocator *, char **)
     * }
     */
    private static class ModelMetadataGetProducerName {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ModelMetadataGetProducerName$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ModelMetadataGetProducerName"));

    private static final long ModelMetadataGetProducerName$OFFSET = $LAYOUT.byteOffset(groupElement("ModelMetadataGetProducerName"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ModelMetadataGetProducerName)(const OrtModelMetadata *, OrtAllocator *, char **)
     * }
     */
    public static MemorySegment ModelMetadataGetProducerName(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
        var funcPtr = struct.get(ModelMetadataGetProducerName$LAYOUT, ModelMetadataGetProducerName$OFFSET);
        return ModelMetadataGetProducerName.invoke(funcPtr, _x0, _x1, _x2);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*ModelMetadataGetGraphName)(const OrtModelMetadata *, OrtAllocator *, char **)
     * }
     */
    private static class ModelMetadataGetGraphName {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ModelMetadataGetGraphName$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ModelMetadataGetGraphName"));

    private static final long ModelMetadataGetGraphName$OFFSET = $LAYOUT.byteOffset(groupElement("ModelMetadataGetGraphName"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ModelMetadataGetGraphName)(const OrtModelMetadata *, OrtAllocator *, char **)
     * }
     */
    public static MemorySegment ModelMetadataGetGraphName(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
        var funcPtr = struct.get(ModelMetadataGetGraphName$LAYOUT, ModelMetadataGetGraphName$OFFSET);
        return ModelMetadataGetGraphName.invoke(funcPtr, _x0, _x1, _x2);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*ModelMetadataGetDomain)(const OrtModelMetadata *, OrtAllocator *, char **)
     * }
     */
    private static class ModelMetadataGetDomain {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ModelMetadataGetDomain$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ModelMetadataGetDomain"));

    private static final long ModelMetadataGetDomain$OFFSET = $LAYOUT.byteOffset(groupElement("ModelMetadataGetDomain"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ModelMetadataGetDomain)(const OrtModelMetadata *, OrtAllocator *, char **)
     * }
     */
    public static MemorySegment ModelMetadataGetDomain(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
        var funcPtr = struct.get(ModelMetadataGetDomain$LAYOUT, ModelMetadataGetDomain$OFFSET);
        return ModelMetadataGetDomain.invoke(funcPtr, _x0, _x1, _x2);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*ModelMetadataGetDescription)(const OrtModelMetadata *, OrtAllocator *, char **)
     * }
     */
    private static class ModelMetadataGetDescription {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ModelMetadataGetDescription$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ModelMetadataGetDescription"));

    private static final long ModelMetadataGetDescription$OFFSET = $LAYOUT.byteOffset(groupElement("ModelMetadataGetDescription"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ModelMetadataGetDescription)(const OrtModelMetadata *, OrtAllocator *, char **)
     * }
     */
    public static MemorySegment ModelMetadataGetDescription(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
        var funcPtr = struct.get(ModelMetadataGetDescription$LAYOUT, ModelMetadataGetDescription$OFFSET);
        return ModelMetadataGetDescription.invoke(funcPtr, _x0, _x1, _x2);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*ModelMetadataLookupCustomMetadataMap)(const OrtModelMetadata *, OrtAllocator *, const char *, char **)
     * }
     */
    private static class ModelMetadataLookupCustomMetadataMap {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ModelMetadataLookupCustomMetadataMap$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ModelMetadataLookupCustomMetadataMap"));

    private static final long ModelMetadataLookupCustomMetadataMap$OFFSET = $LAYOUT.byteOffset(groupElement("ModelMetadataLookupCustomMetadataMap"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ModelMetadataLookupCustomMetadataMap)(const OrtModelMetadata *, OrtAllocator *, const char *, char **)
     * }
     */
    public static MemorySegment ModelMetadataLookupCustomMetadataMap(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
        var funcPtr = struct.get(ModelMetadataLookupCustomMetadataMap$LAYOUT, ModelMetadataLookupCustomMetadataMap$OFFSET);
        return ModelMetadataLookupCustomMetadataMap.invoke(funcPtr, _x0, _x1, _x2, _x3);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*ModelMetadataGetVersion)(const OrtModelMetadata *, int64_t *)
     * }
     */
    private static class ModelMetadataGetVersion {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ModelMetadataGetVersion$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ModelMetadataGetVersion"));

    private static final long ModelMetadataGetVersion$OFFSET = $LAYOUT.byteOffset(groupElement("ModelMetadataGetVersion"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ModelMetadataGetVersion)(const OrtModelMetadata *, int64_t *)
     * }
     */
    public static MemorySegment ModelMetadataGetVersion(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {
        var funcPtr = struct.get(ModelMetadataGetVersion$LAYOUT, ModelMetadataGetVersion$OFFSET);
        return ModelMetadataGetVersion.invoke(funcPtr, _x0, _x1);
    }

    /**
     * {@snippet lang=c :
     * void (*ReleaseModelMetadata)(OrtModelMetadata *)
     * }
     */
    private static class ReleaseModelMetadata {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ReleaseModelMetadata$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ReleaseModelMetadata"));

    private static final long ReleaseModelMetadata$OFFSET = $LAYOUT.byteOffset(groupElement("ReleaseModelMetadata"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * void (*ReleaseModelMetadata)(OrtModelMetadata *)
     * }
     */
    public static void ReleaseModelMetadata(MemorySegment struct, MemorySegment _x0) {
        var funcPtr = struct.get(ReleaseModelMetadata$LAYOUT, ReleaseModelMetadata$OFFSET);
        ReleaseModelMetadata.invoke(funcPtr, _x0);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateEnvWithGlobalThreadPools)(OrtLoggingLevel, const char *, const OrtThreadingOptions *, OrtEnv **)
     * }
     */
    private static class CreateEnvWithGlobalThreadPools {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_INT,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,int _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CreateEnvWithGlobalThreadPools$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CreateEnvWithGlobalThreadPools"));

    private static final long CreateEnvWithGlobalThreadPools$OFFSET = $LAYOUT.byteOffset(groupElement("CreateEnvWithGlobalThreadPools"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateEnvWithGlobalThreadPools)(OrtLoggingLevel, const char *, const OrtThreadingOptions *, OrtEnv **)
     * }
     */
    public static MemorySegment CreateEnvWithGlobalThreadPools(MemorySegment struct, int _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
        var funcPtr = struct.get(CreateEnvWithGlobalThreadPools$LAYOUT, CreateEnvWithGlobalThreadPools$OFFSET);
        return CreateEnvWithGlobalThreadPools.invoke(funcPtr, _x0, _x1, _x2, _x3);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*DisablePerSessionThreads)(OrtSessionOptions *)
     * }
     */
    private static class DisablePerSessionThreads {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout DisablePerSessionThreads$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("DisablePerSessionThreads"));

    private static final long DisablePerSessionThreads$OFFSET = $LAYOUT.byteOffset(groupElement("DisablePerSessionThreads"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*DisablePerSessionThreads)(OrtSessionOptions *)
     * }
     */
    public static MemorySegment DisablePerSessionThreads(MemorySegment struct, MemorySegment _x0) {
        var funcPtr = struct.get(DisablePerSessionThreads$LAYOUT, DisablePerSessionThreads$OFFSET);
        return DisablePerSessionThreads.invoke(funcPtr, _x0);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateThreadingOptions)(OrtThreadingOptions **)
     * }
     */
    private static class CreateThreadingOptions {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CreateThreadingOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CreateThreadingOptions"));

    private static final long CreateThreadingOptions$OFFSET = $LAYOUT.byteOffset(groupElement("CreateThreadingOptions"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateThreadingOptions)(OrtThreadingOptions **)
     * }
     */
    public static MemorySegment CreateThreadingOptions(MemorySegment struct, MemorySegment _x0) {
        var funcPtr = struct.get(CreateThreadingOptions$LAYOUT, CreateThreadingOptions$OFFSET);
        return CreateThreadingOptions.invoke(funcPtr, _x0);
    }

    /**
     * {@snippet lang=c :
     * void (*ReleaseThreadingOptions)(OrtThreadingOptions *)
     * }
     */
    private static class ReleaseThreadingOptions {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ReleaseThreadingOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ReleaseThreadingOptions"));

    private static final long ReleaseThreadingOptions$OFFSET = $LAYOUT.byteOffset(groupElement("ReleaseThreadingOptions"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * void (*ReleaseThreadingOptions)(OrtThreadingOptions *)
     * }
     */
    public static void ReleaseThreadingOptions(MemorySegment struct, MemorySegment _x0) {
        var funcPtr = struct.get(ReleaseThreadingOptions$LAYOUT, ReleaseThreadingOptions$OFFSET);
        ReleaseThreadingOptions.invoke(funcPtr, _x0);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*ModelMetadataGetCustomMetadataMapKeys)(const OrtModelMetadata *, OrtAllocator *, char ***, int64_t *)
     * }
     */
    private static class ModelMetadataGetCustomMetadataMapKeys {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ModelMetadataGetCustomMetadataMapKeys$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ModelMetadataGetCustomMetadataMapKeys"));

    private static final long ModelMetadataGetCustomMetadataMapKeys$OFFSET = $LAYOUT.byteOffset(groupElement("ModelMetadataGetCustomMetadataMapKeys"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ModelMetadataGetCustomMetadataMapKeys)(const OrtModelMetadata *, OrtAllocator *, char ***, int64_t *)
     * }
     */
    public static MemorySegment ModelMetadataGetCustomMetadataMapKeys(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
        var funcPtr = struct.get(ModelMetadataGetCustomMetadataMapKeys$LAYOUT, ModelMetadataGetCustomMetadataMapKeys$OFFSET);
        return ModelMetadataGetCustomMetadataMapKeys.invoke(funcPtr, _x0, _x1, _x2, _x3);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*AddFreeDimensionOverrideByName)(OrtSessionOptions *, const char *, int64_t)
     * }
     */
    private static class AddFreeDimensionOverrideByName {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout AddFreeDimensionOverrideByName$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("AddFreeDimensionOverrideByName"));

    private static final long AddFreeDimensionOverrideByName$OFFSET = $LAYOUT.byteOffset(groupElement("AddFreeDimensionOverrideByName"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AddFreeDimensionOverrideByName)(OrtSessionOptions *, const char *, int64_t)
     * }
     */
    public static MemorySegment AddFreeDimensionOverrideByName(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, long _x2) {
        var funcPtr = struct.get(AddFreeDimensionOverrideByName$LAYOUT, AddFreeDimensionOverrideByName$OFFSET);
        return AddFreeDimensionOverrideByName.invoke(funcPtr, _x0, _x1, _x2);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetAvailableProviders)(char ***, int *)
     * }
     */
    private static class GetAvailableProviders {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetAvailableProviders$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetAvailableProviders"));

    private static final long GetAvailableProviders$OFFSET = $LAYOUT.byteOffset(groupElement("GetAvailableProviders"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetAvailableProviders)(char ***, int *)
     * }
     */
    public static MemorySegment GetAvailableProviders(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {
        var funcPtr = struct.get(GetAvailableProviders$LAYOUT, GetAvailableProviders$OFFSET);
        return GetAvailableProviders.invoke(funcPtr, _x0, _x1);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*ReleaseAvailableProviders)(char **, int)
     * }
     */
    private static class ReleaseAvailableProviders {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_INT
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ReleaseAvailableProviders$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ReleaseAvailableProviders"));

    private static final long ReleaseAvailableProviders$OFFSET = $LAYOUT.byteOffset(groupElement("ReleaseAvailableProviders"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ReleaseAvailableProviders)(char **, int)
     * }
     */
    public static MemorySegment ReleaseAvailableProviders(MemorySegment struct, MemorySegment _x0, int _x1) {
        var funcPtr = struct.get(ReleaseAvailableProviders$LAYOUT, ReleaseAvailableProviders$OFFSET);
        return ReleaseAvailableProviders.invoke(funcPtr, _x0, _x1);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetStringTensorElementLength)(const OrtValue *, size_t, size_t *)
     * }
     */
    private static class GetStringTensorElementLength {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, long _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetStringTensorElementLength$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetStringTensorElementLength"));

    private static final long GetStringTensorElementLength$OFFSET = $LAYOUT.byteOffset(groupElement("GetStringTensorElementLength"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetStringTensorElementLength)(const OrtValue *, size_t, size_t *)
     * }
     */
    public static MemorySegment GetStringTensorElementLength(MemorySegment struct, MemorySegment _x0, long _x1, MemorySegment _x2) {
        var funcPtr = struct.get(GetStringTensorElementLength$LAYOUT, GetStringTensorElementLength$OFFSET);
        return GetStringTensorElementLength.invoke(funcPtr, _x0, _x1, _x2);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetStringTensorElement)(const OrtValue *, size_t, size_t, void *)
     * }
     */
    private static class GetStringTensorElement {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, long _x1, long _x2, MemorySegment _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetStringTensorElement$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetStringTensorElement"));

    private static final long GetStringTensorElement$OFFSET = $LAYOUT.byteOffset(groupElement("GetStringTensorElement"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetStringTensorElement)(const OrtValue *, size_t, size_t, void *)
     * }
     */
    public static MemorySegment GetStringTensorElement(MemorySegment struct, MemorySegment _x0, long _x1, long _x2, MemorySegment _x3) {
        var funcPtr = struct.get(GetStringTensorElement$LAYOUT, GetStringTensorElement$OFFSET);
        return GetStringTensorElement.invoke(funcPtr, _x0, _x1, _x2, _x3);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*FillStringTensorElement)(OrtValue *, const char *, size_t)
     * }
     */
    private static class FillStringTensorElement {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout FillStringTensorElement$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("FillStringTensorElement"));

    private static final long FillStringTensorElement$OFFSET = $LAYOUT.byteOffset(groupElement("FillStringTensorElement"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*FillStringTensorElement)(OrtValue *, const char *, size_t)
     * }
     */
    public static MemorySegment FillStringTensorElement(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, long _x2) {
        var funcPtr = struct.get(FillStringTensorElement$LAYOUT, FillStringTensorElement$OFFSET);
        return FillStringTensorElement.invoke(funcPtr, _x0, _x1, _x2);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*AddSessionConfigEntry)(OrtSessionOptions *, const char *, const char *)
     * }
     */
    private static class AddSessionConfigEntry {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout AddSessionConfigEntry$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("AddSessionConfigEntry"));

    private static final long AddSessionConfigEntry$OFFSET = $LAYOUT.byteOffset(groupElement("AddSessionConfigEntry"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AddSessionConfigEntry)(OrtSessionOptions *, const char *, const char *)
     * }
     */
    public static MemorySegment AddSessionConfigEntry(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
        var funcPtr = struct.get(AddSessionConfigEntry$LAYOUT, AddSessionConfigEntry$OFFSET);
        return AddSessionConfigEntry.invoke(funcPtr, _x0, _x1, _x2);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateAllocator)(const OrtSession *, const OrtMemoryInfo *, OrtAllocator **)
     * }
     */
    private static class CreateAllocator {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CreateAllocator$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CreateAllocator"));

    private static final long CreateAllocator$OFFSET = $LAYOUT.byteOffset(groupElement("CreateAllocator"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateAllocator)(const OrtSession *, const OrtMemoryInfo *, OrtAllocator **)
     * }
     */
    public static MemorySegment CreateAllocator(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
        var funcPtr = struct.get(CreateAllocator$LAYOUT, CreateAllocator$OFFSET);
        return CreateAllocator.invoke(funcPtr, _x0, _x1, _x2);
    }

    /**
     * {@snippet lang=c :
     * void (*ReleaseAllocator)(OrtAllocator *)
     * }
     */
    private static class ReleaseAllocator {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ReleaseAllocator$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ReleaseAllocator"));

    private static final long ReleaseAllocator$OFFSET = $LAYOUT.byteOffset(groupElement("ReleaseAllocator"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * void (*ReleaseAllocator)(OrtAllocator *)
     * }
     */
    public static void ReleaseAllocator(MemorySegment struct, MemorySegment _x0) {
        var funcPtr = struct.get(ReleaseAllocator$LAYOUT, ReleaseAllocator$OFFSET);
        ReleaseAllocator.invoke(funcPtr, _x0);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*RunWithBinding)(OrtSession *, const OrtRunOptions *, const OrtIoBinding *)
     * }
     */
    private static class RunWithBinding {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout RunWithBinding$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("RunWithBinding"));

    private static final long RunWithBinding$OFFSET = $LAYOUT.byteOffset(groupElement("RunWithBinding"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RunWithBinding)(OrtSession *, const OrtRunOptions *, const OrtIoBinding *)
     * }
     */
    public static MemorySegment RunWithBinding(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
        var funcPtr = struct.get(RunWithBinding$LAYOUT, RunWithBinding$OFFSET);
        return RunWithBinding.invoke(funcPtr, _x0, _x1, _x2);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateIoBinding)(OrtSession *, OrtIoBinding **)
     * }
     */
    private static class CreateIoBinding {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CreateIoBinding$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CreateIoBinding"));

    private static final long CreateIoBinding$OFFSET = $LAYOUT.byteOffset(groupElement("CreateIoBinding"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateIoBinding)(OrtSession *, OrtIoBinding **)
     * }
     */
    public static MemorySegment CreateIoBinding(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {
        var funcPtr = struct.get(CreateIoBinding$LAYOUT, CreateIoBinding$OFFSET);
        return CreateIoBinding.invoke(funcPtr, _x0, _x1);
    }

    /**
     * {@snippet lang=c :
     * void (*ReleaseIoBinding)(OrtIoBinding *)
     * }
     */
    private static class ReleaseIoBinding {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ReleaseIoBinding$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ReleaseIoBinding"));

    private static final long ReleaseIoBinding$OFFSET = $LAYOUT.byteOffset(groupElement("ReleaseIoBinding"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * void (*ReleaseIoBinding)(OrtIoBinding *)
     * }
     */
    public static void ReleaseIoBinding(MemorySegment struct, MemorySegment _x0) {
        var funcPtr = struct.get(ReleaseIoBinding$LAYOUT, ReleaseIoBinding$OFFSET);
        ReleaseIoBinding.invoke(funcPtr, _x0);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*BindInput)(OrtIoBinding *, const char *, const OrtValue *)
     * }
     */
    private static class BindInput {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout BindInput$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("BindInput"));

    private static final long BindInput$OFFSET = $LAYOUT.byteOffset(groupElement("BindInput"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*BindInput)(OrtIoBinding *, const char *, const OrtValue *)
     * }
     */
    public static MemorySegment BindInput(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
        var funcPtr = struct.get(BindInput$LAYOUT, BindInput$OFFSET);
        return BindInput.invoke(funcPtr, _x0, _x1, _x2);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*BindOutput)(OrtIoBinding *, const char *, const OrtValue *)
     * }
     */
    private static class BindOutput {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout BindOutput$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("BindOutput"));

    private static final long BindOutput$OFFSET = $LAYOUT.byteOffset(groupElement("BindOutput"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*BindOutput)(OrtIoBinding *, const char *, const OrtValue *)
     * }
     */
    public static MemorySegment BindOutput(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
        var funcPtr = struct.get(BindOutput$LAYOUT, BindOutput$OFFSET);
        return BindOutput.invoke(funcPtr, _x0, _x1, _x2);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*BindOutputToDevice)(OrtIoBinding *, const char *, const OrtMemoryInfo *)
     * }
     */
    private static class BindOutputToDevice {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout BindOutputToDevice$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("BindOutputToDevice"));

    private static final long BindOutputToDevice$OFFSET = $LAYOUT.byteOffset(groupElement("BindOutputToDevice"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*BindOutputToDevice)(OrtIoBinding *, const char *, const OrtMemoryInfo *)
     * }
     */
    public static MemorySegment BindOutputToDevice(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
        var funcPtr = struct.get(BindOutputToDevice$LAYOUT, BindOutputToDevice$OFFSET);
        return BindOutputToDevice.invoke(funcPtr, _x0, _x1, _x2);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetBoundOutputNames)(const OrtIoBinding *, OrtAllocator *, char **, size_t **, size_t *)
     * }
     */
    private static class GetBoundOutputNames {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetBoundOutputNames$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetBoundOutputNames"));

    private static final long GetBoundOutputNames$OFFSET = $LAYOUT.byteOffset(groupElement("GetBoundOutputNames"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetBoundOutputNames)(const OrtIoBinding *, OrtAllocator *, char **, size_t **, size_t *)
     * }
     */
    public static MemorySegment GetBoundOutputNames(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4) {
        var funcPtr = struct.get(GetBoundOutputNames$LAYOUT, GetBoundOutputNames$OFFSET);
        return GetBoundOutputNames.invoke(funcPtr, _x0, _x1, _x2, _x3, _x4);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetBoundOutputValues)(const OrtIoBinding *, OrtAllocator *, OrtValue ***, size_t *)
     * }
     */
    private static class GetBoundOutputValues {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetBoundOutputValues$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetBoundOutputValues"));

    private static final long GetBoundOutputValues$OFFSET = $LAYOUT.byteOffset(groupElement("GetBoundOutputValues"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetBoundOutputValues)(const OrtIoBinding *, OrtAllocator *, OrtValue ***, size_t *)
     * }
     */
    public static MemorySegment GetBoundOutputValues(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
        var funcPtr = struct.get(GetBoundOutputValues$LAYOUT, GetBoundOutputValues$OFFSET);
        return GetBoundOutputValues.invoke(funcPtr, _x0, _x1, _x2, _x3);
    }

    /**
     * {@snippet lang=c :
     * void (*ClearBoundInputs)(OrtIoBinding *)
     * }
     */
    private static class ClearBoundInputs {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ClearBoundInputs$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ClearBoundInputs"));

    private static final long ClearBoundInputs$OFFSET = $LAYOUT.byteOffset(groupElement("ClearBoundInputs"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * void (*ClearBoundInputs)(OrtIoBinding *)
     * }
     */
    public static void ClearBoundInputs(MemorySegment struct, MemorySegment _x0) {
        var funcPtr = struct.get(ClearBoundInputs$LAYOUT, ClearBoundInputs$OFFSET);
        ClearBoundInputs.invoke(funcPtr, _x0);
    }

    /**
     * {@snippet lang=c :
     * void (*ClearBoundOutputs)(OrtIoBinding *)
     * }
     */
    private static class ClearBoundOutputs {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ClearBoundOutputs$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ClearBoundOutputs"));

    private static final long ClearBoundOutputs$OFFSET = $LAYOUT.byteOffset(groupElement("ClearBoundOutputs"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * void (*ClearBoundOutputs)(OrtIoBinding *)
     * }
     */
    public static void ClearBoundOutputs(MemorySegment struct, MemorySegment _x0) {
        var funcPtr = struct.get(ClearBoundOutputs$LAYOUT, ClearBoundOutputs$OFFSET);
        ClearBoundOutputs.invoke(funcPtr, _x0);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*TensorAt)(OrtValue *, const int64_t *, size_t, void **)
     * }
     */
    private static class TensorAt {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout TensorAt$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("TensorAt"));

    private static final long TensorAt$OFFSET = $LAYOUT.byteOffset(groupElement("TensorAt"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*TensorAt)(OrtValue *, const int64_t *, size_t, void **)
     * }
     */
    public static MemorySegment TensorAt(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3) {
        var funcPtr = struct.get(TensorAt$LAYOUT, TensorAt$OFFSET);
        return TensorAt.invoke(funcPtr, _x0, _x1, _x2, _x3);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateAndRegisterAllocator)(OrtEnv *, const OrtMemoryInfo *, const OrtArenaCfg *)
     * }
     */
    private static class CreateAndRegisterAllocator {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CreateAndRegisterAllocator$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CreateAndRegisterAllocator"));

    private static final long CreateAndRegisterAllocator$OFFSET = $LAYOUT.byteOffset(groupElement("CreateAndRegisterAllocator"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateAndRegisterAllocator)(OrtEnv *, const OrtMemoryInfo *, const OrtArenaCfg *)
     * }
     */
    public static MemorySegment CreateAndRegisterAllocator(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
        var funcPtr = struct.get(CreateAndRegisterAllocator$LAYOUT, CreateAndRegisterAllocator$OFFSET);
        return CreateAndRegisterAllocator.invoke(funcPtr, _x0, _x1, _x2);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SetLanguageProjection)(const OrtEnv *, OrtLanguageProjection)
     * }
     */
    private static class SetLanguageProjection {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_INT
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SetLanguageProjection$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SetLanguageProjection"));

    private static final long SetLanguageProjection$OFFSET = $LAYOUT.byteOffset(groupElement("SetLanguageProjection"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetLanguageProjection)(const OrtEnv *, OrtLanguageProjection)
     * }
     */
    public static MemorySegment SetLanguageProjection(MemorySegment struct, MemorySegment _x0, int _x1) {
        var funcPtr = struct.get(SetLanguageProjection$LAYOUT, SetLanguageProjection$OFFSET);
        return SetLanguageProjection.invoke(funcPtr, _x0, _x1);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetProfilingStartTimeNs)(const OrtSession *, uint64_t *)
     * }
     */
    private static class SessionGetProfilingStartTimeNs {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SessionGetProfilingStartTimeNs$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SessionGetProfilingStartTimeNs"));

    private static final long SessionGetProfilingStartTimeNs$OFFSET = $LAYOUT.byteOffset(groupElement("SessionGetProfilingStartTimeNs"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetProfilingStartTimeNs)(const OrtSession *, uint64_t *)
     * }
     */
    public static MemorySegment SessionGetProfilingStartTimeNs(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {
        var funcPtr = struct.get(SessionGetProfilingStartTimeNs$LAYOUT, SessionGetProfilingStartTimeNs$OFFSET);
        return SessionGetProfilingStartTimeNs.invoke(funcPtr, _x0, _x1);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGlobalIntraOpNumThreads)(OrtThreadingOptions *, int)
     * }
     */
    private static class SetGlobalIntraOpNumThreads {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_INT
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SetGlobalIntraOpNumThreads$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SetGlobalIntraOpNumThreads"));

    private static final long SetGlobalIntraOpNumThreads$OFFSET = $LAYOUT.byteOffset(groupElement("SetGlobalIntraOpNumThreads"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGlobalIntraOpNumThreads)(OrtThreadingOptions *, int)
     * }
     */
    public static MemorySegment SetGlobalIntraOpNumThreads(MemorySegment struct, MemorySegment _x0, int _x1) {
        var funcPtr = struct.get(SetGlobalIntraOpNumThreads$LAYOUT, SetGlobalIntraOpNumThreads$OFFSET);
        return SetGlobalIntraOpNumThreads.invoke(funcPtr, _x0, _x1);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGlobalInterOpNumThreads)(OrtThreadingOptions *, int)
     * }
     */
    private static class SetGlobalInterOpNumThreads {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_INT
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SetGlobalInterOpNumThreads$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SetGlobalInterOpNumThreads"));

    private static final long SetGlobalInterOpNumThreads$OFFSET = $LAYOUT.byteOffset(groupElement("SetGlobalInterOpNumThreads"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGlobalInterOpNumThreads)(OrtThreadingOptions *, int)
     * }
     */
    public static MemorySegment SetGlobalInterOpNumThreads(MemorySegment struct, MemorySegment _x0, int _x1) {
        var funcPtr = struct.get(SetGlobalInterOpNumThreads$LAYOUT, SetGlobalInterOpNumThreads$OFFSET);
        return SetGlobalInterOpNumThreads.invoke(funcPtr, _x0, _x1);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGlobalSpinControl)(OrtThreadingOptions *, int)
     * }
     */
    private static class SetGlobalSpinControl {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_INT
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SetGlobalSpinControl$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SetGlobalSpinControl"));

    private static final long SetGlobalSpinControl$OFFSET = $LAYOUT.byteOffset(groupElement("SetGlobalSpinControl"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGlobalSpinControl)(OrtThreadingOptions *, int)
     * }
     */
    public static MemorySegment SetGlobalSpinControl(MemorySegment struct, MemorySegment _x0, int _x1) {
        var funcPtr = struct.get(SetGlobalSpinControl$LAYOUT, SetGlobalSpinControl$OFFSET);
        return SetGlobalSpinControl.invoke(funcPtr, _x0, _x1);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*AddInitializer)(OrtSessionOptions *, const char *, const OrtValue *)
     * }
     */
    private static class AddInitializer {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout AddInitializer$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("AddInitializer"));

    private static final long AddInitializer$OFFSET = $LAYOUT.byteOffset(groupElement("AddInitializer"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AddInitializer)(OrtSessionOptions *, const char *, const OrtValue *)
     * }
     */
    public static MemorySegment AddInitializer(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
        var funcPtr = struct.get(AddInitializer$LAYOUT, AddInitializer$OFFSET);
        return AddInitializer.invoke(funcPtr, _x0, _x1, _x2);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateEnvWithCustomLoggerAndGlobalThreadPools)(OrtLoggingFunction, void *, OrtLoggingLevel, const char *, const struct OrtThreadingOptions *, OrtEnv **)
     * }
     */
    private static class CreateEnvWithCustomLoggerAndGlobalThreadPools {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_INT,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, int _x2, MemorySegment _x3, MemorySegment _x4, MemorySegment _x5) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CreateEnvWithCustomLoggerAndGlobalThreadPools$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CreateEnvWithCustomLoggerAndGlobalThreadPools"));

    private static final long CreateEnvWithCustomLoggerAndGlobalThreadPools$OFFSET = $LAYOUT.byteOffset(groupElement("CreateEnvWithCustomLoggerAndGlobalThreadPools"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateEnvWithCustomLoggerAndGlobalThreadPools)(OrtLoggingFunction, void *, OrtLoggingLevel, const char *, const struct OrtThreadingOptions *, OrtEnv **)
     * }
     */
    public static MemorySegment CreateEnvWithCustomLoggerAndGlobalThreadPools(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, int _x2, MemorySegment _x3, MemorySegment _x4, MemorySegment _x5) {
        var funcPtr = struct.get(CreateEnvWithCustomLoggerAndGlobalThreadPools$LAYOUT, CreateEnvWithCustomLoggerAndGlobalThreadPools$OFFSET);
        return CreateEnvWithCustomLoggerAndGlobalThreadPools.invoke(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_CUDA)(OrtSessionOptions *, const OrtCUDAProviderOptions *)
     * }
     */
    private static class SessionOptionsAppendExecutionProvider_CUDA {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SessionOptionsAppendExecutionProvider_CUDA$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SessionOptionsAppendExecutionProvider_CUDA"));

    private static final long SessionOptionsAppendExecutionProvider_CUDA$OFFSET = $LAYOUT.byteOffset(groupElement("SessionOptionsAppendExecutionProvider_CUDA"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_CUDA)(OrtSessionOptions *, const OrtCUDAProviderOptions *)
     * }
     */
    public static MemorySegment SessionOptionsAppendExecutionProvider_CUDA(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {
        var funcPtr = struct.get(SessionOptionsAppendExecutionProvider_CUDA$LAYOUT, SessionOptionsAppendExecutionProvider_CUDA$OFFSET);
        return SessionOptionsAppendExecutionProvider_CUDA.invoke(funcPtr, _x0, _x1);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_ROCM)(OrtSessionOptions *, const OrtROCMProviderOptions *)
     * }
     */
    private static class SessionOptionsAppendExecutionProvider_ROCM {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SessionOptionsAppendExecutionProvider_ROCM$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SessionOptionsAppendExecutionProvider_ROCM"));

    private static final long SessionOptionsAppendExecutionProvider_ROCM$OFFSET = $LAYOUT.byteOffset(groupElement("SessionOptionsAppendExecutionProvider_ROCM"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_ROCM)(OrtSessionOptions *, const OrtROCMProviderOptions *)
     * }
     */
    public static MemorySegment SessionOptionsAppendExecutionProvider_ROCM(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {
        var funcPtr = struct.get(SessionOptionsAppendExecutionProvider_ROCM$LAYOUT, SessionOptionsAppendExecutionProvider_ROCM$OFFSET);
        return SessionOptionsAppendExecutionProvider_ROCM.invoke(funcPtr, _x0, _x1);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_OpenVINO)(OrtSessionOptions *, const OrtOpenVINOProviderOptions *)
     * }
     */
    private static class SessionOptionsAppendExecutionProvider_OpenVINO {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SessionOptionsAppendExecutionProvider_OpenVINO$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SessionOptionsAppendExecutionProvider_OpenVINO"));

    private static final long SessionOptionsAppendExecutionProvider_OpenVINO$OFFSET = $LAYOUT.byteOffset(groupElement("SessionOptionsAppendExecutionProvider_OpenVINO"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_OpenVINO)(OrtSessionOptions *, const OrtOpenVINOProviderOptions *)
     * }
     */
    public static MemorySegment SessionOptionsAppendExecutionProvider_OpenVINO(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {
        var funcPtr = struct.get(SessionOptionsAppendExecutionProvider_OpenVINO$LAYOUT, SessionOptionsAppendExecutionProvider_OpenVINO$OFFSET);
        return SessionOptionsAppendExecutionProvider_OpenVINO.invoke(funcPtr, _x0, _x1);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGlobalDenormalAsZero)(OrtThreadingOptions *)
     * }
     */
    private static class SetGlobalDenormalAsZero {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SetGlobalDenormalAsZero$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SetGlobalDenormalAsZero"));

    private static final long SetGlobalDenormalAsZero$OFFSET = $LAYOUT.byteOffset(groupElement("SetGlobalDenormalAsZero"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGlobalDenormalAsZero)(OrtThreadingOptions *)
     * }
     */
    public static MemorySegment SetGlobalDenormalAsZero(MemorySegment struct, MemorySegment _x0) {
        var funcPtr = struct.get(SetGlobalDenormalAsZero$LAYOUT, SetGlobalDenormalAsZero$OFFSET);
        return SetGlobalDenormalAsZero.invoke(funcPtr, _x0);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateArenaCfg)(size_t, int, int, int, OrtArenaCfg **)
     * }
     */
    private static class CreateArenaCfg {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_INT,
            onnxruntime_c_api_h.C_INT,
            onnxruntime_c_api_h.C_INT,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,long _x0, int _x1, int _x2, int _x3, MemorySegment _x4) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CreateArenaCfg$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CreateArenaCfg"));

    private static final long CreateArenaCfg$OFFSET = $LAYOUT.byteOffset(groupElement("CreateArenaCfg"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateArenaCfg)(size_t, int, int, int, OrtArenaCfg **)
     * }
     */
    public static MemorySegment CreateArenaCfg(MemorySegment struct, long _x0, int _x1, int _x2, int _x3, MemorySegment _x4) {
        var funcPtr = struct.get(CreateArenaCfg$LAYOUT, CreateArenaCfg$OFFSET);
        return CreateArenaCfg.invoke(funcPtr, _x0, _x1, _x2, _x3, _x4);
    }

    /**
     * {@snippet lang=c :
     * void (*ReleaseArenaCfg)(OrtArenaCfg *)
     * }
     */
    private static class ReleaseArenaCfg {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ReleaseArenaCfg$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ReleaseArenaCfg"));

    private static final long ReleaseArenaCfg$OFFSET = $LAYOUT.byteOffset(groupElement("ReleaseArenaCfg"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * void (*ReleaseArenaCfg)(OrtArenaCfg *)
     * }
     */
    public static void ReleaseArenaCfg(MemorySegment struct, MemorySegment _x0) {
        var funcPtr = struct.get(ReleaseArenaCfg$LAYOUT, ReleaseArenaCfg$OFFSET);
        ReleaseArenaCfg.invoke(funcPtr, _x0);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*ModelMetadataGetGraphDescription)(const OrtModelMetadata *, OrtAllocator *, char **)
     * }
     */
    private static class ModelMetadataGetGraphDescription {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ModelMetadataGetGraphDescription$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ModelMetadataGetGraphDescription"));

    private static final long ModelMetadataGetGraphDescription$OFFSET = $LAYOUT.byteOffset(groupElement("ModelMetadataGetGraphDescription"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ModelMetadataGetGraphDescription)(const OrtModelMetadata *, OrtAllocator *, char **)
     * }
     */
    public static MemorySegment ModelMetadataGetGraphDescription(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
        var funcPtr = struct.get(ModelMetadataGetGraphDescription$LAYOUT, ModelMetadataGetGraphDescription$OFFSET);
        return ModelMetadataGetGraphDescription.invoke(funcPtr, _x0, _x1, _x2);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_TensorRT)(OrtSessionOptions *, const OrtTensorRTProviderOptions *)
     * }
     */
    private static class SessionOptionsAppendExecutionProvider_TensorRT {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SessionOptionsAppendExecutionProvider_TensorRT$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SessionOptionsAppendExecutionProvider_TensorRT"));

    private static final long SessionOptionsAppendExecutionProvider_TensorRT$OFFSET = $LAYOUT.byteOffset(groupElement("SessionOptionsAppendExecutionProvider_TensorRT"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_TensorRT)(OrtSessionOptions *, const OrtTensorRTProviderOptions *)
     * }
     */
    public static MemorySegment SessionOptionsAppendExecutionProvider_TensorRT(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {
        var funcPtr = struct.get(SessionOptionsAppendExecutionProvider_TensorRT$LAYOUT, SessionOptionsAppendExecutionProvider_TensorRT$OFFSET);
        return SessionOptionsAppendExecutionProvider_TensorRT.invoke(funcPtr, _x0, _x1);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SetCurrentGpuDeviceId)(int)
     * }
     */
    private static class SetCurrentGpuDeviceId {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_INT
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,int _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SetCurrentGpuDeviceId$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SetCurrentGpuDeviceId"));

    private static final long SetCurrentGpuDeviceId$OFFSET = $LAYOUT.byteOffset(groupElement("SetCurrentGpuDeviceId"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetCurrentGpuDeviceId)(int)
     * }
     */
    public static MemorySegment SetCurrentGpuDeviceId(MemorySegment struct, int _x0) {
        var funcPtr = struct.get(SetCurrentGpuDeviceId$LAYOUT, SetCurrentGpuDeviceId$OFFSET);
        return SetCurrentGpuDeviceId.invoke(funcPtr, _x0);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetCurrentGpuDeviceId)(int *)
     * }
     */
    private static class GetCurrentGpuDeviceId {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetCurrentGpuDeviceId$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetCurrentGpuDeviceId"));

    private static final long GetCurrentGpuDeviceId$OFFSET = $LAYOUT.byteOffset(groupElement("GetCurrentGpuDeviceId"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetCurrentGpuDeviceId)(int *)
     * }
     */
    public static MemorySegment GetCurrentGpuDeviceId(MemorySegment struct, MemorySegment _x0) {
        var funcPtr = struct.get(GetCurrentGpuDeviceId$LAYOUT, GetCurrentGpuDeviceId$OFFSET);
        return GetCurrentGpuDeviceId.invoke(funcPtr, _x0);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfoGetAttributeArray_float)(const OrtKernelInfo *, const char *, float *, size_t *)
     * }
     */
    private static class KernelInfoGetAttributeArray_float {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout KernelInfoGetAttributeArray_float$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("KernelInfoGetAttributeArray_float"));

    private static final long KernelInfoGetAttributeArray_float$OFFSET = $LAYOUT.byteOffset(groupElement("KernelInfoGetAttributeArray_float"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfoGetAttributeArray_float)(const OrtKernelInfo *, const char *, float *, size_t *)
     * }
     */
    public static MemorySegment KernelInfoGetAttributeArray_float(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
        var funcPtr = struct.get(KernelInfoGetAttributeArray_float$LAYOUT, KernelInfoGetAttributeArray_float$OFFSET);
        return KernelInfoGetAttributeArray_float.invoke(funcPtr, _x0, _x1, _x2, _x3);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfoGetAttributeArray_int64)(const OrtKernelInfo *, const char *, int64_t *, size_t *)
     * }
     */
    private static class KernelInfoGetAttributeArray_int64 {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout KernelInfoGetAttributeArray_int64$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("KernelInfoGetAttributeArray_int64"));

    private static final long KernelInfoGetAttributeArray_int64$OFFSET = $LAYOUT.byteOffset(groupElement("KernelInfoGetAttributeArray_int64"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfoGetAttributeArray_int64)(const OrtKernelInfo *, const char *, int64_t *, size_t *)
     * }
     */
    public static MemorySegment KernelInfoGetAttributeArray_int64(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
        var funcPtr = struct.get(KernelInfoGetAttributeArray_int64$LAYOUT, KernelInfoGetAttributeArray_int64$OFFSET);
        return KernelInfoGetAttributeArray_int64.invoke(funcPtr, _x0, _x1, _x2, _x3);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateArenaCfgV2)(const char *const *, const size_t *, size_t, OrtArenaCfg **)
     * }
     */
    private static class CreateArenaCfgV2 {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CreateArenaCfgV2$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CreateArenaCfgV2"));

    private static final long CreateArenaCfgV2$OFFSET = $LAYOUT.byteOffset(groupElement("CreateArenaCfgV2"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateArenaCfgV2)(const char *const *, const size_t *, size_t, OrtArenaCfg **)
     * }
     */
    public static MemorySegment CreateArenaCfgV2(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3) {
        var funcPtr = struct.get(CreateArenaCfgV2$LAYOUT, CreateArenaCfgV2$OFFSET);
        return CreateArenaCfgV2.invoke(funcPtr, _x0, _x1, _x2, _x3);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*AddRunConfigEntry)(OrtRunOptions *, const char *, const char *)
     * }
     */
    private static class AddRunConfigEntry {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout AddRunConfigEntry$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("AddRunConfigEntry"));

    private static final long AddRunConfigEntry$OFFSET = $LAYOUT.byteOffset(groupElement("AddRunConfigEntry"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AddRunConfigEntry)(OrtRunOptions *, const char *, const char *)
     * }
     */
    public static MemorySegment AddRunConfigEntry(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
        var funcPtr = struct.get(AddRunConfigEntry$LAYOUT, AddRunConfigEntry$OFFSET);
        return AddRunConfigEntry.invoke(funcPtr, _x0, _x1, _x2);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreatePrepackedWeightsContainer)(OrtPrepackedWeightsContainer **)
     * }
     */
    private static class CreatePrepackedWeightsContainer {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CreatePrepackedWeightsContainer$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CreatePrepackedWeightsContainer"));

    private static final long CreatePrepackedWeightsContainer$OFFSET = $LAYOUT.byteOffset(groupElement("CreatePrepackedWeightsContainer"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreatePrepackedWeightsContainer)(OrtPrepackedWeightsContainer **)
     * }
     */
    public static MemorySegment CreatePrepackedWeightsContainer(MemorySegment struct, MemorySegment _x0) {
        var funcPtr = struct.get(CreatePrepackedWeightsContainer$LAYOUT, CreatePrepackedWeightsContainer$OFFSET);
        return CreatePrepackedWeightsContainer.invoke(funcPtr, _x0);
    }

    /**
     * {@snippet lang=c :
     * void (*ReleasePrepackedWeightsContainer)(OrtPrepackedWeightsContainer *)
     * }
     */
    private static class ReleasePrepackedWeightsContainer {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ReleasePrepackedWeightsContainer$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ReleasePrepackedWeightsContainer"));

    private static final long ReleasePrepackedWeightsContainer$OFFSET = $LAYOUT.byteOffset(groupElement("ReleasePrepackedWeightsContainer"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * void (*ReleasePrepackedWeightsContainer)(OrtPrepackedWeightsContainer *)
     * }
     */
    public static void ReleasePrepackedWeightsContainer(MemorySegment struct, MemorySegment _x0) {
        var funcPtr = struct.get(ReleasePrepackedWeightsContainer$LAYOUT, ReleasePrepackedWeightsContainer$OFFSET);
        ReleasePrepackedWeightsContainer.invoke(funcPtr, _x0);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSessionWithPrepackedWeightsContainer)(const OrtEnv *, const char *, const OrtSessionOptions *, OrtPrepackedWeightsContainer *, OrtSession **)
     * }
     */
    private static class CreateSessionWithPrepackedWeightsContainer {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CreateSessionWithPrepackedWeightsContainer$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CreateSessionWithPrepackedWeightsContainer"));

    private static final long CreateSessionWithPrepackedWeightsContainer$OFFSET = $LAYOUT.byteOffset(groupElement("CreateSessionWithPrepackedWeightsContainer"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSessionWithPrepackedWeightsContainer)(const OrtEnv *, const char *, const OrtSessionOptions *, OrtPrepackedWeightsContainer *, OrtSession **)
     * }
     */
    public static MemorySegment CreateSessionWithPrepackedWeightsContainer(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4) {
        var funcPtr = struct.get(CreateSessionWithPrepackedWeightsContainer$LAYOUT, CreateSessionWithPrepackedWeightsContainer$OFFSET);
        return CreateSessionWithPrepackedWeightsContainer.invoke(funcPtr, _x0, _x1, _x2, _x3, _x4);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSessionFromArrayWithPrepackedWeightsContainer)(const OrtEnv *, const void *, size_t, const OrtSessionOptions *, OrtPrepackedWeightsContainer *, OrtSession **)
     * }
     */
    private static class CreateSessionFromArrayWithPrepackedWeightsContainer {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3, MemorySegment _x4, MemorySegment _x5) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CreateSessionFromArrayWithPrepackedWeightsContainer$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CreateSessionFromArrayWithPrepackedWeightsContainer"));

    private static final long CreateSessionFromArrayWithPrepackedWeightsContainer$OFFSET = $LAYOUT.byteOffset(groupElement("CreateSessionFromArrayWithPrepackedWeightsContainer"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSessionFromArrayWithPrepackedWeightsContainer)(const OrtEnv *, const void *, size_t, const OrtSessionOptions *, OrtPrepackedWeightsContainer *, OrtSession **)
     * }
     */
    public static MemorySegment CreateSessionFromArrayWithPrepackedWeightsContainer(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3, MemorySegment _x4, MemorySegment _x5) {
        var funcPtr = struct.get(CreateSessionFromArrayWithPrepackedWeightsContainer$LAYOUT, CreateSessionFromArrayWithPrepackedWeightsContainer$OFFSET);
        return CreateSessionFromArrayWithPrepackedWeightsContainer.invoke(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_TensorRT_V2)(OrtSessionOptions *, const OrtTensorRTProviderOptionsV2 *)
     * }
     */
    private static class SessionOptionsAppendExecutionProvider_TensorRT_V2 {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SessionOptionsAppendExecutionProvider_TensorRT_V2$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SessionOptionsAppendExecutionProvider_TensorRT_V2"));

    private static final long SessionOptionsAppendExecutionProvider_TensorRT_V2$OFFSET = $LAYOUT.byteOffset(groupElement("SessionOptionsAppendExecutionProvider_TensorRT_V2"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_TensorRT_V2)(OrtSessionOptions *, const OrtTensorRTProviderOptionsV2 *)
     * }
     */
    public static MemorySegment SessionOptionsAppendExecutionProvider_TensorRT_V2(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {
        var funcPtr = struct.get(SessionOptionsAppendExecutionProvider_TensorRT_V2$LAYOUT, SessionOptionsAppendExecutionProvider_TensorRT_V2$OFFSET);
        return SessionOptionsAppendExecutionProvider_TensorRT_V2.invoke(funcPtr, _x0, _x1);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateTensorRTProviderOptions)(OrtTensorRTProviderOptionsV2 **)
     * }
     */
    private static class CreateTensorRTProviderOptions {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CreateTensorRTProviderOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CreateTensorRTProviderOptions"));

    private static final long CreateTensorRTProviderOptions$OFFSET = $LAYOUT.byteOffset(groupElement("CreateTensorRTProviderOptions"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateTensorRTProviderOptions)(OrtTensorRTProviderOptionsV2 **)
     * }
     */
    public static MemorySegment CreateTensorRTProviderOptions(MemorySegment struct, MemorySegment _x0) {
        var funcPtr = struct.get(CreateTensorRTProviderOptions$LAYOUT, CreateTensorRTProviderOptions$OFFSET);
        return CreateTensorRTProviderOptions.invoke(funcPtr, _x0);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*UpdateTensorRTProviderOptions)(OrtTensorRTProviderOptionsV2 *, const char *const *, const char *const *, size_t)
     * }
     */
    private static class UpdateTensorRTProviderOptions {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout UpdateTensorRTProviderOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("UpdateTensorRTProviderOptions"));

    private static final long UpdateTensorRTProviderOptions$OFFSET = $LAYOUT.byteOffset(groupElement("UpdateTensorRTProviderOptions"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UpdateTensorRTProviderOptions)(OrtTensorRTProviderOptionsV2 *, const char *const *, const char *const *, size_t)
     * }
     */
    public static MemorySegment UpdateTensorRTProviderOptions(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3) {
        var funcPtr = struct.get(UpdateTensorRTProviderOptions$LAYOUT, UpdateTensorRTProviderOptions$OFFSET);
        return UpdateTensorRTProviderOptions.invoke(funcPtr, _x0, _x1, _x2, _x3);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTensorRTProviderOptionsAsString)(const OrtTensorRTProviderOptionsV2 *, OrtAllocator *, char **)
     * }
     */
    private static class GetTensorRTProviderOptionsAsString {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetTensorRTProviderOptionsAsString$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetTensorRTProviderOptionsAsString"));

    private static final long GetTensorRTProviderOptionsAsString$OFFSET = $LAYOUT.byteOffset(groupElement("GetTensorRTProviderOptionsAsString"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTensorRTProviderOptionsAsString)(const OrtTensorRTProviderOptionsV2 *, OrtAllocator *, char **)
     * }
     */
    public static MemorySegment GetTensorRTProviderOptionsAsString(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
        var funcPtr = struct.get(GetTensorRTProviderOptionsAsString$LAYOUT, GetTensorRTProviderOptionsAsString$OFFSET);
        return GetTensorRTProviderOptionsAsString.invoke(funcPtr, _x0, _x1, _x2);
    }

    /**
     * {@snippet lang=c :
     * void (*ReleaseTensorRTProviderOptions)(OrtTensorRTProviderOptionsV2 *)
     * }
     */
    private static class ReleaseTensorRTProviderOptions {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ReleaseTensorRTProviderOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ReleaseTensorRTProviderOptions"));

    private static final long ReleaseTensorRTProviderOptions$OFFSET = $LAYOUT.byteOffset(groupElement("ReleaseTensorRTProviderOptions"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * void (*ReleaseTensorRTProviderOptions)(OrtTensorRTProviderOptionsV2 *)
     * }
     */
    public static void ReleaseTensorRTProviderOptions(MemorySegment struct, MemorySegment _x0) {
        var funcPtr = struct.get(ReleaseTensorRTProviderOptions$LAYOUT, ReleaseTensorRTProviderOptions$OFFSET);
        ReleaseTensorRTProviderOptions.invoke(funcPtr, _x0);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*EnableOrtCustomOps)(OrtSessionOptions *)
     * }
     */
    private static class EnableOrtCustomOps {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout EnableOrtCustomOps$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("EnableOrtCustomOps"));

    private static final long EnableOrtCustomOps$OFFSET = $LAYOUT.byteOffset(groupElement("EnableOrtCustomOps"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*EnableOrtCustomOps)(OrtSessionOptions *)
     * }
     */
    public static MemorySegment EnableOrtCustomOps(MemorySegment struct, MemorySegment _x0) {
        var funcPtr = struct.get(EnableOrtCustomOps$LAYOUT, EnableOrtCustomOps$OFFSET);
        return EnableOrtCustomOps.invoke(funcPtr, _x0);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*RegisterAllocator)(OrtEnv *, OrtAllocator *)
     * }
     */
    private static class RegisterAllocator {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout RegisterAllocator$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("RegisterAllocator"));

    private static final long RegisterAllocator$OFFSET = $LAYOUT.byteOffset(groupElement("RegisterAllocator"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RegisterAllocator)(OrtEnv *, OrtAllocator *)
     * }
     */
    public static MemorySegment RegisterAllocator(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {
        var funcPtr = struct.get(RegisterAllocator$LAYOUT, RegisterAllocator$OFFSET);
        return RegisterAllocator.invoke(funcPtr, _x0, _x1);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*UnregisterAllocator)(OrtEnv *, const OrtMemoryInfo *)
     * }
     */
    private static class UnregisterAllocator {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout UnregisterAllocator$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("UnregisterAllocator"));

    private static final long UnregisterAllocator$OFFSET = $LAYOUT.byteOffset(groupElement("UnregisterAllocator"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UnregisterAllocator)(OrtEnv *, const OrtMemoryInfo *)
     * }
     */
    public static MemorySegment UnregisterAllocator(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {
        var funcPtr = struct.get(UnregisterAllocator$LAYOUT, UnregisterAllocator$OFFSET);
        return UnregisterAllocator.invoke(funcPtr, _x0, _x1);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*IsSparseTensor)(const OrtValue *, int *)
     * }
     */
    private static class IsSparseTensor {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout IsSparseTensor$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("IsSparseTensor"));

    private static final long IsSparseTensor$OFFSET = $LAYOUT.byteOffset(groupElement("IsSparseTensor"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*IsSparseTensor)(const OrtValue *, int *)
     * }
     */
    public static MemorySegment IsSparseTensor(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {
        var funcPtr = struct.get(IsSparseTensor$LAYOUT, IsSparseTensor$OFFSET);
        return IsSparseTensor.invoke(funcPtr, _x0, _x1);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSparseTensorAsOrtValue)(OrtAllocator *, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **)
     * }
     */
    private static class CreateSparseTensorAsOrtValue {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_INT,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2, int _x3, MemorySegment _x4) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CreateSparseTensorAsOrtValue$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CreateSparseTensorAsOrtValue"));

    private static final long CreateSparseTensorAsOrtValue$OFFSET = $LAYOUT.byteOffset(groupElement("CreateSparseTensorAsOrtValue"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSparseTensorAsOrtValue)(OrtAllocator *, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **)
     * }
     */
    public static MemorySegment CreateSparseTensorAsOrtValue(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, long _x2, int _x3, MemorySegment _x4) {
        var funcPtr = struct.get(CreateSparseTensorAsOrtValue$LAYOUT, CreateSparseTensorAsOrtValue$OFFSET);
        return CreateSparseTensorAsOrtValue.invoke(funcPtr, _x0, _x1, _x2, _x3, _x4);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*FillSparseTensorCoo)(OrtValue *, const OrtMemoryInfo *, const int64_t *, size_t, const void *, const int64_t *, size_t)
     * }
     */
    private static class FillSparseTensorCoo {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3, MemorySegment _x4, MemorySegment _x5, long _x6) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout FillSparseTensorCoo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("FillSparseTensorCoo"));

    private static final long FillSparseTensorCoo$OFFSET = $LAYOUT.byteOffset(groupElement("FillSparseTensorCoo"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*FillSparseTensorCoo)(OrtValue *, const OrtMemoryInfo *, const int64_t *, size_t, const void *, const int64_t *, size_t)
     * }
     */
    public static MemorySegment FillSparseTensorCoo(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3, MemorySegment _x4, MemorySegment _x5, long _x6) {
        var funcPtr = struct.get(FillSparseTensorCoo$LAYOUT, FillSparseTensorCoo$OFFSET);
        return FillSparseTensorCoo.invoke(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*FillSparseTensorCsr)(OrtValue *, const OrtMemoryInfo *, const int64_t *, size_t, const void *, const int64_t *, size_t, const int64_t *, size_t)
     * }
     */
    private static class FillSparseTensorCsr {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3, MemorySegment _x4, MemorySegment _x5, long _x6, MemorySegment _x7, long _x8) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6, _x7, _x8);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout FillSparseTensorCsr$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("FillSparseTensorCsr"));

    private static final long FillSparseTensorCsr$OFFSET = $LAYOUT.byteOffset(groupElement("FillSparseTensorCsr"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*FillSparseTensorCsr)(OrtValue *, const OrtMemoryInfo *, const int64_t *, size_t, const void *, const int64_t *, size_t, const int64_t *, size_t)
     * }
     */
    public static MemorySegment FillSparseTensorCsr(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3, MemorySegment _x4, MemorySegment _x5, long _x6, MemorySegment _x7, long _x8) {
        var funcPtr = struct.get(FillSparseTensorCsr$LAYOUT, FillSparseTensorCsr$OFFSET);
        return FillSparseTensorCsr.invoke(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6, _x7, _x8);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*FillSparseTensorBlockSparse)(OrtValue *, const OrtMemoryInfo *, const int64_t *, size_t, const void *, const int64_t *, size_t, const int32_t *)
     * }
     */
    private static class FillSparseTensorBlockSparse {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3, MemorySegment _x4, MemorySegment _x5, long _x6, MemorySegment _x7) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6, _x7);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout FillSparseTensorBlockSparse$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("FillSparseTensorBlockSparse"));

    private static final long FillSparseTensorBlockSparse$OFFSET = $LAYOUT.byteOffset(groupElement("FillSparseTensorBlockSparse"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*FillSparseTensorBlockSparse)(OrtValue *, const OrtMemoryInfo *, const int64_t *, size_t, const void *, const int64_t *, size_t, const int32_t *)
     * }
     */
    public static MemorySegment FillSparseTensorBlockSparse(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3, MemorySegment _x4, MemorySegment _x5, long _x6, MemorySegment _x7) {
        var funcPtr = struct.get(FillSparseTensorBlockSparse$LAYOUT, FillSparseTensorBlockSparse$OFFSET);
        return FillSparseTensorBlockSparse.invoke(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6, _x7);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSparseTensorWithValuesAsOrtValue)(const OrtMemoryInfo *, void *, const int64_t *, size_t, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **)
     * }
     */
    private static class CreateSparseTensorWithValuesAsOrtValue {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_INT,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3, MemorySegment _x4, long _x5, int _x6, MemorySegment _x7) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6, _x7);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CreateSparseTensorWithValuesAsOrtValue$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CreateSparseTensorWithValuesAsOrtValue"));

    private static final long CreateSparseTensorWithValuesAsOrtValue$OFFSET = $LAYOUT.byteOffset(groupElement("CreateSparseTensorWithValuesAsOrtValue"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSparseTensorWithValuesAsOrtValue)(const OrtMemoryInfo *, void *, const int64_t *, size_t, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **)
     * }
     */
    public static MemorySegment CreateSparseTensorWithValuesAsOrtValue(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3, MemorySegment _x4, long _x5, int _x6, MemorySegment _x7) {
        var funcPtr = struct.get(CreateSparseTensorWithValuesAsOrtValue$LAYOUT, CreateSparseTensorWithValuesAsOrtValue$OFFSET);
        return CreateSparseTensorWithValuesAsOrtValue.invoke(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6, _x7);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*UseCooIndices)(OrtValue *, int64_t *, size_t)
     * }
     */
    private static class UseCooIndices {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout UseCooIndices$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("UseCooIndices"));

    private static final long UseCooIndices$OFFSET = $LAYOUT.byteOffset(groupElement("UseCooIndices"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UseCooIndices)(OrtValue *, int64_t *, size_t)
     * }
     */
    public static MemorySegment UseCooIndices(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, long _x2) {
        var funcPtr = struct.get(UseCooIndices$LAYOUT, UseCooIndices$OFFSET);
        return UseCooIndices.invoke(funcPtr, _x0, _x1, _x2);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*UseCsrIndices)(OrtValue *, int64_t *, size_t, int64_t *, size_t)
     * }
     */
    private static class UseCsrIndices {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3, long _x4) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout UseCsrIndices$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("UseCsrIndices"));

    private static final long UseCsrIndices$OFFSET = $LAYOUT.byteOffset(groupElement("UseCsrIndices"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UseCsrIndices)(OrtValue *, int64_t *, size_t, int64_t *, size_t)
     * }
     */
    public static MemorySegment UseCsrIndices(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3, long _x4) {
        var funcPtr = struct.get(UseCsrIndices$LAYOUT, UseCsrIndices$OFFSET);
        return UseCsrIndices.invoke(funcPtr, _x0, _x1, _x2, _x3, _x4);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*UseBlockSparseIndices)(OrtValue *, const int64_t *, size_t, int32_t *)
     * }
     */
    private static class UseBlockSparseIndices {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout UseBlockSparseIndices$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("UseBlockSparseIndices"));

    private static final long UseBlockSparseIndices$OFFSET = $LAYOUT.byteOffset(groupElement("UseBlockSparseIndices"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UseBlockSparseIndices)(OrtValue *, const int64_t *, size_t, int32_t *)
     * }
     */
    public static MemorySegment UseBlockSparseIndices(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3) {
        var funcPtr = struct.get(UseBlockSparseIndices$LAYOUT, UseBlockSparseIndices$OFFSET);
        return UseBlockSparseIndices.invoke(funcPtr, _x0, _x1, _x2, _x3);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSparseTensorFormat)(const OrtValue *, enum OrtSparseFormat *)
     * }
     */
    private static class GetSparseTensorFormat {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetSparseTensorFormat$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetSparseTensorFormat"));

    private static final long GetSparseTensorFormat$OFFSET = $LAYOUT.byteOffset(groupElement("GetSparseTensorFormat"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSparseTensorFormat)(const OrtValue *, enum OrtSparseFormat *)
     * }
     */
    public static MemorySegment GetSparseTensorFormat(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {
        var funcPtr = struct.get(GetSparseTensorFormat$LAYOUT, GetSparseTensorFormat$OFFSET);
        return GetSparseTensorFormat.invoke(funcPtr, _x0, _x1);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSparseTensorValuesTypeAndShape)(const OrtValue *, OrtTensorTypeAndShapeInfo **)
     * }
     */
    private static class GetSparseTensorValuesTypeAndShape {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetSparseTensorValuesTypeAndShape$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetSparseTensorValuesTypeAndShape"));

    private static final long GetSparseTensorValuesTypeAndShape$OFFSET = $LAYOUT.byteOffset(groupElement("GetSparseTensorValuesTypeAndShape"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSparseTensorValuesTypeAndShape)(const OrtValue *, OrtTensorTypeAndShapeInfo **)
     * }
     */
    public static MemorySegment GetSparseTensorValuesTypeAndShape(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {
        var funcPtr = struct.get(GetSparseTensorValuesTypeAndShape$LAYOUT, GetSparseTensorValuesTypeAndShape$OFFSET);
        return GetSparseTensorValuesTypeAndShape.invoke(funcPtr, _x0, _x1);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSparseTensorValues)(const OrtValue *, const void **)
     * }
     */
    private static class GetSparseTensorValues {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetSparseTensorValues$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetSparseTensorValues"));

    private static final long GetSparseTensorValues$OFFSET = $LAYOUT.byteOffset(groupElement("GetSparseTensorValues"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSparseTensorValues)(const OrtValue *, const void **)
     * }
     */
    public static MemorySegment GetSparseTensorValues(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {
        var funcPtr = struct.get(GetSparseTensorValues$LAYOUT, GetSparseTensorValues$OFFSET);
        return GetSparseTensorValues.invoke(funcPtr, _x0, _x1);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSparseTensorIndicesTypeShape)(const OrtValue *, enum OrtSparseIndicesFormat, OrtTensorTypeAndShapeInfo **)
     * }
     */
    private static class GetSparseTensorIndicesTypeShape {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_INT,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetSparseTensorIndicesTypeShape$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetSparseTensorIndicesTypeShape"));

    private static final long GetSparseTensorIndicesTypeShape$OFFSET = $LAYOUT.byteOffset(groupElement("GetSparseTensorIndicesTypeShape"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSparseTensorIndicesTypeShape)(const OrtValue *, enum OrtSparseIndicesFormat, OrtTensorTypeAndShapeInfo **)
     * }
     */
    public static MemorySegment GetSparseTensorIndicesTypeShape(MemorySegment struct, MemorySegment _x0, int _x1, MemorySegment _x2) {
        var funcPtr = struct.get(GetSparseTensorIndicesTypeShape$LAYOUT, GetSparseTensorIndicesTypeShape$OFFSET);
        return GetSparseTensorIndicesTypeShape.invoke(funcPtr, _x0, _x1, _x2);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSparseTensorIndices)(const OrtValue *, enum OrtSparseIndicesFormat, size_t *, const void **)
     * }
     */
    private static class GetSparseTensorIndices {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_INT,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetSparseTensorIndices$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetSparseTensorIndices"));

    private static final long GetSparseTensorIndices$OFFSET = $LAYOUT.byteOffset(groupElement("GetSparseTensorIndices"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSparseTensorIndices)(const OrtValue *, enum OrtSparseIndicesFormat, size_t *, const void **)
     * }
     */
    public static MemorySegment GetSparseTensorIndices(MemorySegment struct, MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3) {
        var funcPtr = struct.get(GetSparseTensorIndices$LAYOUT, GetSparseTensorIndices$OFFSET);
        return GetSparseTensorIndices.invoke(funcPtr, _x0, _x1, _x2, _x3);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*HasValue)(const OrtValue *, int *)
     * }
     */
    private static class HasValue {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout HasValue$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("HasValue"));

    private static final long HasValue$OFFSET = $LAYOUT.byteOffset(groupElement("HasValue"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*HasValue)(const OrtValue *, int *)
     * }
     */
    public static MemorySegment HasValue(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {
        var funcPtr = struct.get(HasValue$LAYOUT, HasValue$OFFSET);
        return HasValue.invoke(funcPtr, _x0, _x1);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetGPUComputeStream)(const OrtKernelContext *, void **)
     * }
     */
    private static class KernelContext_GetGPUComputeStream {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout KernelContext_GetGPUComputeStream$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("KernelContext_GetGPUComputeStream"));

    private static final long KernelContext_GetGPUComputeStream$OFFSET = $LAYOUT.byteOffset(groupElement("KernelContext_GetGPUComputeStream"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetGPUComputeStream)(const OrtKernelContext *, void **)
     * }
     */
    public static MemorySegment KernelContext_GetGPUComputeStream(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {
        var funcPtr = struct.get(KernelContext_GetGPUComputeStream$LAYOUT, KernelContext_GetGPUComputeStream$OFFSET);
        return KernelContext_GetGPUComputeStream.invoke(funcPtr, _x0, _x1);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTensorMemoryInfo)(const OrtValue *, const OrtMemoryInfo **)
     * }
     */
    private static class GetTensorMemoryInfo {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetTensorMemoryInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetTensorMemoryInfo"));

    private static final long GetTensorMemoryInfo$OFFSET = $LAYOUT.byteOffset(groupElement("GetTensorMemoryInfo"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTensorMemoryInfo)(const OrtValue *, const OrtMemoryInfo **)
     * }
     */
    public static MemorySegment GetTensorMemoryInfo(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {
        var funcPtr = struct.get(GetTensorMemoryInfo$LAYOUT, GetTensorMemoryInfo$OFFSET);
        return GetTensorMemoryInfo.invoke(funcPtr, _x0, _x1);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetExecutionProviderApi)(const char *, uint32_t, const void **)
     * }
     */
    private static class GetExecutionProviderApi {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_INT,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetExecutionProviderApi$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetExecutionProviderApi"));

    private static final long GetExecutionProviderApi$OFFSET = $LAYOUT.byteOffset(groupElement("GetExecutionProviderApi"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetExecutionProviderApi)(const char *, uint32_t, const void **)
     * }
     */
    public static MemorySegment GetExecutionProviderApi(MemorySegment struct, MemorySegment _x0, int _x1, MemorySegment _x2) {
        var funcPtr = struct.get(GetExecutionProviderApi$LAYOUT, GetExecutionProviderApi$OFFSET);
        return GetExecutionProviderApi.invoke(funcPtr, _x0, _x1, _x2);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsSetCustomCreateThreadFn)(OrtSessionOptions *, OrtCustomCreateThreadFn)
     * }
     */
    private static class SessionOptionsSetCustomCreateThreadFn {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SessionOptionsSetCustomCreateThreadFn$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SessionOptionsSetCustomCreateThreadFn"));

    private static final long SessionOptionsSetCustomCreateThreadFn$OFFSET = $LAYOUT.byteOffset(groupElement("SessionOptionsSetCustomCreateThreadFn"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsSetCustomCreateThreadFn)(OrtSessionOptions *, OrtCustomCreateThreadFn)
     * }
     */
    public static MemorySegment SessionOptionsSetCustomCreateThreadFn(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {
        var funcPtr = struct.get(SessionOptionsSetCustomCreateThreadFn$LAYOUT, SessionOptionsSetCustomCreateThreadFn$OFFSET);
        return SessionOptionsSetCustomCreateThreadFn.invoke(funcPtr, _x0, _x1);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsSetCustomThreadCreationOptions)(OrtSessionOptions *, void *)
     * }
     */
    private static class SessionOptionsSetCustomThreadCreationOptions {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SessionOptionsSetCustomThreadCreationOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SessionOptionsSetCustomThreadCreationOptions"));

    private static final long SessionOptionsSetCustomThreadCreationOptions$OFFSET = $LAYOUT.byteOffset(groupElement("SessionOptionsSetCustomThreadCreationOptions"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsSetCustomThreadCreationOptions)(OrtSessionOptions *, void *)
     * }
     */
    public static MemorySegment SessionOptionsSetCustomThreadCreationOptions(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {
        var funcPtr = struct.get(SessionOptionsSetCustomThreadCreationOptions$LAYOUT, SessionOptionsSetCustomThreadCreationOptions$OFFSET);
        return SessionOptionsSetCustomThreadCreationOptions.invoke(funcPtr, _x0, _x1);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsSetCustomJoinThreadFn)(OrtSessionOptions *, OrtCustomJoinThreadFn)
     * }
     */
    private static class SessionOptionsSetCustomJoinThreadFn {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SessionOptionsSetCustomJoinThreadFn$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SessionOptionsSetCustomJoinThreadFn"));

    private static final long SessionOptionsSetCustomJoinThreadFn$OFFSET = $LAYOUT.byteOffset(groupElement("SessionOptionsSetCustomJoinThreadFn"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsSetCustomJoinThreadFn)(OrtSessionOptions *, OrtCustomJoinThreadFn)
     * }
     */
    public static MemorySegment SessionOptionsSetCustomJoinThreadFn(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {
        var funcPtr = struct.get(SessionOptionsSetCustomJoinThreadFn$LAYOUT, SessionOptionsSetCustomJoinThreadFn$OFFSET);
        return SessionOptionsSetCustomJoinThreadFn.invoke(funcPtr, _x0, _x1);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGlobalCustomCreateThreadFn)(OrtThreadingOptions *, OrtCustomCreateThreadFn)
     * }
     */
    private static class SetGlobalCustomCreateThreadFn {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SetGlobalCustomCreateThreadFn$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SetGlobalCustomCreateThreadFn"));

    private static final long SetGlobalCustomCreateThreadFn$OFFSET = $LAYOUT.byteOffset(groupElement("SetGlobalCustomCreateThreadFn"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGlobalCustomCreateThreadFn)(OrtThreadingOptions *, OrtCustomCreateThreadFn)
     * }
     */
    public static MemorySegment SetGlobalCustomCreateThreadFn(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {
        var funcPtr = struct.get(SetGlobalCustomCreateThreadFn$LAYOUT, SetGlobalCustomCreateThreadFn$OFFSET);
        return SetGlobalCustomCreateThreadFn.invoke(funcPtr, _x0, _x1);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGlobalCustomThreadCreationOptions)(OrtThreadingOptions *, void *)
     * }
     */
    private static class SetGlobalCustomThreadCreationOptions {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SetGlobalCustomThreadCreationOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SetGlobalCustomThreadCreationOptions"));

    private static final long SetGlobalCustomThreadCreationOptions$OFFSET = $LAYOUT.byteOffset(groupElement("SetGlobalCustomThreadCreationOptions"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGlobalCustomThreadCreationOptions)(OrtThreadingOptions *, void *)
     * }
     */
    public static MemorySegment SetGlobalCustomThreadCreationOptions(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {
        var funcPtr = struct.get(SetGlobalCustomThreadCreationOptions$LAYOUT, SetGlobalCustomThreadCreationOptions$OFFSET);
        return SetGlobalCustomThreadCreationOptions.invoke(funcPtr, _x0, _x1);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGlobalCustomJoinThreadFn)(OrtThreadingOptions *, OrtCustomJoinThreadFn)
     * }
     */
    private static class SetGlobalCustomJoinThreadFn {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SetGlobalCustomJoinThreadFn$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SetGlobalCustomJoinThreadFn"));

    private static final long SetGlobalCustomJoinThreadFn$OFFSET = $LAYOUT.byteOffset(groupElement("SetGlobalCustomJoinThreadFn"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGlobalCustomJoinThreadFn)(OrtThreadingOptions *, OrtCustomJoinThreadFn)
     * }
     */
    public static MemorySegment SetGlobalCustomJoinThreadFn(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {
        var funcPtr = struct.get(SetGlobalCustomJoinThreadFn$LAYOUT, SetGlobalCustomJoinThreadFn$OFFSET);
        return SetGlobalCustomJoinThreadFn.invoke(funcPtr, _x0, _x1);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SynchronizeBoundInputs)(OrtIoBinding *)
     * }
     */
    private static class SynchronizeBoundInputs {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SynchronizeBoundInputs$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SynchronizeBoundInputs"));

    private static final long SynchronizeBoundInputs$OFFSET = $LAYOUT.byteOffset(groupElement("SynchronizeBoundInputs"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SynchronizeBoundInputs)(OrtIoBinding *)
     * }
     */
    public static MemorySegment SynchronizeBoundInputs(MemorySegment struct, MemorySegment _x0) {
        var funcPtr = struct.get(SynchronizeBoundInputs$LAYOUT, SynchronizeBoundInputs$OFFSET);
        return SynchronizeBoundInputs.invoke(funcPtr, _x0);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SynchronizeBoundOutputs)(OrtIoBinding *)
     * }
     */
    private static class SynchronizeBoundOutputs {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SynchronizeBoundOutputs$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SynchronizeBoundOutputs"));

    private static final long SynchronizeBoundOutputs$OFFSET = $LAYOUT.byteOffset(groupElement("SynchronizeBoundOutputs"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SynchronizeBoundOutputs)(OrtIoBinding *)
     * }
     */
    public static MemorySegment SynchronizeBoundOutputs(MemorySegment struct, MemorySegment _x0) {
        var funcPtr = struct.get(SynchronizeBoundOutputs$LAYOUT, SynchronizeBoundOutputs$OFFSET);
        return SynchronizeBoundOutputs.invoke(funcPtr, _x0);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_CUDA_V2)(OrtSessionOptions *, const OrtCUDAProviderOptionsV2 *)
     * }
     */
    private static class SessionOptionsAppendExecutionProvider_CUDA_V2 {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SessionOptionsAppendExecutionProvider_CUDA_V2$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SessionOptionsAppendExecutionProvider_CUDA_V2"));

    private static final long SessionOptionsAppendExecutionProvider_CUDA_V2$OFFSET = $LAYOUT.byteOffset(groupElement("SessionOptionsAppendExecutionProvider_CUDA_V2"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_CUDA_V2)(OrtSessionOptions *, const OrtCUDAProviderOptionsV2 *)
     * }
     */
    public static MemorySegment SessionOptionsAppendExecutionProvider_CUDA_V2(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {
        var funcPtr = struct.get(SessionOptionsAppendExecutionProvider_CUDA_V2$LAYOUT, SessionOptionsAppendExecutionProvider_CUDA_V2$OFFSET);
        return SessionOptionsAppendExecutionProvider_CUDA_V2.invoke(funcPtr, _x0, _x1);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateCUDAProviderOptions)(OrtCUDAProviderOptionsV2 **)
     * }
     */
    private static class CreateCUDAProviderOptions {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CreateCUDAProviderOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CreateCUDAProviderOptions"));

    private static final long CreateCUDAProviderOptions$OFFSET = $LAYOUT.byteOffset(groupElement("CreateCUDAProviderOptions"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateCUDAProviderOptions)(OrtCUDAProviderOptionsV2 **)
     * }
     */
    public static MemorySegment CreateCUDAProviderOptions(MemorySegment struct, MemorySegment _x0) {
        var funcPtr = struct.get(CreateCUDAProviderOptions$LAYOUT, CreateCUDAProviderOptions$OFFSET);
        return CreateCUDAProviderOptions.invoke(funcPtr, _x0);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*UpdateCUDAProviderOptions)(OrtCUDAProviderOptionsV2 *, const char *const *, const char *const *, size_t)
     * }
     */
    private static class UpdateCUDAProviderOptions {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout UpdateCUDAProviderOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("UpdateCUDAProviderOptions"));

    private static final long UpdateCUDAProviderOptions$OFFSET = $LAYOUT.byteOffset(groupElement("UpdateCUDAProviderOptions"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UpdateCUDAProviderOptions)(OrtCUDAProviderOptionsV2 *, const char *const *, const char *const *, size_t)
     * }
     */
    public static MemorySegment UpdateCUDAProviderOptions(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3) {
        var funcPtr = struct.get(UpdateCUDAProviderOptions$LAYOUT, UpdateCUDAProviderOptions$OFFSET);
        return UpdateCUDAProviderOptions.invoke(funcPtr, _x0, _x1, _x2, _x3);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetCUDAProviderOptionsAsString)(const OrtCUDAProviderOptionsV2 *, OrtAllocator *, char **)
     * }
     */
    private static class GetCUDAProviderOptionsAsString {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetCUDAProviderOptionsAsString$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetCUDAProviderOptionsAsString"));

    private static final long GetCUDAProviderOptionsAsString$OFFSET = $LAYOUT.byteOffset(groupElement("GetCUDAProviderOptionsAsString"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetCUDAProviderOptionsAsString)(const OrtCUDAProviderOptionsV2 *, OrtAllocator *, char **)
     * }
     */
    public static MemorySegment GetCUDAProviderOptionsAsString(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
        var funcPtr = struct.get(GetCUDAProviderOptionsAsString$LAYOUT, GetCUDAProviderOptionsAsString$OFFSET);
        return GetCUDAProviderOptionsAsString.invoke(funcPtr, _x0, _x1, _x2);
    }

    /**
     * {@snippet lang=c :
     * void (*ReleaseCUDAProviderOptions)(OrtCUDAProviderOptionsV2 *)
     * }
     */
    private static class ReleaseCUDAProviderOptions {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ReleaseCUDAProviderOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ReleaseCUDAProviderOptions"));

    private static final long ReleaseCUDAProviderOptions$OFFSET = $LAYOUT.byteOffset(groupElement("ReleaseCUDAProviderOptions"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * void (*ReleaseCUDAProviderOptions)(OrtCUDAProviderOptionsV2 *)
     * }
     */
    public static void ReleaseCUDAProviderOptions(MemorySegment struct, MemorySegment _x0) {
        var funcPtr = struct.get(ReleaseCUDAProviderOptions$LAYOUT, ReleaseCUDAProviderOptions$OFFSET);
        ReleaseCUDAProviderOptions.invoke(funcPtr, _x0);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_MIGraphX)(OrtSessionOptions *, const OrtMIGraphXProviderOptions *)
     * }
     */
    private static class SessionOptionsAppendExecutionProvider_MIGraphX {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SessionOptionsAppendExecutionProvider_MIGraphX$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SessionOptionsAppendExecutionProvider_MIGraphX"));

    private static final long SessionOptionsAppendExecutionProvider_MIGraphX$OFFSET = $LAYOUT.byteOffset(groupElement("SessionOptionsAppendExecutionProvider_MIGraphX"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_MIGraphX)(OrtSessionOptions *, const OrtMIGraphXProviderOptions *)
     * }
     */
    public static MemorySegment SessionOptionsAppendExecutionProvider_MIGraphX(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {
        var funcPtr = struct.get(SessionOptionsAppendExecutionProvider_MIGraphX$LAYOUT, SessionOptionsAppendExecutionProvider_MIGraphX$OFFSET);
        return SessionOptionsAppendExecutionProvider_MIGraphX.invoke(funcPtr, _x0, _x1);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*AddExternalInitializers)(OrtSessionOptions *, const char *const *, const OrtValue *const *, size_t)
     * }
     */
    private static class AddExternalInitializers {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout AddExternalInitializers$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("AddExternalInitializers"));

    private static final long AddExternalInitializers$OFFSET = $LAYOUT.byteOffset(groupElement("AddExternalInitializers"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AddExternalInitializers)(OrtSessionOptions *, const char *const *, const OrtValue *const *, size_t)
     * }
     */
    public static MemorySegment AddExternalInitializers(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3) {
        var funcPtr = struct.get(AddExternalInitializers$LAYOUT, AddExternalInitializers$OFFSET);
        return AddExternalInitializers.invoke(funcPtr, _x0, _x1, _x2, _x3);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateOpAttr)(const char *, const void *, int, OrtOpAttrType, OrtOpAttr **)
     * }
     */
    private static class CreateOpAttr {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_INT,
            onnxruntime_c_api_h.C_INT,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, int _x2, int _x3, MemorySegment _x4) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CreateOpAttr$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CreateOpAttr"));

    private static final long CreateOpAttr$OFFSET = $LAYOUT.byteOffset(groupElement("CreateOpAttr"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateOpAttr)(const char *, const void *, int, OrtOpAttrType, OrtOpAttr **)
     * }
     */
    public static MemorySegment CreateOpAttr(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, int _x2, int _x3, MemorySegment _x4) {
        var funcPtr = struct.get(CreateOpAttr$LAYOUT, CreateOpAttr$OFFSET);
        return CreateOpAttr.invoke(funcPtr, _x0, _x1, _x2, _x3, _x4);
    }

    /**
     * {@snippet lang=c :
     * void (*ReleaseOpAttr)(OrtOpAttr *)
     * }
     */
    private static class ReleaseOpAttr {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ReleaseOpAttr$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ReleaseOpAttr"));

    private static final long ReleaseOpAttr$OFFSET = $LAYOUT.byteOffset(groupElement("ReleaseOpAttr"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * void (*ReleaseOpAttr)(OrtOpAttr *)
     * }
     */
    public static void ReleaseOpAttr(MemorySegment struct, MemorySegment _x0) {
        var funcPtr = struct.get(ReleaseOpAttr$LAYOUT, ReleaseOpAttr$OFFSET);
        ReleaseOpAttr.invoke(funcPtr, _x0);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateOp)(const OrtKernelInfo *, const char *, const char *, int, const char **, const ONNXTensorElementDataType *, int, const OrtOpAttr *const *, int, int, int, OrtOp **)
     * }
     */
    private static class CreateOp {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_INT,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_INT,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_INT,
            onnxruntime_c_api_h.C_INT,
            onnxruntime_c_api_h.C_INT,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, int _x3, MemorySegment _x4, MemorySegment _x5, int _x6, MemorySegment _x7, int _x8, int _x9, int _x10, MemorySegment _x11) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6, _x7, _x8, _x9, _x10, _x11);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CreateOp$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CreateOp"));

    private static final long CreateOp$OFFSET = $LAYOUT.byteOffset(groupElement("CreateOp"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateOp)(const OrtKernelInfo *, const char *, const char *, int, const char **, const ONNXTensorElementDataType *, int, const OrtOpAttr *const *, int, int, int, OrtOp **)
     * }
     */
    public static MemorySegment CreateOp(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, int _x3, MemorySegment _x4, MemorySegment _x5, int _x6, MemorySegment _x7, int _x8, int _x9, int _x10, MemorySegment _x11) {
        var funcPtr = struct.get(CreateOp$LAYOUT, CreateOp$OFFSET);
        return CreateOp.invoke(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6, _x7, _x8, _x9, _x10, _x11);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*InvokeOp)(const OrtKernelContext *, const OrtOp *, const OrtValue *const *, int, OrtValue *const *, int)
     * }
     */
    private static class InvokeOp {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_INT,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_INT
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, int _x3, MemorySegment _x4, int _x5) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout InvokeOp$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("InvokeOp"));

    private static final long InvokeOp$OFFSET = $LAYOUT.byteOffset(groupElement("InvokeOp"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*InvokeOp)(const OrtKernelContext *, const OrtOp *, const OrtValue *const *, int, OrtValue *const *, int)
     * }
     */
    public static MemorySegment InvokeOp(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, int _x3, MemorySegment _x4, int _x5) {
        var funcPtr = struct.get(InvokeOp$LAYOUT, InvokeOp$OFFSET);
        return InvokeOp.invoke(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5);
    }

    /**
     * {@snippet lang=c :
     * void (*ReleaseOp)(OrtOp *)
     * }
     */
    private static class ReleaseOp {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ReleaseOp$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ReleaseOp"));

    private static final long ReleaseOp$OFFSET = $LAYOUT.byteOffset(groupElement("ReleaseOp"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * void (*ReleaseOp)(OrtOp *)
     * }
     */
    public static void ReleaseOp(MemorySegment struct, MemorySegment _x0) {
        var funcPtr = struct.get(ReleaseOp$LAYOUT, ReleaseOp$OFFSET);
        ReleaseOp.invoke(funcPtr, _x0);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider)(OrtSessionOptions *, const char *, const char *const *, const char *const *, size_t)
     * }
     */
    private static class SessionOptionsAppendExecutionProvider {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, long _x4) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SessionOptionsAppendExecutionProvider$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SessionOptionsAppendExecutionProvider"));

    private static final long SessionOptionsAppendExecutionProvider$OFFSET = $LAYOUT.byteOffset(groupElement("SessionOptionsAppendExecutionProvider"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider)(OrtSessionOptions *, const char *, const char *const *, const char *const *, size_t)
     * }
     */
    public static MemorySegment SessionOptionsAppendExecutionProvider(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, long _x4) {
        var funcPtr = struct.get(SessionOptionsAppendExecutionProvider$LAYOUT, SessionOptionsAppendExecutionProvider$OFFSET);
        return SessionOptionsAppendExecutionProvider.invoke(funcPtr, _x0, _x1, _x2, _x3, _x4);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CopyKernelInfo)(const OrtKernelInfo *, OrtKernelInfo **)
     * }
     */
    private static class CopyKernelInfo {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CopyKernelInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CopyKernelInfo"));

    private static final long CopyKernelInfo$OFFSET = $LAYOUT.byteOffset(groupElement("CopyKernelInfo"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CopyKernelInfo)(const OrtKernelInfo *, OrtKernelInfo **)
     * }
     */
    public static MemorySegment CopyKernelInfo(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {
        var funcPtr = struct.get(CopyKernelInfo$LAYOUT, CopyKernelInfo$OFFSET);
        return CopyKernelInfo.invoke(funcPtr, _x0, _x1);
    }

    /**
     * {@snippet lang=c :
     * void (*ReleaseKernelInfo)(OrtKernelInfo *)
     * }
     */
    private static class ReleaseKernelInfo {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ReleaseKernelInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ReleaseKernelInfo"));

    private static final long ReleaseKernelInfo$OFFSET = $LAYOUT.byteOffset(groupElement("ReleaseKernelInfo"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * void (*ReleaseKernelInfo)(OrtKernelInfo *)
     * }
     */
    public static void ReleaseKernelInfo(MemorySegment struct, MemorySegment _x0) {
        var funcPtr = struct.get(ReleaseKernelInfo$LAYOUT, ReleaseKernelInfo$OFFSET);
        ReleaseKernelInfo.invoke(funcPtr, _x0);
    }

    /**
     * {@snippet lang=c :
     * const OrtTrainingApi *(*GetTrainingApi)(uint32_t)
     * }
     */
    private static class GetTrainingApi {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_INT
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,int _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetTrainingApi$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetTrainingApi"));

    private static final long GetTrainingApi$OFFSET = $LAYOUT.byteOffset(groupElement("GetTrainingApi"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * const OrtTrainingApi *(*GetTrainingApi)(uint32_t)
     * }
     */
    public static MemorySegment GetTrainingApi(MemorySegment struct, int _x0) {
        var funcPtr = struct.get(GetTrainingApi$LAYOUT, GetTrainingApi$OFFSET);
        return GetTrainingApi.invoke(funcPtr, _x0);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_CANN)(OrtSessionOptions *, const OrtCANNProviderOptions *)
     * }
     */
    private static class SessionOptionsAppendExecutionProvider_CANN {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SessionOptionsAppendExecutionProvider_CANN$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SessionOptionsAppendExecutionProvider_CANN"));

    private static final long SessionOptionsAppendExecutionProvider_CANN$OFFSET = $LAYOUT.byteOffset(groupElement("SessionOptionsAppendExecutionProvider_CANN"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_CANN)(OrtSessionOptions *, const OrtCANNProviderOptions *)
     * }
     */
    public static MemorySegment SessionOptionsAppendExecutionProvider_CANN(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {
        var funcPtr = struct.get(SessionOptionsAppendExecutionProvider_CANN$LAYOUT, SessionOptionsAppendExecutionProvider_CANN$OFFSET);
        return SessionOptionsAppendExecutionProvider_CANN.invoke(funcPtr, _x0, _x1);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateCANNProviderOptions)(OrtCANNProviderOptions **)
     * }
     */
    private static class CreateCANNProviderOptions {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CreateCANNProviderOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CreateCANNProviderOptions"));

    private static final long CreateCANNProviderOptions$OFFSET = $LAYOUT.byteOffset(groupElement("CreateCANNProviderOptions"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateCANNProviderOptions)(OrtCANNProviderOptions **)
     * }
     */
    public static MemorySegment CreateCANNProviderOptions(MemorySegment struct, MemorySegment _x0) {
        var funcPtr = struct.get(CreateCANNProviderOptions$LAYOUT, CreateCANNProviderOptions$OFFSET);
        return CreateCANNProviderOptions.invoke(funcPtr, _x0);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*UpdateCANNProviderOptions)(OrtCANNProviderOptions *, const char *const *, const char *const *, size_t)
     * }
     */
    private static class UpdateCANNProviderOptions {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout UpdateCANNProviderOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("UpdateCANNProviderOptions"));

    private static final long UpdateCANNProviderOptions$OFFSET = $LAYOUT.byteOffset(groupElement("UpdateCANNProviderOptions"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UpdateCANNProviderOptions)(OrtCANNProviderOptions *, const char *const *, const char *const *, size_t)
     * }
     */
    public static MemorySegment UpdateCANNProviderOptions(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3) {
        var funcPtr = struct.get(UpdateCANNProviderOptions$LAYOUT, UpdateCANNProviderOptions$OFFSET);
        return UpdateCANNProviderOptions.invoke(funcPtr, _x0, _x1, _x2, _x3);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetCANNProviderOptionsAsString)(const OrtCANNProviderOptions *, OrtAllocator *, char **)
     * }
     */
    private static class GetCANNProviderOptionsAsString {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetCANNProviderOptionsAsString$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetCANNProviderOptionsAsString"));

    private static final long GetCANNProviderOptionsAsString$OFFSET = $LAYOUT.byteOffset(groupElement("GetCANNProviderOptionsAsString"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetCANNProviderOptionsAsString)(const OrtCANNProviderOptions *, OrtAllocator *, char **)
     * }
     */
    public static MemorySegment GetCANNProviderOptionsAsString(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
        var funcPtr = struct.get(GetCANNProviderOptionsAsString$LAYOUT, GetCANNProviderOptionsAsString$OFFSET);
        return GetCANNProviderOptionsAsString.invoke(funcPtr, _x0, _x1, _x2);
    }

    /**
     * {@snippet lang=c :
     * void (*ReleaseCANNProviderOptions)(OrtCANNProviderOptions *)
     * }
     */
    private static class ReleaseCANNProviderOptions {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ReleaseCANNProviderOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ReleaseCANNProviderOptions"));

    private static final long ReleaseCANNProviderOptions$OFFSET = $LAYOUT.byteOffset(groupElement("ReleaseCANNProviderOptions"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * void (*ReleaseCANNProviderOptions)(OrtCANNProviderOptions *)
     * }
     */
    public static void ReleaseCANNProviderOptions(MemorySegment struct, MemorySegment _x0) {
        var funcPtr = struct.get(ReleaseCANNProviderOptions$LAYOUT, ReleaseCANNProviderOptions$OFFSET);
        ReleaseCANNProviderOptions.invoke(funcPtr, _x0);
    }

    /**
     * {@snippet lang=c :
     * void (*MemoryInfoGetDeviceType)(const OrtMemoryInfo *, OrtMemoryInfoDeviceType *)
     * }
     */
    private static class MemoryInfoGetDeviceType {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout MemoryInfoGetDeviceType$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("MemoryInfoGetDeviceType"));

    private static final long MemoryInfoGetDeviceType$OFFSET = $LAYOUT.byteOffset(groupElement("MemoryInfoGetDeviceType"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * void (*MemoryInfoGetDeviceType)(const OrtMemoryInfo *, OrtMemoryInfoDeviceType *)
     * }
     */
    public static void MemoryInfoGetDeviceType(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {
        var funcPtr = struct.get(MemoryInfoGetDeviceType$LAYOUT, MemoryInfoGetDeviceType$OFFSET);
        MemoryInfoGetDeviceType.invoke(funcPtr, _x0, _x1);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*UpdateEnvWithCustomLogLevel)(OrtEnv *, OrtLoggingLevel)
     * }
     */
    private static class UpdateEnvWithCustomLogLevel {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_INT
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout UpdateEnvWithCustomLogLevel$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("UpdateEnvWithCustomLogLevel"));

    private static final long UpdateEnvWithCustomLogLevel$OFFSET = $LAYOUT.byteOffset(groupElement("UpdateEnvWithCustomLogLevel"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UpdateEnvWithCustomLogLevel)(OrtEnv *, OrtLoggingLevel)
     * }
     */
    public static MemorySegment UpdateEnvWithCustomLogLevel(MemorySegment struct, MemorySegment _x0, int _x1) {
        var funcPtr = struct.get(UpdateEnvWithCustomLogLevel$LAYOUT, UpdateEnvWithCustomLogLevel$OFFSET);
        return UpdateEnvWithCustomLogLevel.invoke(funcPtr, _x0, _x1);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGlobalIntraOpThreadAffinity)(OrtThreadingOptions *, const char *)
     * }
     */
    private static class SetGlobalIntraOpThreadAffinity {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SetGlobalIntraOpThreadAffinity$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SetGlobalIntraOpThreadAffinity"));

    private static final long SetGlobalIntraOpThreadAffinity$OFFSET = $LAYOUT.byteOffset(groupElement("SetGlobalIntraOpThreadAffinity"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGlobalIntraOpThreadAffinity)(OrtThreadingOptions *, const char *)
     * }
     */
    public static MemorySegment SetGlobalIntraOpThreadAffinity(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {
        var funcPtr = struct.get(SetGlobalIntraOpThreadAffinity$LAYOUT, SetGlobalIntraOpThreadAffinity$OFFSET);
        return SetGlobalIntraOpThreadAffinity.invoke(funcPtr, _x0, _x1);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*RegisterCustomOpsLibrary_V2)(OrtSessionOptions *, const char *)
     * }
     */
    private static class RegisterCustomOpsLibrary_V2 {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout RegisterCustomOpsLibrary_V2$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("RegisterCustomOpsLibrary_V2"));

    private static final long RegisterCustomOpsLibrary_V2$OFFSET = $LAYOUT.byteOffset(groupElement("RegisterCustomOpsLibrary_V2"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RegisterCustomOpsLibrary_V2)(OrtSessionOptions *, const char *)
     * }
     */
    public static MemorySegment RegisterCustomOpsLibrary_V2(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {
        var funcPtr = struct.get(RegisterCustomOpsLibrary_V2$LAYOUT, RegisterCustomOpsLibrary_V2$OFFSET);
        return RegisterCustomOpsLibrary_V2.invoke(funcPtr, _x0, _x1);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*RegisterCustomOpsUsingFunction)(OrtSessionOptions *, const char *)
     * }
     */
    private static class RegisterCustomOpsUsingFunction {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout RegisterCustomOpsUsingFunction$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("RegisterCustomOpsUsingFunction"));

    private static final long RegisterCustomOpsUsingFunction$OFFSET = $LAYOUT.byteOffset(groupElement("RegisterCustomOpsUsingFunction"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RegisterCustomOpsUsingFunction)(OrtSessionOptions *, const char *)
     * }
     */
    public static MemorySegment RegisterCustomOpsUsingFunction(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {
        var funcPtr = struct.get(RegisterCustomOpsUsingFunction$LAYOUT, RegisterCustomOpsUsingFunction$OFFSET);
        return RegisterCustomOpsUsingFunction.invoke(funcPtr, _x0, _x1);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfo_GetInputCount)(const OrtKernelInfo *, size_t *)
     * }
     */
    private static class KernelInfo_GetInputCount {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout KernelInfo_GetInputCount$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("KernelInfo_GetInputCount"));

    private static final long KernelInfo_GetInputCount$OFFSET = $LAYOUT.byteOffset(groupElement("KernelInfo_GetInputCount"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfo_GetInputCount)(const OrtKernelInfo *, size_t *)
     * }
     */
    public static MemorySegment KernelInfo_GetInputCount(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {
        var funcPtr = struct.get(KernelInfo_GetInputCount$LAYOUT, KernelInfo_GetInputCount$OFFSET);
        return KernelInfo_GetInputCount.invoke(funcPtr, _x0, _x1);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfo_GetOutputCount)(const OrtKernelInfo *, size_t *)
     * }
     */
    private static class KernelInfo_GetOutputCount {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout KernelInfo_GetOutputCount$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("KernelInfo_GetOutputCount"));

    private static final long KernelInfo_GetOutputCount$OFFSET = $LAYOUT.byteOffset(groupElement("KernelInfo_GetOutputCount"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfo_GetOutputCount)(const OrtKernelInfo *, size_t *)
     * }
     */
    public static MemorySegment KernelInfo_GetOutputCount(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {
        var funcPtr = struct.get(KernelInfo_GetOutputCount$LAYOUT, KernelInfo_GetOutputCount$OFFSET);
        return KernelInfo_GetOutputCount.invoke(funcPtr, _x0, _x1);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfo_GetInputName)(const OrtKernelInfo *, size_t, char *, size_t *)
     * }
     */
    private static class KernelInfo_GetInputName {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, long _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout KernelInfo_GetInputName$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("KernelInfo_GetInputName"));

    private static final long KernelInfo_GetInputName$OFFSET = $LAYOUT.byteOffset(groupElement("KernelInfo_GetInputName"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfo_GetInputName)(const OrtKernelInfo *, size_t, char *, size_t *)
     * }
     */
    public static MemorySegment KernelInfo_GetInputName(MemorySegment struct, MemorySegment _x0, long _x1, MemorySegment _x2, MemorySegment _x3) {
        var funcPtr = struct.get(KernelInfo_GetInputName$LAYOUT, KernelInfo_GetInputName$OFFSET);
        return KernelInfo_GetInputName.invoke(funcPtr, _x0, _x1, _x2, _x3);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfo_GetOutputName)(const OrtKernelInfo *, size_t, char *, size_t *)
     * }
     */
    private static class KernelInfo_GetOutputName {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, long _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout KernelInfo_GetOutputName$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("KernelInfo_GetOutputName"));

    private static final long KernelInfo_GetOutputName$OFFSET = $LAYOUT.byteOffset(groupElement("KernelInfo_GetOutputName"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfo_GetOutputName)(const OrtKernelInfo *, size_t, char *, size_t *)
     * }
     */
    public static MemorySegment KernelInfo_GetOutputName(MemorySegment struct, MemorySegment _x0, long _x1, MemorySegment _x2, MemorySegment _x3) {
        var funcPtr = struct.get(KernelInfo_GetOutputName$LAYOUT, KernelInfo_GetOutputName$OFFSET);
        return KernelInfo_GetOutputName.invoke(funcPtr, _x0, _x1, _x2, _x3);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfo_GetInputTypeInfo)(const OrtKernelInfo *, size_t, OrtTypeInfo **)
     * }
     */
    private static class KernelInfo_GetInputTypeInfo {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, long _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout KernelInfo_GetInputTypeInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("KernelInfo_GetInputTypeInfo"));

    private static final long KernelInfo_GetInputTypeInfo$OFFSET = $LAYOUT.byteOffset(groupElement("KernelInfo_GetInputTypeInfo"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfo_GetInputTypeInfo)(const OrtKernelInfo *, size_t, OrtTypeInfo **)
     * }
     */
    public static MemorySegment KernelInfo_GetInputTypeInfo(MemorySegment struct, MemorySegment _x0, long _x1, MemorySegment _x2) {
        var funcPtr = struct.get(KernelInfo_GetInputTypeInfo$LAYOUT, KernelInfo_GetInputTypeInfo$OFFSET);
        return KernelInfo_GetInputTypeInfo.invoke(funcPtr, _x0, _x1, _x2);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfo_GetOutputTypeInfo)(const OrtKernelInfo *, size_t, OrtTypeInfo **)
     * }
     */
    private static class KernelInfo_GetOutputTypeInfo {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, long _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout KernelInfo_GetOutputTypeInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("KernelInfo_GetOutputTypeInfo"));

    private static final long KernelInfo_GetOutputTypeInfo$OFFSET = $LAYOUT.byteOffset(groupElement("KernelInfo_GetOutputTypeInfo"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfo_GetOutputTypeInfo)(const OrtKernelInfo *, size_t, OrtTypeInfo **)
     * }
     */
    public static MemorySegment KernelInfo_GetOutputTypeInfo(MemorySegment struct, MemorySegment _x0, long _x1, MemorySegment _x2) {
        var funcPtr = struct.get(KernelInfo_GetOutputTypeInfo$LAYOUT, KernelInfo_GetOutputTypeInfo$OFFSET);
        return KernelInfo_GetOutputTypeInfo.invoke(funcPtr, _x0, _x1, _x2);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfoGetAttribute_tensor)(const OrtKernelInfo *, const char *, OrtAllocator *, OrtValue **)
     * }
     */
    private static class KernelInfoGetAttribute_tensor {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout KernelInfoGetAttribute_tensor$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("KernelInfoGetAttribute_tensor"));

    private static final long KernelInfoGetAttribute_tensor$OFFSET = $LAYOUT.byteOffset(groupElement("KernelInfoGetAttribute_tensor"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfoGetAttribute_tensor)(const OrtKernelInfo *, const char *, OrtAllocator *, OrtValue **)
     * }
     */
    public static MemorySegment KernelInfoGetAttribute_tensor(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
        var funcPtr = struct.get(KernelInfoGetAttribute_tensor$LAYOUT, KernelInfoGetAttribute_tensor$OFFSET);
        return KernelInfoGetAttribute_tensor.invoke(funcPtr, _x0, _x1, _x2, _x3);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*HasSessionConfigEntry)(const OrtSessionOptions *, const char *, int *)
     * }
     */
    private static class HasSessionConfigEntry {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout HasSessionConfigEntry$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("HasSessionConfigEntry"));

    private static final long HasSessionConfigEntry$OFFSET = $LAYOUT.byteOffset(groupElement("HasSessionConfigEntry"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*HasSessionConfigEntry)(const OrtSessionOptions *, const char *, int *)
     * }
     */
    public static MemorySegment HasSessionConfigEntry(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
        var funcPtr = struct.get(HasSessionConfigEntry$LAYOUT, HasSessionConfigEntry$OFFSET);
        return HasSessionConfigEntry.invoke(funcPtr, _x0, _x1, _x2);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSessionConfigEntry)(const OrtSessionOptions *, const char *, char *, size_t *)
     * }
     */
    private static class GetSessionConfigEntry {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetSessionConfigEntry$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetSessionConfigEntry"));

    private static final long GetSessionConfigEntry$OFFSET = $LAYOUT.byteOffset(groupElement("GetSessionConfigEntry"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSessionConfigEntry)(const OrtSessionOptions *, const char *, char *, size_t *)
     * }
     */
    public static MemorySegment GetSessionConfigEntry(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
        var funcPtr = struct.get(GetSessionConfigEntry$LAYOUT, GetSessionConfigEntry$OFFSET);
        return GetSessionConfigEntry.invoke(funcPtr, _x0, _x1, _x2, _x3);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_Dnnl)(OrtSessionOptions *, const OrtDnnlProviderOptions *)
     * }
     */
    private static class SessionOptionsAppendExecutionProvider_Dnnl {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SessionOptionsAppendExecutionProvider_Dnnl$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SessionOptionsAppendExecutionProvider_Dnnl"));

    private static final long SessionOptionsAppendExecutionProvider_Dnnl$OFFSET = $LAYOUT.byteOffset(groupElement("SessionOptionsAppendExecutionProvider_Dnnl"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_Dnnl)(OrtSessionOptions *, const OrtDnnlProviderOptions *)
     * }
     */
    public static MemorySegment SessionOptionsAppendExecutionProvider_Dnnl(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {
        var funcPtr = struct.get(SessionOptionsAppendExecutionProvider_Dnnl$LAYOUT, SessionOptionsAppendExecutionProvider_Dnnl$OFFSET);
        return SessionOptionsAppendExecutionProvider_Dnnl.invoke(funcPtr, _x0, _x1);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateDnnlProviderOptions)(OrtDnnlProviderOptions **)
     * }
     */
    private static class CreateDnnlProviderOptions {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CreateDnnlProviderOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CreateDnnlProviderOptions"));

    private static final long CreateDnnlProviderOptions$OFFSET = $LAYOUT.byteOffset(groupElement("CreateDnnlProviderOptions"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateDnnlProviderOptions)(OrtDnnlProviderOptions **)
     * }
     */
    public static MemorySegment CreateDnnlProviderOptions(MemorySegment struct, MemorySegment _x0) {
        var funcPtr = struct.get(CreateDnnlProviderOptions$LAYOUT, CreateDnnlProviderOptions$OFFSET);
        return CreateDnnlProviderOptions.invoke(funcPtr, _x0);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*UpdateDnnlProviderOptions)(OrtDnnlProviderOptions *, const char *const *, const char *const *, size_t)
     * }
     */
    private static class UpdateDnnlProviderOptions {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout UpdateDnnlProviderOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("UpdateDnnlProviderOptions"));

    private static final long UpdateDnnlProviderOptions$OFFSET = $LAYOUT.byteOffset(groupElement("UpdateDnnlProviderOptions"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UpdateDnnlProviderOptions)(OrtDnnlProviderOptions *, const char *const *, const char *const *, size_t)
     * }
     */
    public static MemorySegment UpdateDnnlProviderOptions(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3) {
        var funcPtr = struct.get(UpdateDnnlProviderOptions$LAYOUT, UpdateDnnlProviderOptions$OFFSET);
        return UpdateDnnlProviderOptions.invoke(funcPtr, _x0, _x1, _x2, _x3);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetDnnlProviderOptionsAsString)(const OrtDnnlProviderOptions *, OrtAllocator *, char **)
     * }
     */
    private static class GetDnnlProviderOptionsAsString {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetDnnlProviderOptionsAsString$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetDnnlProviderOptionsAsString"));

    private static final long GetDnnlProviderOptionsAsString$OFFSET = $LAYOUT.byteOffset(groupElement("GetDnnlProviderOptionsAsString"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetDnnlProviderOptionsAsString)(const OrtDnnlProviderOptions *, OrtAllocator *, char **)
     * }
     */
    public static MemorySegment GetDnnlProviderOptionsAsString(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
        var funcPtr = struct.get(GetDnnlProviderOptionsAsString$LAYOUT, GetDnnlProviderOptionsAsString$OFFSET);
        return GetDnnlProviderOptionsAsString.invoke(funcPtr, _x0, _x1, _x2);
    }

    /**
     * {@snippet lang=c :
     * void (*ReleaseDnnlProviderOptions)(OrtDnnlProviderOptions *)
     * }
     */
    private static class ReleaseDnnlProviderOptions {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ReleaseDnnlProviderOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ReleaseDnnlProviderOptions"));

    private static final long ReleaseDnnlProviderOptions$OFFSET = $LAYOUT.byteOffset(groupElement("ReleaseDnnlProviderOptions"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * void (*ReleaseDnnlProviderOptions)(OrtDnnlProviderOptions *)
     * }
     */
    public static void ReleaseDnnlProviderOptions(MemorySegment struct, MemorySegment _x0) {
        var funcPtr = struct.get(ReleaseDnnlProviderOptions$LAYOUT, ReleaseDnnlProviderOptions$OFFSET);
        ReleaseDnnlProviderOptions.invoke(funcPtr, _x0);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfo_GetNodeName)(const OrtKernelInfo *, char *, size_t *)
     * }
     */
    private static class KernelInfo_GetNodeName {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout KernelInfo_GetNodeName$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("KernelInfo_GetNodeName"));

    private static final long KernelInfo_GetNodeName$OFFSET = $LAYOUT.byteOffset(groupElement("KernelInfo_GetNodeName"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfo_GetNodeName)(const OrtKernelInfo *, char *, size_t *)
     * }
     */
    public static MemorySegment KernelInfo_GetNodeName(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
        var funcPtr = struct.get(KernelInfo_GetNodeName$LAYOUT, KernelInfo_GetNodeName$OFFSET);
        return KernelInfo_GetNodeName.invoke(funcPtr, _x0, _x1, _x2);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfo_GetLogger)(const OrtKernelInfo *, const OrtLogger **)
     * }
     */
    private static class KernelInfo_GetLogger {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout KernelInfo_GetLogger$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("KernelInfo_GetLogger"));

    private static final long KernelInfo_GetLogger$OFFSET = $LAYOUT.byteOffset(groupElement("KernelInfo_GetLogger"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfo_GetLogger)(const OrtKernelInfo *, const OrtLogger **)
     * }
     */
    public static MemorySegment KernelInfo_GetLogger(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {
        var funcPtr = struct.get(KernelInfo_GetLogger$LAYOUT, KernelInfo_GetLogger$OFFSET);
        return KernelInfo_GetLogger.invoke(funcPtr, _x0, _x1);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetLogger)(const OrtKernelContext *, const OrtLogger **)
     * }
     */
    private static class KernelContext_GetLogger {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout KernelContext_GetLogger$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("KernelContext_GetLogger"));

    private static final long KernelContext_GetLogger$OFFSET = $LAYOUT.byteOffset(groupElement("KernelContext_GetLogger"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetLogger)(const OrtKernelContext *, const OrtLogger **)
     * }
     */
    public static MemorySegment KernelContext_GetLogger(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {
        var funcPtr = struct.get(KernelContext_GetLogger$LAYOUT, KernelContext_GetLogger$OFFSET);
        return KernelContext_GetLogger.invoke(funcPtr, _x0, _x1);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*Logger_LogMessage)(const OrtLogger *, OrtLoggingLevel, const char *, const char *, int, const char *)
     * }
     */
    private static class Logger_LogMessage {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_INT,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_INT,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3, int _x4, MemorySegment _x5) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout Logger_LogMessage$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("Logger_LogMessage"));

    private static final long Logger_LogMessage$OFFSET = $LAYOUT.byteOffset(groupElement("Logger_LogMessage"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Logger_LogMessage)(const OrtLogger *, OrtLoggingLevel, const char *, const char *, int, const char *)
     * }
     */
    public static MemorySegment Logger_LogMessage(MemorySegment struct, MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3, int _x4, MemorySegment _x5) {
        var funcPtr = struct.get(Logger_LogMessage$LAYOUT, Logger_LogMessage$OFFSET);
        return Logger_LogMessage.invoke(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*Logger_GetLoggingSeverityLevel)(const OrtLogger *, OrtLoggingLevel *)
     * }
     */
    private static class Logger_GetLoggingSeverityLevel {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout Logger_GetLoggingSeverityLevel$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("Logger_GetLoggingSeverityLevel"));

    private static final long Logger_GetLoggingSeverityLevel$OFFSET = $LAYOUT.byteOffset(groupElement("Logger_GetLoggingSeverityLevel"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Logger_GetLoggingSeverityLevel)(const OrtLogger *, OrtLoggingLevel *)
     * }
     */
    public static MemorySegment Logger_GetLoggingSeverityLevel(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {
        var funcPtr = struct.get(Logger_GetLoggingSeverityLevel$LAYOUT, Logger_GetLoggingSeverityLevel$OFFSET);
        return Logger_GetLoggingSeverityLevel.invoke(funcPtr, _x0, _x1);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfoGetConstantInput_tensor)(const OrtKernelInfo *, size_t, int *, const OrtValue **)
     * }
     */
    private static class KernelInfoGetConstantInput_tensor {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, long _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout KernelInfoGetConstantInput_tensor$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("KernelInfoGetConstantInput_tensor"));

    private static final long KernelInfoGetConstantInput_tensor$OFFSET = $LAYOUT.byteOffset(groupElement("KernelInfoGetConstantInput_tensor"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfoGetConstantInput_tensor)(const OrtKernelInfo *, size_t, int *, const OrtValue **)
     * }
     */
    public static MemorySegment KernelInfoGetConstantInput_tensor(MemorySegment struct, MemorySegment _x0, long _x1, MemorySegment _x2, MemorySegment _x3) {
        var funcPtr = struct.get(KernelInfoGetConstantInput_tensor$LAYOUT, KernelInfoGetConstantInput_tensor$OFFSET);
        return KernelInfoGetConstantInput_tensor.invoke(funcPtr, _x0, _x1, _x2, _x3);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CastTypeInfoToOptionalTypeInfo)(const OrtTypeInfo *, const OrtOptionalTypeInfo **)
     * }
     */
    private static class CastTypeInfoToOptionalTypeInfo {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CastTypeInfoToOptionalTypeInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CastTypeInfoToOptionalTypeInfo"));

    private static final long CastTypeInfoToOptionalTypeInfo$OFFSET = $LAYOUT.byteOffset(groupElement("CastTypeInfoToOptionalTypeInfo"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CastTypeInfoToOptionalTypeInfo)(const OrtTypeInfo *, const OrtOptionalTypeInfo **)
     * }
     */
    public static MemorySegment CastTypeInfoToOptionalTypeInfo(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {
        var funcPtr = struct.get(CastTypeInfoToOptionalTypeInfo$LAYOUT, CastTypeInfoToOptionalTypeInfo$OFFSET);
        return CastTypeInfoToOptionalTypeInfo.invoke(funcPtr, _x0, _x1);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetOptionalContainedTypeInfo)(const OrtOptionalTypeInfo *, OrtTypeInfo **)
     * }
     */
    private static class GetOptionalContainedTypeInfo {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetOptionalContainedTypeInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetOptionalContainedTypeInfo"));

    private static final long GetOptionalContainedTypeInfo$OFFSET = $LAYOUT.byteOffset(groupElement("GetOptionalContainedTypeInfo"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetOptionalContainedTypeInfo)(const OrtOptionalTypeInfo *, OrtTypeInfo **)
     * }
     */
    public static MemorySegment GetOptionalContainedTypeInfo(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {
        var funcPtr = struct.get(GetOptionalContainedTypeInfo$LAYOUT, GetOptionalContainedTypeInfo$OFFSET);
        return GetOptionalContainedTypeInfo.invoke(funcPtr, _x0, _x1);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetResizedStringTensorElementBuffer)(OrtValue *, size_t, size_t, char **)
     * }
     */
    private static class GetResizedStringTensorElementBuffer {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, long _x1, long _x2, MemorySegment _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetResizedStringTensorElementBuffer$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetResizedStringTensorElementBuffer"));

    private static final long GetResizedStringTensorElementBuffer$OFFSET = $LAYOUT.byteOffset(groupElement("GetResizedStringTensorElementBuffer"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetResizedStringTensorElementBuffer)(OrtValue *, size_t, size_t, char **)
     * }
     */
    public static MemorySegment GetResizedStringTensorElementBuffer(MemorySegment struct, MemorySegment _x0, long _x1, long _x2, MemorySegment _x3) {
        var funcPtr = struct.get(GetResizedStringTensorElementBuffer$LAYOUT, GetResizedStringTensorElementBuffer$OFFSET);
        return GetResizedStringTensorElementBuffer.invoke(funcPtr, _x0, _x1, _x2, _x3);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetAllocator)(const OrtKernelContext *, const OrtMemoryInfo *, OrtAllocator **)
     * }
     */
    private static class KernelContext_GetAllocator {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout KernelContext_GetAllocator$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("KernelContext_GetAllocator"));

    private static final long KernelContext_GetAllocator$OFFSET = $LAYOUT.byteOffset(groupElement("KernelContext_GetAllocator"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetAllocator)(const OrtKernelContext *, const OrtMemoryInfo *, OrtAllocator **)
     * }
     */
    public static MemorySegment KernelContext_GetAllocator(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
        var funcPtr = struct.get(KernelContext_GetAllocator$LAYOUT, KernelContext_GetAllocator$OFFSET);
        return KernelContext_GetAllocator.invoke(funcPtr, _x0, _x1, _x2);
    }

    /**
     * {@snippet lang=c :
     * const char *(*GetBuildInfoString)(void)
     * }
     */
    private static class GetBuildInfoString {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER);

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetBuildInfoString$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetBuildInfoString"));

    private static final long GetBuildInfoString$OFFSET = $LAYOUT.byteOffset(groupElement("GetBuildInfoString"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * const char *(*GetBuildInfoString)(void)
     * }
     */
    public static MemorySegment GetBuildInfoString(MemorySegment struct) {
        var funcPtr = struct.get(GetBuildInfoString$LAYOUT, GetBuildInfoString$OFFSET);
        return GetBuildInfoString.invoke(funcPtr);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateROCMProviderOptions)(OrtROCMProviderOptions **)
     * }
     */
    private static class CreateROCMProviderOptions {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CreateROCMProviderOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CreateROCMProviderOptions"));

    private static final long CreateROCMProviderOptions$OFFSET = $LAYOUT.byteOffset(groupElement("CreateROCMProviderOptions"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateROCMProviderOptions)(OrtROCMProviderOptions **)
     * }
     */
    public static MemorySegment CreateROCMProviderOptions(MemorySegment struct, MemorySegment _x0) {
        var funcPtr = struct.get(CreateROCMProviderOptions$LAYOUT, CreateROCMProviderOptions$OFFSET);
        return CreateROCMProviderOptions.invoke(funcPtr, _x0);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*UpdateROCMProviderOptions)(OrtROCMProviderOptions *, const char *const *, const char *const *, size_t)
     * }
     */
    private static class UpdateROCMProviderOptions {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout UpdateROCMProviderOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("UpdateROCMProviderOptions"));

    private static final long UpdateROCMProviderOptions$OFFSET = $LAYOUT.byteOffset(groupElement("UpdateROCMProviderOptions"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UpdateROCMProviderOptions)(OrtROCMProviderOptions *, const char *const *, const char *const *, size_t)
     * }
     */
    public static MemorySegment UpdateROCMProviderOptions(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3) {
        var funcPtr = struct.get(UpdateROCMProviderOptions$LAYOUT, UpdateROCMProviderOptions$OFFSET);
        return UpdateROCMProviderOptions.invoke(funcPtr, _x0, _x1, _x2, _x3);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetROCMProviderOptionsAsString)(const OrtROCMProviderOptions *, OrtAllocator *, char **)
     * }
     */
    private static class GetROCMProviderOptionsAsString {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetROCMProviderOptionsAsString$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetROCMProviderOptionsAsString"));

    private static final long GetROCMProviderOptionsAsString$OFFSET = $LAYOUT.byteOffset(groupElement("GetROCMProviderOptionsAsString"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetROCMProviderOptionsAsString)(const OrtROCMProviderOptions *, OrtAllocator *, char **)
     * }
     */
    public static MemorySegment GetROCMProviderOptionsAsString(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
        var funcPtr = struct.get(GetROCMProviderOptionsAsString$LAYOUT, GetROCMProviderOptionsAsString$OFFSET);
        return GetROCMProviderOptionsAsString.invoke(funcPtr, _x0, _x1, _x2);
    }

    /**
     * {@snippet lang=c :
     * void (*ReleaseROCMProviderOptions)(OrtROCMProviderOptions *)
     * }
     */
    private static class ReleaseROCMProviderOptions {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ReleaseROCMProviderOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ReleaseROCMProviderOptions"));

    private static final long ReleaseROCMProviderOptions$OFFSET = $LAYOUT.byteOffset(groupElement("ReleaseROCMProviderOptions"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * void (*ReleaseROCMProviderOptions)(OrtROCMProviderOptions *)
     * }
     */
    public static void ReleaseROCMProviderOptions(MemorySegment struct, MemorySegment _x0) {
        var funcPtr = struct.get(ReleaseROCMProviderOptions$LAYOUT, ReleaseROCMProviderOptions$OFFSET);
        ReleaseROCMProviderOptions.invoke(funcPtr, _x0);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateAndRegisterAllocatorV2)(OrtEnv *, const char *, const OrtMemoryInfo *, const OrtArenaCfg *, const char *const *, const char *const *, size_t)
     * }
     */
    private static class CreateAndRegisterAllocatorV2 {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4, MemorySegment _x5, long _x6) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CreateAndRegisterAllocatorV2$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CreateAndRegisterAllocatorV2"));

    private static final long CreateAndRegisterAllocatorV2$OFFSET = $LAYOUT.byteOffset(groupElement("CreateAndRegisterAllocatorV2"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateAndRegisterAllocatorV2)(OrtEnv *, const char *, const OrtMemoryInfo *, const OrtArenaCfg *, const char *const *, const char *const *, size_t)
     * }
     */
    public static MemorySegment CreateAndRegisterAllocatorV2(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4, MemorySegment _x5, long _x6) {
        var funcPtr = struct.get(CreateAndRegisterAllocatorV2$LAYOUT, CreateAndRegisterAllocatorV2$OFFSET);
        return CreateAndRegisterAllocatorV2.invoke(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*RunAsync)(OrtSession *, const OrtRunOptions *, const char *const *, const OrtValue *const *, size_t, const char *const *, size_t, OrtValue **, RunAsyncCallbackFn, void *)
     * }
     */
    private static class RunAsync {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, long _x4, MemorySegment _x5, long _x6, MemorySegment _x7, MemorySegment _x8, MemorySegment _x9) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6, _x7, _x8, _x9);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout RunAsync$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("RunAsync"));

    private static final long RunAsync$OFFSET = $LAYOUT.byteOffset(groupElement("RunAsync"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RunAsync)(OrtSession *, const OrtRunOptions *, const char *const *, const OrtValue *const *, size_t, const char *const *, size_t, OrtValue **, RunAsyncCallbackFn, void *)
     * }
     */
    public static MemorySegment RunAsync(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, long _x4, MemorySegment _x5, long _x6, MemorySegment _x7, MemorySegment _x8, MemorySegment _x9) {
        var funcPtr = struct.get(RunAsync$LAYOUT, RunAsync$OFFSET);
        return RunAsync.invoke(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6, _x7, _x8, _x9);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*UpdateTensorRTProviderOptionsWithValue)(OrtTensorRTProviderOptionsV2 *, const char *, void *)
     * }
     */
    private static class UpdateTensorRTProviderOptionsWithValue {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout UpdateTensorRTProviderOptionsWithValue$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("UpdateTensorRTProviderOptionsWithValue"));

    private static final long UpdateTensorRTProviderOptionsWithValue$OFFSET = $LAYOUT.byteOffset(groupElement("UpdateTensorRTProviderOptionsWithValue"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UpdateTensorRTProviderOptionsWithValue)(OrtTensorRTProviderOptionsV2 *, const char *, void *)
     * }
     */
    public static MemorySegment UpdateTensorRTProviderOptionsWithValue(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
        var funcPtr = struct.get(UpdateTensorRTProviderOptionsWithValue$LAYOUT, UpdateTensorRTProviderOptionsWithValue$OFFSET);
        return UpdateTensorRTProviderOptionsWithValue.invoke(funcPtr, _x0, _x1, _x2);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTensorRTProviderOptionsByName)(const OrtTensorRTProviderOptionsV2 *, const char *, void **)
     * }
     */
    private static class GetTensorRTProviderOptionsByName {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetTensorRTProviderOptionsByName$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetTensorRTProviderOptionsByName"));

    private static final long GetTensorRTProviderOptionsByName$OFFSET = $LAYOUT.byteOffset(groupElement("GetTensorRTProviderOptionsByName"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTensorRTProviderOptionsByName)(const OrtTensorRTProviderOptionsV2 *, const char *, void **)
     * }
     */
    public static MemorySegment GetTensorRTProviderOptionsByName(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
        var funcPtr = struct.get(GetTensorRTProviderOptionsByName$LAYOUT, GetTensorRTProviderOptionsByName$OFFSET);
        return GetTensorRTProviderOptionsByName.invoke(funcPtr, _x0, _x1, _x2);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*UpdateCUDAProviderOptionsWithValue)(OrtCUDAProviderOptionsV2 *, const char *, void *)
     * }
     */
    private static class UpdateCUDAProviderOptionsWithValue {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout UpdateCUDAProviderOptionsWithValue$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("UpdateCUDAProviderOptionsWithValue"));

    private static final long UpdateCUDAProviderOptionsWithValue$OFFSET = $LAYOUT.byteOffset(groupElement("UpdateCUDAProviderOptionsWithValue"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UpdateCUDAProviderOptionsWithValue)(OrtCUDAProviderOptionsV2 *, const char *, void *)
     * }
     */
    public static MemorySegment UpdateCUDAProviderOptionsWithValue(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
        var funcPtr = struct.get(UpdateCUDAProviderOptionsWithValue$LAYOUT, UpdateCUDAProviderOptionsWithValue$OFFSET);
        return UpdateCUDAProviderOptionsWithValue.invoke(funcPtr, _x0, _x1, _x2);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetCUDAProviderOptionsByName)(const OrtCUDAProviderOptionsV2 *, const char *, void **)
     * }
     */
    private static class GetCUDAProviderOptionsByName {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetCUDAProviderOptionsByName$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetCUDAProviderOptionsByName"));

    private static final long GetCUDAProviderOptionsByName$OFFSET = $LAYOUT.byteOffset(groupElement("GetCUDAProviderOptionsByName"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetCUDAProviderOptionsByName)(const OrtCUDAProviderOptionsV2 *, const char *, void **)
     * }
     */
    public static MemorySegment GetCUDAProviderOptionsByName(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
        var funcPtr = struct.get(GetCUDAProviderOptionsByName$LAYOUT, GetCUDAProviderOptionsByName$OFFSET);
        return GetCUDAProviderOptionsByName.invoke(funcPtr, _x0, _x1, _x2);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetResource)(const OrtKernelContext *, int, int, void **)
     * }
     */
    private static class KernelContext_GetResource {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_INT,
            onnxruntime_c_api_h.C_INT,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, int _x2, MemorySegment _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout KernelContext_GetResource$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("KernelContext_GetResource"));

    private static final long KernelContext_GetResource$OFFSET = $LAYOUT.byteOffset(groupElement("KernelContext_GetResource"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetResource)(const OrtKernelContext *, int, int, void **)
     * }
     */
    public static MemorySegment KernelContext_GetResource(MemorySegment struct, MemorySegment _x0, int _x1, int _x2, MemorySegment _x3) {
        var funcPtr = struct.get(KernelContext_GetResource$LAYOUT, KernelContext_GetResource$OFFSET);
        return KernelContext_GetResource.invoke(funcPtr, _x0, _x1, _x2, _x3);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SetUserLoggingFunction)(OrtSessionOptions *, OrtLoggingFunction, void *)
     * }
     */
    private static class SetUserLoggingFunction {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SetUserLoggingFunction$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SetUserLoggingFunction"));

    private static final long SetUserLoggingFunction$OFFSET = $LAYOUT.byteOffset(groupElement("SetUserLoggingFunction"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetUserLoggingFunction)(OrtSessionOptions *, OrtLoggingFunction, void *)
     * }
     */
    public static MemorySegment SetUserLoggingFunction(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
        var funcPtr = struct.get(SetUserLoggingFunction$LAYOUT, SetUserLoggingFunction$OFFSET);
        return SetUserLoggingFunction.invoke(funcPtr, _x0, _x1, _x2);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*ShapeInferContext_GetInputCount)(const OrtShapeInferContext *, size_t *)
     * }
     */
    private static class ShapeInferContext_GetInputCount {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ShapeInferContext_GetInputCount$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ShapeInferContext_GetInputCount"));

    private static final long ShapeInferContext_GetInputCount$OFFSET = $LAYOUT.byteOffset(groupElement("ShapeInferContext_GetInputCount"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ShapeInferContext_GetInputCount)(const OrtShapeInferContext *, size_t *)
     * }
     */
    public static MemorySegment ShapeInferContext_GetInputCount(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {
        var funcPtr = struct.get(ShapeInferContext_GetInputCount$LAYOUT, ShapeInferContext_GetInputCount$OFFSET);
        return ShapeInferContext_GetInputCount.invoke(funcPtr, _x0, _x1);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*ShapeInferContext_GetInputTypeShape)(const OrtShapeInferContext *, size_t, OrtTensorTypeAndShapeInfo **)
     * }
     */
    private static class ShapeInferContext_GetInputTypeShape {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, long _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ShapeInferContext_GetInputTypeShape$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ShapeInferContext_GetInputTypeShape"));

    private static final long ShapeInferContext_GetInputTypeShape$OFFSET = $LAYOUT.byteOffset(groupElement("ShapeInferContext_GetInputTypeShape"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ShapeInferContext_GetInputTypeShape)(const OrtShapeInferContext *, size_t, OrtTensorTypeAndShapeInfo **)
     * }
     */
    public static MemorySegment ShapeInferContext_GetInputTypeShape(MemorySegment struct, MemorySegment _x0, long _x1, MemorySegment _x2) {
        var funcPtr = struct.get(ShapeInferContext_GetInputTypeShape$LAYOUT, ShapeInferContext_GetInputTypeShape$OFFSET);
        return ShapeInferContext_GetInputTypeShape.invoke(funcPtr, _x0, _x1, _x2);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*ShapeInferContext_GetAttribute)(const OrtShapeInferContext *, const char *, const OrtOpAttr **)
     * }
     */
    private static class ShapeInferContext_GetAttribute {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ShapeInferContext_GetAttribute$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ShapeInferContext_GetAttribute"));

    private static final long ShapeInferContext_GetAttribute$OFFSET = $LAYOUT.byteOffset(groupElement("ShapeInferContext_GetAttribute"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ShapeInferContext_GetAttribute)(const OrtShapeInferContext *, const char *, const OrtOpAttr **)
     * }
     */
    public static MemorySegment ShapeInferContext_GetAttribute(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
        var funcPtr = struct.get(ShapeInferContext_GetAttribute$LAYOUT, ShapeInferContext_GetAttribute$OFFSET);
        return ShapeInferContext_GetAttribute.invoke(funcPtr, _x0, _x1, _x2);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*ShapeInferContext_SetOutputTypeShape)(const OrtShapeInferContext *, size_t, const OrtTensorTypeAndShapeInfo *)
     * }
     */
    private static class ShapeInferContext_SetOutputTypeShape {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, long _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ShapeInferContext_SetOutputTypeShape$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ShapeInferContext_SetOutputTypeShape"));

    private static final long ShapeInferContext_SetOutputTypeShape$OFFSET = $LAYOUT.byteOffset(groupElement("ShapeInferContext_SetOutputTypeShape"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ShapeInferContext_SetOutputTypeShape)(const OrtShapeInferContext *, size_t, const OrtTensorTypeAndShapeInfo *)
     * }
     */
    public static MemorySegment ShapeInferContext_SetOutputTypeShape(MemorySegment struct, MemorySegment _x0, long _x1, MemorySegment _x2) {
        var funcPtr = struct.get(ShapeInferContext_SetOutputTypeShape$LAYOUT, ShapeInferContext_SetOutputTypeShape$OFFSET);
        return ShapeInferContext_SetOutputTypeShape.invoke(funcPtr, _x0, _x1, _x2);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SetSymbolicDimensions)(OrtTensorTypeAndShapeInfo *, const char **, size_t)
     * }
     */
    private static class SetSymbolicDimensions {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SetSymbolicDimensions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SetSymbolicDimensions"));

    private static final long SetSymbolicDimensions$OFFSET = $LAYOUT.byteOffset(groupElement("SetSymbolicDimensions"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetSymbolicDimensions)(OrtTensorTypeAndShapeInfo *, const char **, size_t)
     * }
     */
    public static MemorySegment SetSymbolicDimensions(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, long _x2) {
        var funcPtr = struct.get(SetSymbolicDimensions$LAYOUT, SetSymbolicDimensions$OFFSET);
        return SetSymbolicDimensions.invoke(funcPtr, _x0, _x1, _x2);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*ReadOpAttr)(const OrtOpAttr *, OrtOpAttrType, void *, size_t, size_t *)
     * }
     */
    private static class ReadOpAttr {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_INT,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, MemorySegment _x2, long _x3, MemorySegment _x4) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ReadOpAttr$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ReadOpAttr"));

    private static final long ReadOpAttr$OFFSET = $LAYOUT.byteOffset(groupElement("ReadOpAttr"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ReadOpAttr)(const OrtOpAttr *, OrtOpAttrType, void *, size_t, size_t *)
     * }
     */
    public static MemorySegment ReadOpAttr(MemorySegment struct, MemorySegment _x0, int _x1, MemorySegment _x2, long _x3, MemorySegment _x4) {
        var funcPtr = struct.get(ReadOpAttr$LAYOUT, ReadOpAttr$OFFSET);
        return ReadOpAttr.invoke(funcPtr, _x0, _x1, _x2, _x3, _x4);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SetDeterministicCompute)(OrtSessionOptions *, bool)
     * }
     */
    private static class SetDeterministicCompute {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_BOOL
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, boolean _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SetDeterministicCompute$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SetDeterministicCompute"));

    private static final long SetDeterministicCompute$OFFSET = $LAYOUT.byteOffset(groupElement("SetDeterministicCompute"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetDeterministicCompute)(OrtSessionOptions *, bool)
     * }
     */
    public static MemorySegment SetDeterministicCompute(MemorySegment struct, MemorySegment _x0, boolean _x1) {
        var funcPtr = struct.get(SetDeterministicCompute$LAYOUT, SetDeterministicCompute$OFFSET);
        return SetDeterministicCompute.invoke(funcPtr, _x0, _x1);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_ParallelFor)(const OrtKernelContext *, void (*)(void *, size_t), size_t, size_t, void *)
     * }
     */
    private static class KernelContext_ParallelFor {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2, long _x3, MemorySegment _x4) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout KernelContext_ParallelFor$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("KernelContext_ParallelFor"));

    private static final long KernelContext_ParallelFor$OFFSET = $LAYOUT.byteOffset(groupElement("KernelContext_ParallelFor"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_ParallelFor)(const OrtKernelContext *, void (*)(void *, size_t), size_t, size_t, void *)
     * }
     */
    public static MemorySegment KernelContext_ParallelFor(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, long _x2, long _x3, MemorySegment _x4) {
        var funcPtr = struct.get(KernelContext_ParallelFor$LAYOUT, KernelContext_ParallelFor$OFFSET);
        return KernelContext_ParallelFor.invoke(funcPtr, _x0, _x1, _x2, _x3, _x4);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_OpenVINO_V2)(OrtSessionOptions *, const char *const *, const char *const *, size_t)
     * }
     */
    private static class SessionOptionsAppendExecutionProvider_OpenVINO_V2 {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SessionOptionsAppendExecutionProvider_OpenVINO_V2$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SessionOptionsAppendExecutionProvider_OpenVINO_V2"));

    private static final long SessionOptionsAppendExecutionProvider_OpenVINO_V2$OFFSET = $LAYOUT.byteOffset(groupElement("SessionOptionsAppendExecutionProvider_OpenVINO_V2"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_OpenVINO_V2)(OrtSessionOptions *, const char *const *, const char *const *, size_t)
     * }
     */
    public static MemorySegment SessionOptionsAppendExecutionProvider_OpenVINO_V2(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3) {
        var funcPtr = struct.get(SessionOptionsAppendExecutionProvider_OpenVINO_V2$LAYOUT, SessionOptionsAppendExecutionProvider_OpenVINO_V2$OFFSET);
        return SessionOptionsAppendExecutionProvider_OpenVINO_V2.invoke(funcPtr, _x0, _x1, _x2, _x3);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_VitisAI)(OrtSessionOptions *, const char *const *, const char *const *, size_t)
     * }
     */
    private static class SessionOptionsAppendExecutionProvider_VitisAI {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SessionOptionsAppendExecutionProvider_VitisAI$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SessionOptionsAppendExecutionProvider_VitisAI"));

    private static final long SessionOptionsAppendExecutionProvider_VitisAI$OFFSET = $LAYOUT.byteOffset(groupElement("SessionOptionsAppendExecutionProvider_VitisAI"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_VitisAI)(OrtSessionOptions *, const char *const *, const char *const *, size_t)
     * }
     */
    public static MemorySegment SessionOptionsAppendExecutionProvider_VitisAI(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3) {
        var funcPtr = struct.get(SessionOptionsAppendExecutionProvider_VitisAI$LAYOUT, SessionOptionsAppendExecutionProvider_VitisAI$OFFSET);
        return SessionOptionsAppendExecutionProvider_VitisAI.invoke(funcPtr, _x0, _x1, _x2, _x3);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetScratchBuffer)(const OrtKernelContext *, const OrtMemoryInfo *, size_t, void **)
     * }
     */
    private static class KernelContext_GetScratchBuffer {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout KernelContext_GetScratchBuffer$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("KernelContext_GetScratchBuffer"));

    private static final long KernelContext_GetScratchBuffer$OFFSET = $LAYOUT.byteOffset(groupElement("KernelContext_GetScratchBuffer"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetScratchBuffer)(const OrtKernelContext *, const OrtMemoryInfo *, size_t, void **)
     * }
     */
    public static MemorySegment KernelContext_GetScratchBuffer(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3) {
        var funcPtr = struct.get(KernelContext_GetScratchBuffer$LAYOUT, KernelContext_GetScratchBuffer$OFFSET);
        return KernelContext_GetScratchBuffer.invoke(funcPtr, _x0, _x1, _x2, _x3);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfoGetAllocator)(const OrtKernelInfo *, OrtMemType, OrtAllocator **)
     * }
     */
    private static class KernelInfoGetAllocator {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_INT,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout KernelInfoGetAllocator$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("KernelInfoGetAllocator"));

    private static final long KernelInfoGetAllocator$OFFSET = $LAYOUT.byteOffset(groupElement("KernelInfoGetAllocator"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfoGetAllocator)(const OrtKernelInfo *, OrtMemType, OrtAllocator **)
     * }
     */
    public static MemorySegment KernelInfoGetAllocator(MemorySegment struct, MemorySegment _x0, int _x1, MemorySegment _x2) {
        var funcPtr = struct.get(KernelInfoGetAllocator$LAYOUT, KernelInfoGetAllocator$OFFSET);
        return KernelInfoGetAllocator.invoke(funcPtr, _x0, _x1, _x2);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*AddExternalInitializersFromFilesInMemory)(OrtSessionOptions *, const char *const *, char *const *, const size_t *, size_t)
     * }
     */
    private static class AddExternalInitializersFromFilesInMemory {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, long _x4) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout AddExternalInitializersFromFilesInMemory$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("AddExternalInitializersFromFilesInMemory"));

    private static final long AddExternalInitializersFromFilesInMemory$OFFSET = $LAYOUT.byteOffset(groupElement("AddExternalInitializersFromFilesInMemory"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AddExternalInitializersFromFilesInMemory)(OrtSessionOptions *, const char *const *, char *const *, const size_t *, size_t)
     * }
     */
    public static MemorySegment AddExternalInitializersFromFilesInMemory(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, long _x4) {
        var funcPtr = struct.get(AddExternalInitializersFromFilesInMemory$LAYOUT, AddExternalInitializersFromFilesInMemory$OFFSET);
        return AddExternalInitializersFromFilesInMemory.invoke(funcPtr, _x0, _x1, _x2, _x3, _x4);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateLoraAdapter)(const char *, OrtAllocator *, OrtLoraAdapter **)
     * }
     */
    private static class CreateLoraAdapter {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CreateLoraAdapter$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CreateLoraAdapter"));

    private static final long CreateLoraAdapter$OFFSET = $LAYOUT.byteOffset(groupElement("CreateLoraAdapter"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateLoraAdapter)(const char *, OrtAllocator *, OrtLoraAdapter **)
     * }
     */
    public static MemorySegment CreateLoraAdapter(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
        var funcPtr = struct.get(CreateLoraAdapter$LAYOUT, CreateLoraAdapter$OFFSET);
        return CreateLoraAdapter.invoke(funcPtr, _x0, _x1, _x2);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateLoraAdapterFromArray)(const void *, size_t, OrtAllocator *, OrtLoraAdapter **)
     * }
     */
    private static class CreateLoraAdapterFromArray {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, long _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CreateLoraAdapterFromArray$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CreateLoraAdapterFromArray"));

    private static final long CreateLoraAdapterFromArray$OFFSET = $LAYOUT.byteOffset(groupElement("CreateLoraAdapterFromArray"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateLoraAdapterFromArray)(const void *, size_t, OrtAllocator *, OrtLoraAdapter **)
     * }
     */
    public static MemorySegment CreateLoraAdapterFromArray(MemorySegment struct, MemorySegment _x0, long _x1, MemorySegment _x2, MemorySegment _x3) {
        var funcPtr = struct.get(CreateLoraAdapterFromArray$LAYOUT, CreateLoraAdapterFromArray$OFFSET);
        return CreateLoraAdapterFromArray.invoke(funcPtr, _x0, _x1, _x2, _x3);
    }

    /**
     * {@snippet lang=c :
     * void (*ReleaseLoraAdapter)(OrtLoraAdapter *)
     * }
     */
    private static class ReleaseLoraAdapter {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ReleaseLoraAdapter$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ReleaseLoraAdapter"));

    private static final long ReleaseLoraAdapter$OFFSET = $LAYOUT.byteOffset(groupElement("ReleaseLoraAdapter"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * void (*ReleaseLoraAdapter)(OrtLoraAdapter *)
     * }
     */
    public static void ReleaseLoraAdapter(MemorySegment struct, MemorySegment _x0) {
        var funcPtr = struct.get(ReleaseLoraAdapter$LAYOUT, ReleaseLoraAdapter$OFFSET);
        ReleaseLoraAdapter.invoke(funcPtr, _x0);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsAddActiveLoraAdapter)(OrtRunOptions *, const OrtLoraAdapter *)
     * }
     */
    private static class RunOptionsAddActiveLoraAdapter {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout RunOptionsAddActiveLoraAdapter$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("RunOptionsAddActiveLoraAdapter"));

    private static final long RunOptionsAddActiveLoraAdapter$OFFSET = $LAYOUT.byteOffset(groupElement("RunOptionsAddActiveLoraAdapter"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsAddActiveLoraAdapter)(OrtRunOptions *, const OrtLoraAdapter *)
     * }
     */
    public static MemorySegment RunOptionsAddActiveLoraAdapter(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {
        var funcPtr = struct.get(RunOptionsAddActiveLoraAdapter$LAYOUT, RunOptionsAddActiveLoraAdapter$OFFSET);
        return RunOptionsAddActiveLoraAdapter.invoke(funcPtr, _x0, _x1);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SetEpDynamicOptions)(OrtSession *, const char *const *, const char *const *, size_t)
     * }
     */
    private static class SetEpDynamicOptions {

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG
        );

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SetEpDynamicOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SetEpDynamicOptions"));

    private static final long SetEpDynamicOptions$OFFSET = $LAYOUT.byteOffset(groupElement("SetEpDynamicOptions"));

    /**
     * Invoker for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetEpDynamicOptions)(OrtSession *, const char *const *, const char *const *, size_t)
     * }
     */
    public static MemorySegment SetEpDynamicOptions(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3) {
        var funcPtr = struct.get(SetEpDynamicOptions$LAYOUT, SetEpDynamicOptions$OFFSET);
        return SetEpDynamicOptions.invoke(funcPtr, _x0, _x1, _x2, _x3);
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index) {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this struct
     */
    public static long sizeof() { return layout().byteSize(); }

    /**
     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate(layout());
    }

    /**
     * Allocate an array of size {@code elementCount} using {@code allocator}.
     * The returned segment has size {@code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}

