// Generated by jextract

package oracle.code.onnx.foreign;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

/**
 * {@snippet lang=c :
 * struct OrtModelEditorApi {
 *     OrtStatusPtr (*CreateTensorTypeInfo)(const OrtTensorTypeAndShapeInfo *, OrtTypeInfo **);
 *     OrtStatusPtr (*CreateSparseTensorTypeInfo)(const OrtTensorTypeAndShapeInfo *, OrtTypeInfo **);
 *     OrtStatusPtr (*CreateMapTypeInfo)(ONNXTensorElementDataType, const OrtTypeInfo *, OrtTypeInfo **);
 *     OrtStatusPtr (*CreateSequenceTypeInfo)(const OrtTypeInfo *, OrtTypeInfo **);
 *     OrtStatusPtr (*CreateOptionalTypeInfo)(const OrtTypeInfo *, OrtTypeInfo **);
 *     OrtStatusPtr (*CreateValueInfo)(const char *, const OrtTypeInfo *, OrtValueInfo **);
 *     OrtStatusPtr (*CreateNode)(const char *, const char *, const char *, const char *const *, size_t, const char *const *, size_t, OrtOpAttr **, size_t, OrtNode **);
 *     OrtStatusPtr (*CreateGraph)(OrtGraph **);
 *     OrtStatusPtr (*SetGraphInputs)(OrtGraph *, OrtValueInfo **, size_t);
 *     OrtStatusPtr (*SetGraphOutputs)(OrtGraph *, OrtValueInfo **, size_t);
 *     OrtStatusPtr (*AddInitializerToGraph)(OrtGraph *, const char *, OrtValue *, bool);
 *     OrtStatusPtr (*AddNodeToGraph)(OrtGraph *, OrtNode *);
 *     OrtStatusPtr (*CreateModel)(const char *const *, const int *, size_t, OrtModel **);
 *     OrtStatusPtr (*AddGraphToModel)(OrtModel *, OrtGraph *);
 *     OrtStatusPtr (*CreateSessionFromModel)(const OrtEnv *, const OrtModel *, const OrtSessionOptions *, OrtSession **);
 *     OrtStatusPtr (*CreateModelEditorSession)(const OrtEnv *, const char *, const OrtSessionOptions *, OrtSession **);
 *     OrtStatusPtr (*CreateModelEditorSessionFromArray)(const OrtEnv *, const void *, size_t, const OrtSessionOptions *, OrtSession **);
 *     OrtStatusPtr (*SessionGetOpsetForDomain)(const OrtSession *, const char *, int *);
 *     OrtStatusPtr (*ApplyModelToModelEditorSession)(OrtSession *, OrtModel *);
 *     OrtStatusPtr (*FinalizeModelEditorSession)(OrtSession *, const OrtSessionOptions *, OrtPrepackedWeightsContainer *);
 * }
 * }
 */
public class OrtModelEditorApi {

    OrtModelEditorApi() {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
        onnxruntime_c_api_h.C_POINTER.withName("CreateTensorTypeInfo"),
        onnxruntime_c_api_h.C_POINTER.withName("CreateSparseTensorTypeInfo"),
        onnxruntime_c_api_h.C_POINTER.withName("CreateMapTypeInfo"),
        onnxruntime_c_api_h.C_POINTER.withName("CreateSequenceTypeInfo"),
        onnxruntime_c_api_h.C_POINTER.withName("CreateOptionalTypeInfo"),
        onnxruntime_c_api_h.C_POINTER.withName("CreateValueInfo"),
        onnxruntime_c_api_h.C_POINTER.withName("CreateNode"),
        onnxruntime_c_api_h.C_POINTER.withName("CreateGraph"),
        onnxruntime_c_api_h.C_POINTER.withName("SetGraphInputs"),
        onnxruntime_c_api_h.C_POINTER.withName("SetGraphOutputs"),
        onnxruntime_c_api_h.C_POINTER.withName("AddInitializerToGraph"),
        onnxruntime_c_api_h.C_POINTER.withName("AddNodeToGraph"),
        onnxruntime_c_api_h.C_POINTER.withName("CreateModel"),
        onnxruntime_c_api_h.C_POINTER.withName("AddGraphToModel"),
        onnxruntime_c_api_h.C_POINTER.withName("CreateSessionFromModel"),
        onnxruntime_c_api_h.C_POINTER.withName("CreateModelEditorSession"),
        onnxruntime_c_api_h.C_POINTER.withName("CreateModelEditorSessionFromArray"),
        onnxruntime_c_api_h.C_POINTER.withName("SessionGetOpsetForDomain"),
        onnxruntime_c_api_h.C_POINTER.withName("ApplyModelToModelEditorSession"),
        onnxruntime_c_api_h.C_POINTER.withName("FinalizeModelEditorSession")
    ).withName("OrtModelEditorApi");

    /**
     * The layout of this struct
     */
    public static final GroupLayout layout() {
        return $LAYOUT;
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateTensorTypeInfo)(const OrtTensorTypeAndShapeInfo *, OrtTypeInfo **)
     * }
     */
    public static class CreateTensorTypeInfo {

        CreateTensorTypeInfo() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(CreateTensorTypeInfo.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CreateTensorTypeInfo.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CreateTensorTypeInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CreateTensorTypeInfo"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateTensorTypeInfo)(const OrtTensorTypeAndShapeInfo *, OrtTypeInfo **)
     * }
     */
    public static final AddressLayout CreateTensorTypeInfo$layout() {
        return CreateTensorTypeInfo$LAYOUT;
    }

    private static final long CreateTensorTypeInfo$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateTensorTypeInfo)(const OrtTensorTypeAndShapeInfo *, OrtTypeInfo **)
     * }
     */
    public static final long CreateTensorTypeInfo$offset() {
        return CreateTensorTypeInfo$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateTensorTypeInfo)(const OrtTensorTypeAndShapeInfo *, OrtTypeInfo **)
     * }
     */
    public static MemorySegment CreateTensorTypeInfo(MemorySegment struct) {
        return struct.get(CreateTensorTypeInfo$LAYOUT, CreateTensorTypeInfo$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateTensorTypeInfo)(const OrtTensorTypeAndShapeInfo *, OrtTypeInfo **)
     * }
     */
    public static void CreateTensorTypeInfo(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CreateTensorTypeInfo$LAYOUT, CreateTensorTypeInfo$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSparseTensorTypeInfo)(const OrtTensorTypeAndShapeInfo *, OrtTypeInfo **)
     * }
     */
    public static class CreateSparseTensorTypeInfo {

        CreateSparseTensorTypeInfo() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(CreateSparseTensorTypeInfo.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CreateSparseTensorTypeInfo.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CreateSparseTensorTypeInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CreateSparseTensorTypeInfo"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSparseTensorTypeInfo)(const OrtTensorTypeAndShapeInfo *, OrtTypeInfo **)
     * }
     */
    public static final AddressLayout CreateSparseTensorTypeInfo$layout() {
        return CreateSparseTensorTypeInfo$LAYOUT;
    }

    private static final long CreateSparseTensorTypeInfo$OFFSET = 8;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSparseTensorTypeInfo)(const OrtTensorTypeAndShapeInfo *, OrtTypeInfo **)
     * }
     */
    public static final long CreateSparseTensorTypeInfo$offset() {
        return CreateSparseTensorTypeInfo$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSparseTensorTypeInfo)(const OrtTensorTypeAndShapeInfo *, OrtTypeInfo **)
     * }
     */
    public static MemorySegment CreateSparseTensorTypeInfo(MemorySegment struct) {
        return struct.get(CreateSparseTensorTypeInfo$LAYOUT, CreateSparseTensorTypeInfo$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSparseTensorTypeInfo)(const OrtTensorTypeAndShapeInfo *, OrtTypeInfo **)
     * }
     */
    public static void CreateSparseTensorTypeInfo(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CreateSparseTensorTypeInfo$LAYOUT, CreateSparseTensorTypeInfo$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateMapTypeInfo)(ONNXTensorElementDataType, const OrtTypeInfo *, OrtTypeInfo **)
     * }
     */
    public static class CreateMapTypeInfo {

        CreateMapTypeInfo() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(int _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_INT,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(CreateMapTypeInfo.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CreateMapTypeInfo.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,int _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CreateMapTypeInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CreateMapTypeInfo"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateMapTypeInfo)(ONNXTensorElementDataType, const OrtTypeInfo *, OrtTypeInfo **)
     * }
     */
    public static final AddressLayout CreateMapTypeInfo$layout() {
        return CreateMapTypeInfo$LAYOUT;
    }

    private static final long CreateMapTypeInfo$OFFSET = 16;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateMapTypeInfo)(ONNXTensorElementDataType, const OrtTypeInfo *, OrtTypeInfo **)
     * }
     */
    public static final long CreateMapTypeInfo$offset() {
        return CreateMapTypeInfo$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateMapTypeInfo)(ONNXTensorElementDataType, const OrtTypeInfo *, OrtTypeInfo **)
     * }
     */
    public static MemorySegment CreateMapTypeInfo(MemorySegment struct) {
        return struct.get(CreateMapTypeInfo$LAYOUT, CreateMapTypeInfo$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateMapTypeInfo)(ONNXTensorElementDataType, const OrtTypeInfo *, OrtTypeInfo **)
     * }
     */
    public static void CreateMapTypeInfo(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CreateMapTypeInfo$LAYOUT, CreateMapTypeInfo$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSequenceTypeInfo)(const OrtTypeInfo *, OrtTypeInfo **)
     * }
     */
    public static class CreateSequenceTypeInfo {

        CreateSequenceTypeInfo() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(CreateSequenceTypeInfo.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CreateSequenceTypeInfo.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CreateSequenceTypeInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CreateSequenceTypeInfo"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSequenceTypeInfo)(const OrtTypeInfo *, OrtTypeInfo **)
     * }
     */
    public static final AddressLayout CreateSequenceTypeInfo$layout() {
        return CreateSequenceTypeInfo$LAYOUT;
    }

    private static final long CreateSequenceTypeInfo$OFFSET = 24;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSequenceTypeInfo)(const OrtTypeInfo *, OrtTypeInfo **)
     * }
     */
    public static final long CreateSequenceTypeInfo$offset() {
        return CreateSequenceTypeInfo$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSequenceTypeInfo)(const OrtTypeInfo *, OrtTypeInfo **)
     * }
     */
    public static MemorySegment CreateSequenceTypeInfo(MemorySegment struct) {
        return struct.get(CreateSequenceTypeInfo$LAYOUT, CreateSequenceTypeInfo$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSequenceTypeInfo)(const OrtTypeInfo *, OrtTypeInfo **)
     * }
     */
    public static void CreateSequenceTypeInfo(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CreateSequenceTypeInfo$LAYOUT, CreateSequenceTypeInfo$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateOptionalTypeInfo)(const OrtTypeInfo *, OrtTypeInfo **)
     * }
     */
    public static class CreateOptionalTypeInfo {

        CreateOptionalTypeInfo() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(CreateOptionalTypeInfo.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CreateOptionalTypeInfo.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CreateOptionalTypeInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CreateOptionalTypeInfo"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateOptionalTypeInfo)(const OrtTypeInfo *, OrtTypeInfo **)
     * }
     */
    public static final AddressLayout CreateOptionalTypeInfo$layout() {
        return CreateOptionalTypeInfo$LAYOUT;
    }

    private static final long CreateOptionalTypeInfo$OFFSET = 32;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateOptionalTypeInfo)(const OrtTypeInfo *, OrtTypeInfo **)
     * }
     */
    public static final long CreateOptionalTypeInfo$offset() {
        return CreateOptionalTypeInfo$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateOptionalTypeInfo)(const OrtTypeInfo *, OrtTypeInfo **)
     * }
     */
    public static MemorySegment CreateOptionalTypeInfo(MemorySegment struct) {
        return struct.get(CreateOptionalTypeInfo$LAYOUT, CreateOptionalTypeInfo$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateOptionalTypeInfo)(const OrtTypeInfo *, OrtTypeInfo **)
     * }
     */
    public static void CreateOptionalTypeInfo(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CreateOptionalTypeInfo$LAYOUT, CreateOptionalTypeInfo$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateValueInfo)(const char *, const OrtTypeInfo *, OrtValueInfo **)
     * }
     */
    public static class CreateValueInfo {

        CreateValueInfo() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(CreateValueInfo.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CreateValueInfo.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CreateValueInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CreateValueInfo"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateValueInfo)(const char *, const OrtTypeInfo *, OrtValueInfo **)
     * }
     */
    public static final AddressLayout CreateValueInfo$layout() {
        return CreateValueInfo$LAYOUT;
    }

    private static final long CreateValueInfo$OFFSET = 40;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateValueInfo)(const char *, const OrtTypeInfo *, OrtValueInfo **)
     * }
     */
    public static final long CreateValueInfo$offset() {
        return CreateValueInfo$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateValueInfo)(const char *, const OrtTypeInfo *, OrtValueInfo **)
     * }
     */
    public static MemorySegment CreateValueInfo(MemorySegment struct) {
        return struct.get(CreateValueInfo$LAYOUT, CreateValueInfo$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateValueInfo)(const char *, const OrtTypeInfo *, OrtValueInfo **)
     * }
     */
    public static void CreateValueInfo(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CreateValueInfo$LAYOUT, CreateValueInfo$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateNode)(const char *, const char *, const char *, const char *const *, size_t, const char *const *, size_t, OrtOpAttr **, size_t, OrtNode **)
     * }
     */
    public static class CreateNode {

        CreateNode() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, long _x4, MemorySegment _x5, long _x6, MemorySegment _x7, long _x8, MemorySegment _x9);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(CreateNode.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CreateNode.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, long _x4, MemorySegment _x5, long _x6, MemorySegment _x7, long _x8, MemorySegment _x9) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6, _x7, _x8, _x9);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CreateNode$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CreateNode"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateNode)(const char *, const char *, const char *, const char *const *, size_t, const char *const *, size_t, OrtOpAttr **, size_t, OrtNode **)
     * }
     */
    public static final AddressLayout CreateNode$layout() {
        return CreateNode$LAYOUT;
    }

    private static final long CreateNode$OFFSET = 48;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateNode)(const char *, const char *, const char *, const char *const *, size_t, const char *const *, size_t, OrtOpAttr **, size_t, OrtNode **)
     * }
     */
    public static final long CreateNode$offset() {
        return CreateNode$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateNode)(const char *, const char *, const char *, const char *const *, size_t, const char *const *, size_t, OrtOpAttr **, size_t, OrtNode **)
     * }
     */
    public static MemorySegment CreateNode(MemorySegment struct) {
        return struct.get(CreateNode$LAYOUT, CreateNode$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateNode)(const char *, const char *, const char *, const char *const *, size_t, const char *const *, size_t, OrtOpAttr **, size_t, OrtNode **)
     * }
     */
    public static void CreateNode(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CreateNode$LAYOUT, CreateNode$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateGraph)(OrtGraph **)
     * }
     */
    public static class CreateGraph {

        CreateGraph() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(CreateGraph.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CreateGraph.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CreateGraph$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CreateGraph"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateGraph)(OrtGraph **)
     * }
     */
    public static final AddressLayout CreateGraph$layout() {
        return CreateGraph$LAYOUT;
    }

    private static final long CreateGraph$OFFSET = 56;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateGraph)(OrtGraph **)
     * }
     */
    public static final long CreateGraph$offset() {
        return CreateGraph$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateGraph)(OrtGraph **)
     * }
     */
    public static MemorySegment CreateGraph(MemorySegment struct) {
        return struct.get(CreateGraph$LAYOUT, CreateGraph$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateGraph)(OrtGraph **)
     * }
     */
    public static void CreateGraph(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CreateGraph$LAYOUT, CreateGraph$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGraphInputs)(OrtGraph *, OrtValueInfo **, size_t)
     * }
     */
    public static class SetGraphInputs {

        SetGraphInputs() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, long _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(SetGraphInputs.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SetGraphInputs.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SetGraphInputs$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SetGraphInputs"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGraphInputs)(OrtGraph *, OrtValueInfo **, size_t)
     * }
     */
    public static final AddressLayout SetGraphInputs$layout() {
        return SetGraphInputs$LAYOUT;
    }

    private static final long SetGraphInputs$OFFSET = 64;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGraphInputs)(OrtGraph *, OrtValueInfo **, size_t)
     * }
     */
    public static final long SetGraphInputs$offset() {
        return SetGraphInputs$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGraphInputs)(OrtGraph *, OrtValueInfo **, size_t)
     * }
     */
    public static MemorySegment SetGraphInputs(MemorySegment struct) {
        return struct.get(SetGraphInputs$LAYOUT, SetGraphInputs$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGraphInputs)(OrtGraph *, OrtValueInfo **, size_t)
     * }
     */
    public static void SetGraphInputs(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SetGraphInputs$LAYOUT, SetGraphInputs$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGraphOutputs)(OrtGraph *, OrtValueInfo **, size_t)
     * }
     */
    public static class SetGraphOutputs {

        SetGraphOutputs() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, long _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(SetGraphOutputs.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SetGraphOutputs.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SetGraphOutputs$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SetGraphOutputs"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGraphOutputs)(OrtGraph *, OrtValueInfo **, size_t)
     * }
     */
    public static final AddressLayout SetGraphOutputs$layout() {
        return SetGraphOutputs$LAYOUT;
    }

    private static final long SetGraphOutputs$OFFSET = 72;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGraphOutputs)(OrtGraph *, OrtValueInfo **, size_t)
     * }
     */
    public static final long SetGraphOutputs$offset() {
        return SetGraphOutputs$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGraphOutputs)(OrtGraph *, OrtValueInfo **, size_t)
     * }
     */
    public static MemorySegment SetGraphOutputs(MemorySegment struct) {
        return struct.get(SetGraphOutputs$LAYOUT, SetGraphOutputs$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGraphOutputs)(OrtGraph *, OrtValueInfo **, size_t)
     * }
     */
    public static void SetGraphOutputs(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SetGraphOutputs$LAYOUT, SetGraphOutputs$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*AddInitializerToGraph)(OrtGraph *, const char *, OrtValue *, bool)
     * }
     */
    public static class AddInitializerToGraph {

        AddInitializerToGraph() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, boolean _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_BOOL
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(AddInitializerToGraph.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(AddInitializerToGraph.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, boolean _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout AddInitializerToGraph$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("AddInitializerToGraph"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AddInitializerToGraph)(OrtGraph *, const char *, OrtValue *, bool)
     * }
     */
    public static final AddressLayout AddInitializerToGraph$layout() {
        return AddInitializerToGraph$LAYOUT;
    }

    private static final long AddInitializerToGraph$OFFSET = 80;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AddInitializerToGraph)(OrtGraph *, const char *, OrtValue *, bool)
     * }
     */
    public static final long AddInitializerToGraph$offset() {
        return AddInitializerToGraph$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AddInitializerToGraph)(OrtGraph *, const char *, OrtValue *, bool)
     * }
     */
    public static MemorySegment AddInitializerToGraph(MemorySegment struct) {
        return struct.get(AddInitializerToGraph$LAYOUT, AddInitializerToGraph$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AddInitializerToGraph)(OrtGraph *, const char *, OrtValue *, bool)
     * }
     */
    public static void AddInitializerToGraph(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(AddInitializerToGraph$LAYOUT, AddInitializerToGraph$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*AddNodeToGraph)(OrtGraph *, OrtNode *)
     * }
     */
    public static class AddNodeToGraph {

        AddNodeToGraph() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(AddNodeToGraph.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(AddNodeToGraph.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout AddNodeToGraph$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("AddNodeToGraph"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AddNodeToGraph)(OrtGraph *, OrtNode *)
     * }
     */
    public static final AddressLayout AddNodeToGraph$layout() {
        return AddNodeToGraph$LAYOUT;
    }

    private static final long AddNodeToGraph$OFFSET = 88;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AddNodeToGraph)(OrtGraph *, OrtNode *)
     * }
     */
    public static final long AddNodeToGraph$offset() {
        return AddNodeToGraph$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AddNodeToGraph)(OrtGraph *, OrtNode *)
     * }
     */
    public static MemorySegment AddNodeToGraph(MemorySegment struct) {
        return struct.get(AddNodeToGraph$LAYOUT, AddNodeToGraph$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AddNodeToGraph)(OrtGraph *, OrtNode *)
     * }
     */
    public static void AddNodeToGraph(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(AddNodeToGraph$LAYOUT, AddNodeToGraph$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateModel)(const char *const *, const int *, size_t, OrtModel **)
     * }
     */
    public static class CreateModel {

        CreateModel() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(CreateModel.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CreateModel.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CreateModel$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CreateModel"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateModel)(const char *const *, const int *, size_t, OrtModel **)
     * }
     */
    public static final AddressLayout CreateModel$layout() {
        return CreateModel$LAYOUT;
    }

    private static final long CreateModel$OFFSET = 96;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateModel)(const char *const *, const int *, size_t, OrtModel **)
     * }
     */
    public static final long CreateModel$offset() {
        return CreateModel$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateModel)(const char *const *, const int *, size_t, OrtModel **)
     * }
     */
    public static MemorySegment CreateModel(MemorySegment struct) {
        return struct.get(CreateModel$LAYOUT, CreateModel$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateModel)(const char *const *, const int *, size_t, OrtModel **)
     * }
     */
    public static void CreateModel(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CreateModel$LAYOUT, CreateModel$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*AddGraphToModel)(OrtModel *, OrtGraph *)
     * }
     */
    public static class AddGraphToModel {

        AddGraphToModel() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(AddGraphToModel.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(AddGraphToModel.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout AddGraphToModel$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("AddGraphToModel"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AddGraphToModel)(OrtModel *, OrtGraph *)
     * }
     */
    public static final AddressLayout AddGraphToModel$layout() {
        return AddGraphToModel$LAYOUT;
    }

    private static final long AddGraphToModel$OFFSET = 104;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AddGraphToModel)(OrtModel *, OrtGraph *)
     * }
     */
    public static final long AddGraphToModel$offset() {
        return AddGraphToModel$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AddGraphToModel)(OrtModel *, OrtGraph *)
     * }
     */
    public static MemorySegment AddGraphToModel(MemorySegment struct) {
        return struct.get(AddGraphToModel$LAYOUT, AddGraphToModel$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AddGraphToModel)(OrtModel *, OrtGraph *)
     * }
     */
    public static void AddGraphToModel(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(AddGraphToModel$LAYOUT, AddGraphToModel$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSessionFromModel)(const OrtEnv *, const OrtModel *, const OrtSessionOptions *, OrtSession **)
     * }
     */
    public static class CreateSessionFromModel {

        CreateSessionFromModel() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(CreateSessionFromModel.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CreateSessionFromModel.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CreateSessionFromModel$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CreateSessionFromModel"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSessionFromModel)(const OrtEnv *, const OrtModel *, const OrtSessionOptions *, OrtSession **)
     * }
     */
    public static final AddressLayout CreateSessionFromModel$layout() {
        return CreateSessionFromModel$LAYOUT;
    }

    private static final long CreateSessionFromModel$OFFSET = 112;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSessionFromModel)(const OrtEnv *, const OrtModel *, const OrtSessionOptions *, OrtSession **)
     * }
     */
    public static final long CreateSessionFromModel$offset() {
        return CreateSessionFromModel$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSessionFromModel)(const OrtEnv *, const OrtModel *, const OrtSessionOptions *, OrtSession **)
     * }
     */
    public static MemorySegment CreateSessionFromModel(MemorySegment struct) {
        return struct.get(CreateSessionFromModel$LAYOUT, CreateSessionFromModel$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSessionFromModel)(const OrtEnv *, const OrtModel *, const OrtSessionOptions *, OrtSession **)
     * }
     */
    public static void CreateSessionFromModel(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CreateSessionFromModel$LAYOUT, CreateSessionFromModel$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateModelEditorSession)(const OrtEnv *, const char *, const OrtSessionOptions *, OrtSession **)
     * }
     */
    public static class CreateModelEditorSession {

        CreateModelEditorSession() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(CreateModelEditorSession.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CreateModelEditorSession.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CreateModelEditorSession$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CreateModelEditorSession"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateModelEditorSession)(const OrtEnv *, const char *, const OrtSessionOptions *, OrtSession **)
     * }
     */
    public static final AddressLayout CreateModelEditorSession$layout() {
        return CreateModelEditorSession$LAYOUT;
    }

    private static final long CreateModelEditorSession$OFFSET = 120;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateModelEditorSession)(const OrtEnv *, const char *, const OrtSessionOptions *, OrtSession **)
     * }
     */
    public static final long CreateModelEditorSession$offset() {
        return CreateModelEditorSession$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateModelEditorSession)(const OrtEnv *, const char *, const OrtSessionOptions *, OrtSession **)
     * }
     */
    public static MemorySegment CreateModelEditorSession(MemorySegment struct) {
        return struct.get(CreateModelEditorSession$LAYOUT, CreateModelEditorSession$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateModelEditorSession)(const OrtEnv *, const char *, const OrtSessionOptions *, OrtSession **)
     * }
     */
    public static void CreateModelEditorSession(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CreateModelEditorSession$LAYOUT, CreateModelEditorSession$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateModelEditorSessionFromArray)(const OrtEnv *, const void *, size_t, const OrtSessionOptions *, OrtSession **)
     * }
     */
    public static class CreateModelEditorSessionFromArray {

        CreateModelEditorSessionFromArray() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3, MemorySegment _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_LONG,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(CreateModelEditorSessionFromArray.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CreateModelEditorSessionFromArray.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3, MemorySegment _x4) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CreateModelEditorSessionFromArray$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CreateModelEditorSessionFromArray"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateModelEditorSessionFromArray)(const OrtEnv *, const void *, size_t, const OrtSessionOptions *, OrtSession **)
     * }
     */
    public static final AddressLayout CreateModelEditorSessionFromArray$layout() {
        return CreateModelEditorSessionFromArray$LAYOUT;
    }

    private static final long CreateModelEditorSessionFromArray$OFFSET = 128;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateModelEditorSessionFromArray)(const OrtEnv *, const void *, size_t, const OrtSessionOptions *, OrtSession **)
     * }
     */
    public static final long CreateModelEditorSessionFromArray$offset() {
        return CreateModelEditorSessionFromArray$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateModelEditorSessionFromArray)(const OrtEnv *, const void *, size_t, const OrtSessionOptions *, OrtSession **)
     * }
     */
    public static MemorySegment CreateModelEditorSessionFromArray(MemorySegment struct) {
        return struct.get(CreateModelEditorSessionFromArray$LAYOUT, CreateModelEditorSessionFromArray$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateModelEditorSessionFromArray)(const OrtEnv *, const void *, size_t, const OrtSessionOptions *, OrtSession **)
     * }
     */
    public static void CreateModelEditorSessionFromArray(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CreateModelEditorSessionFromArray$LAYOUT, CreateModelEditorSessionFromArray$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetOpsetForDomain)(const OrtSession *, const char *, int *)
     * }
     */
    public static class SessionGetOpsetForDomain {

        SessionGetOpsetForDomain() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(SessionGetOpsetForDomain.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SessionGetOpsetForDomain.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SessionGetOpsetForDomain$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SessionGetOpsetForDomain"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetOpsetForDomain)(const OrtSession *, const char *, int *)
     * }
     */
    public static final AddressLayout SessionGetOpsetForDomain$layout() {
        return SessionGetOpsetForDomain$LAYOUT;
    }

    private static final long SessionGetOpsetForDomain$OFFSET = 136;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetOpsetForDomain)(const OrtSession *, const char *, int *)
     * }
     */
    public static final long SessionGetOpsetForDomain$offset() {
        return SessionGetOpsetForDomain$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetOpsetForDomain)(const OrtSession *, const char *, int *)
     * }
     */
    public static MemorySegment SessionGetOpsetForDomain(MemorySegment struct) {
        return struct.get(SessionGetOpsetForDomain$LAYOUT, SessionGetOpsetForDomain$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetOpsetForDomain)(const OrtSession *, const char *, int *)
     * }
     */
    public static void SessionGetOpsetForDomain(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SessionGetOpsetForDomain$LAYOUT, SessionGetOpsetForDomain$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*ApplyModelToModelEditorSession)(OrtSession *, OrtModel *)
     * }
     */
    public static class ApplyModelToModelEditorSession {

        ApplyModelToModelEditorSession() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(ApplyModelToModelEditorSession.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ApplyModelToModelEditorSession.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ApplyModelToModelEditorSession$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ApplyModelToModelEditorSession"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ApplyModelToModelEditorSession)(OrtSession *, OrtModel *)
     * }
     */
    public static final AddressLayout ApplyModelToModelEditorSession$layout() {
        return ApplyModelToModelEditorSession$LAYOUT;
    }

    private static final long ApplyModelToModelEditorSession$OFFSET = 144;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ApplyModelToModelEditorSession)(OrtSession *, OrtModel *)
     * }
     */
    public static final long ApplyModelToModelEditorSession$offset() {
        return ApplyModelToModelEditorSession$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ApplyModelToModelEditorSession)(OrtSession *, OrtModel *)
     * }
     */
    public static MemorySegment ApplyModelToModelEditorSession(MemorySegment struct) {
        return struct.get(ApplyModelToModelEditorSession$LAYOUT, ApplyModelToModelEditorSession$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ApplyModelToModelEditorSession)(OrtSession *, OrtModel *)
     * }
     */
    public static void ApplyModelToModelEditorSession(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ApplyModelToModelEditorSession$LAYOUT, ApplyModelToModelEditorSession$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*FinalizeModelEditorSession)(OrtSession *, const OrtSessionOptions *, OrtPrepackedWeightsContainer *)
     * }
     */
    public static class FinalizeModelEditorSession {

        FinalizeModelEditorSession() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER,
            onnxruntime_c_api_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(FinalizeModelEditorSession.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(FinalizeModelEditorSession.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout FinalizeModelEditorSession$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("FinalizeModelEditorSession"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*FinalizeModelEditorSession)(OrtSession *, const OrtSessionOptions *, OrtPrepackedWeightsContainer *)
     * }
     */
    public static final AddressLayout FinalizeModelEditorSession$layout() {
        return FinalizeModelEditorSession$LAYOUT;
    }

    private static final long FinalizeModelEditorSession$OFFSET = 152;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*FinalizeModelEditorSession)(OrtSession *, const OrtSessionOptions *, OrtPrepackedWeightsContainer *)
     * }
     */
    public static final long FinalizeModelEditorSession$offset() {
        return FinalizeModelEditorSession$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*FinalizeModelEditorSession)(OrtSession *, const OrtSessionOptions *, OrtPrepackedWeightsContainer *)
     * }
     */
    public static MemorySegment FinalizeModelEditorSession(MemorySegment struct) {
        return struct.get(FinalizeModelEditorSession$LAYOUT, FinalizeModelEditorSession$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*FinalizeModelEditorSession)(OrtSession *, const OrtSessionOptions *, OrtPrepackedWeightsContainer *)
     * }
     */
    public static void FinalizeModelEditorSession(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(FinalizeModelEditorSession$LAYOUT, FinalizeModelEditorSession$OFFSET, fieldValue);
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index) {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this struct
     */
    public static long sizeof() { return layout().byteSize(); }

    /**
     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate(layout());
    }

    /**
     * Allocate an array of size {@code elementCount} using {@code allocator}.
     * The returned segment has size {@code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}

