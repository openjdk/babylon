/*
 * Copyright (c) 2025, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the "Classpath" exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
// Auto-generated from ONNX op schema

package oracle.code.onnx.ir;

import jdk.incubator.code.*;
import jdk.incubator.code.extern.ExternalizedOp;
import jdk.incubator.code.extern.OpFactory;

import java.util.*;
import oracle.code.onnx.Tensor;

@SuppressWarnings({"OptionalUsedAsFieldOrParameterType", "unused", "SequencedCollectionMethodCanBeUsed"})
public final class OnnxOps extends ExplicitOnnxOps {

    private OnnxOps() {}

    @OpFactoryHelper.OpDeclaration(Abs.NAME)
    public static final class Abs extends OnnxOp {
        public static final String NAME = "Abs";

        public enum Attribute implements OnnxAttribute.None { }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public Abs(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        Abs(Abs that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public Abs transform(CopyContext cc, OpTransformer ot) {
            return new Abs(this, cc);
        }

        Abs(TypeElement resultType, Value X) {
            super(SCHEMA, resultType, Set.of(), List.of(X), List.of());
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X()));
        }

        public Value X() {
            return operands().get(0);
        }

    }

    public static Abs Abs(TypeElement resultType, Value X) {
        return new Abs(resultType, X);
    }

    @OpFactoryHelper.OpDeclaration(Acos.NAME)
    public static final class Acos extends OnnxOp {
        public static final String NAME = "Acos";

        public enum Attribute implements OnnxAttribute.None { }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            input(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public Acos(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        Acos(Acos that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public Acos transform(CopyContext cc, OpTransformer ot) {
            return new Acos(this, cc);
        }

        Acos(TypeElement resultType, Value input) {
            super(SCHEMA, resultType, Set.of(), List.of(input), List.of());
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(input()));
        }

        public Value input() {
            return operands().get(0);
        }

    }

    public static Acos Acos(TypeElement resultType, Value input) {
        return new Acos(resultType, input);
    }

    @OpFactoryHelper.OpDeclaration(Acosh.NAME)
    public static final class Acosh extends OnnxOp {
        public static final String NAME = "Acosh";

        public enum Attribute implements OnnxAttribute.None { }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            input(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public Acosh(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        Acosh(Acosh that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public Acosh transform(CopyContext cc, OpTransformer ot) {
            return new Acosh(this, cc);
        }

        Acosh(TypeElement resultType, Value input) {
            super(SCHEMA, resultType, Set.of(), List.of(input), List.of());
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(input()));
        }

        public Value input() {
            return operands().get(0);
        }

    }

    public static Acosh Acosh(TypeElement resultType, Value input) {
        return new Acosh(resultType, input);
    }

    @OpFactoryHelper.OpDeclaration(Adagrad.NAME)
    public static final class Adagrad extends OnnxOp {
        public static final String NAME = "Adagrad";

        public enum Attribute implements OnnxAttribute {
            epsilon(Float.class, true, 1.0E-6f),
            decay_factor(Float.class, true, 0.0f),
            norm_coefficient(Float.class, true, 0.0f),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T1(new OnnxType.TypeVariable("T1", List.of(OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),
            T2(new OnnxType.TypeVariable("T2", List.of(OnnxType.tensor(OnnxType.int64())))),
            T3(new OnnxType.TypeVariable("T3", List.of(OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            R(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            T(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),
            inputs(TypeConstraint.T3.typeVariable(), Quantifier.VARIADIC),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            outputs(TypeConstraint.T3.typeVariable(), Quantifier.VARIADIC),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public Adagrad(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        Adagrad(Adagrad that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public Adagrad transform(CopyContext cc, OpTransformer ot) {
            return new Adagrad(this, cc);
        }

        Adagrad(TypeElement resultType, Value R, Value T, List<Value> inputs, java.util.Optional<Float> epsilon, java.util.Optional<Float> decay_factor, java.util.Optional<Float> norm_coefficient) {
            super(SCHEMA, resultType, Set.of(), List.of(R, T, inputs), List.of(epsilon, decay_factor, norm_coefficient));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(R(), T(), inputs()));
        }

        public Value R() {
            return operands().get(0);
        }

        public Value T() {
            return operands().get(1);
        }

        public List<Value> inputs() {
            return operands().subList(2, operands().size());
        }

        public java.util.Optional<Float> epsilon() {
            Float epsilon = Attribute.epsilon.access(Float.class, onnxAttributes);
            return java.util.Optional.ofNullable(epsilon);
        }

        public java.util.Optional<Float> decay_factor() {
            Float decay_factor = Attribute.decay_factor.access(Float.class, onnxAttributes);
            return java.util.Optional.ofNullable(decay_factor);
        }

        public java.util.Optional<Float> norm_coefficient() {
            Float norm_coefficient = Attribute.norm_coefficient.access(Float.class, onnxAttributes);
            return java.util.Optional.ofNullable(norm_coefficient);
        }

    }

    public static Adagrad Adagrad(TypeElement resultType, Value R, Value T, List<Value> inputs, java.util.Optional<Float> epsilon, java.util.Optional<Float> decay_factor, java.util.Optional<Float> norm_coefficient) {
        return new Adagrad(resultType, R, T, inputs, epsilon, decay_factor, norm_coefficient);
    }

    @OpFactoryHelper.OpDeclaration(Adam.NAME)
    public static final class Adam extends OnnxOp {
        public static final String NAME = "Adam";

        public enum Attribute implements OnnxAttribute {
            epsilon(Float.class, true, 1.0E-6f),
            norm_coefficient_post(Float.class, true, 0.0f),
            norm_coefficient(Float.class, true, 0.0f),
            alpha(Float.class, true, 0.9f),
            beta(Float.class, true, 0.999f),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T1(new OnnxType.TypeVariable("T1", List.of(OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),
            T2(new OnnxType.TypeVariable("T2", List.of(OnnxType.tensor(OnnxType.int64())))),
            T3(new OnnxType.TypeVariable("T3", List.of(OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            R(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            T(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),
            inputs(TypeConstraint.T3.typeVariable(), Quantifier.VARIADIC),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            outputs(TypeConstraint.T3.typeVariable(), Quantifier.VARIADIC),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public Adam(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        Adam(Adam that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public Adam transform(CopyContext cc, OpTransformer ot) {
            return new Adam(this, cc);
        }

        Adam(TypeElement resultType, Value R, Value T, List<Value> inputs, java.util.Optional<Float> epsilon, java.util.Optional<Float> norm_coefficient_post, java.util.Optional<Float> norm_coefficient, java.util.Optional<Float> alpha, java.util.Optional<Float> beta) {
            super(SCHEMA, resultType, Set.of(), List.of(R, T, inputs), List.of(epsilon, norm_coefficient_post, norm_coefficient, alpha, beta));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(R(), T(), inputs()));
        }

        public Value R() {
            return operands().get(0);
        }

        public Value T() {
            return operands().get(1);
        }

        public List<Value> inputs() {
            return operands().subList(2, operands().size());
        }

        public java.util.Optional<Float> epsilon() {
            Float epsilon = Attribute.epsilon.access(Float.class, onnxAttributes);
            return java.util.Optional.ofNullable(epsilon);
        }

        public java.util.Optional<Float> norm_coefficient_post() {
            Float norm_coefficient_post = Attribute.norm_coefficient_post.access(Float.class, onnxAttributes);
            return java.util.Optional.ofNullable(norm_coefficient_post);
        }

        public java.util.Optional<Float> norm_coefficient() {
            Float norm_coefficient = Attribute.norm_coefficient.access(Float.class, onnxAttributes);
            return java.util.Optional.ofNullable(norm_coefficient);
        }

        public java.util.Optional<Float> alpha() {
            Float alpha = Attribute.alpha.access(Float.class, onnxAttributes);
            return java.util.Optional.ofNullable(alpha);
        }

        public java.util.Optional<Float> beta() {
            Float beta = Attribute.beta.access(Float.class, onnxAttributes);
            return java.util.Optional.ofNullable(beta);
        }

    }

    public static Adam Adam(TypeElement resultType, Value R, Value T, List<Value> inputs, java.util.Optional<Float> epsilon, java.util.Optional<Float> norm_coefficient_post, java.util.Optional<Float> norm_coefficient, java.util.Optional<Float> alpha, java.util.Optional<Float> beta) {
        return new Adam(resultType, R, T, inputs, epsilon, norm_coefficient_post, norm_coefficient, alpha, beta);
    }

    @OpFactoryHelper.OpDeclaration(Add.NAME)
    public static final class Add extends OnnxOp {
        public static final String NAME = "Add";

        public enum Attribute implements OnnxAttribute.None { }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            A(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            B(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            C(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public Add(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        Add(Add that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public Add transform(CopyContext cc, OpTransformer ot) {
            return new Add(this, cc);
        }

        Add(TypeElement resultType, Value A, Value B) {
            super(SCHEMA, resultType, Set.of(), List.of(A, B), List.of());
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(A(), B()));
        }

        public Value A() {
            return operands().get(0);
        }

        public Value B() {
            return operands().get(1);
        }

    }

    public static Add Add(TypeElement resultType, Value A, Value B) {
        return new Add(resultType, A, B);
    }

    @OpFactoryHelper.OpDeclaration(AffineGrid.NAME)
    public static final class AffineGrid extends OnnxOp {
        public static final String NAME = "AffineGrid";

        public enum Attribute implements OnnxAttribute {
            align_corners(Long.class, true, 0),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T1(new OnnxType.TypeVariable("T1", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),
            T2(new OnnxType.TypeVariable("T2", List.of(OnnxType.tensor(OnnxType.int64())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            theta(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            size(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            grid(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public AffineGrid(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        AffineGrid(AffineGrid that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public AffineGrid transform(CopyContext cc, OpTransformer ot) {
            return new AffineGrid(this, cc);
        }

        AffineGrid(TypeElement resultType, Value theta, Value size, java.util.Optional<Long> align_corners) {
            super(SCHEMA, resultType, Set.of(), List.of(theta, size), List.of(align_corners));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(theta(), size()));
        }

        public Value theta() {
            return operands().get(0);
        }

        public Value size() {
            return operands().get(1);
        }

        public java.util.Optional<Long> align_corners() {
            Long align_corners = Attribute.align_corners.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(align_corners);
        }

    }

    public static AffineGrid AffineGrid(TypeElement resultType, Value theta, Value size, java.util.Optional<Long> align_corners) {
        return new AffineGrid(resultType, theta, size, align_corners);
    }

    @OpFactoryHelper.OpDeclaration(And.NAME)
    public static final class And extends OnnxOp {
        public static final String NAME = "And";

        public enum Attribute implements OnnxAttribute.None { }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.bool())))),
            T1(new OnnxType.TypeVariable("T1", List.of(OnnxType.tensor(OnnxType.bool())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            A(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            B(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            C(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public And(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        And(And that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public And transform(CopyContext cc, OpTransformer ot) {
            return new And(this, cc);
        }

        And(TypeElement resultType, Value A, Value B) {
            super(SCHEMA, resultType, Set.of(), List.of(A, B), List.of());
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(A(), B()));
        }

        public Value A() {
            return operands().get(0);
        }

        public Value B() {
            return operands().get(1);
        }

    }

    public static And And(TypeElement resultType, Value A, Value B) {
        return new And(resultType, A, B);
    }

    @OpFactoryHelper.OpDeclaration(ArgMax.NAME)
    public static final class ArgMax extends OnnxOp {
        public static final String NAME = "ArgMax";

        public enum Attribute implements OnnxAttribute {
            keepdims(Long.class, true, 1),
            select_last_index(Long.class, true, 0),
            axis(Long.class, true, 0),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            data(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            reduced(OnnxType.tensor(OnnxType.int64()), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public ArgMax(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        ArgMax(ArgMax that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public ArgMax transform(CopyContext cc, OpTransformer ot) {
            return new ArgMax(this, cc);
        }

        ArgMax(TypeElement resultType, Value data, java.util.Optional<Long> keepdims, java.util.Optional<Long> select_last_index, java.util.Optional<Long> axis) {
            super(SCHEMA, resultType, Set.of(), List.of(data), List.of(keepdims, select_last_index, axis));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(data()));
        }

        public Value data() {
            return operands().get(0);
        }

        public java.util.Optional<Long> keepdims() {
            Long keepdims = Attribute.keepdims.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(keepdims);
        }

        public java.util.Optional<Long> select_last_index() {
            Long select_last_index = Attribute.select_last_index.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(select_last_index);
        }

        public java.util.Optional<Long> axis() {
            Long axis = Attribute.axis.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(axis);
        }

    }

    public static ArgMax ArgMax(TypeElement resultType, Value data, java.util.Optional<Long> keepdims, java.util.Optional<Long> select_last_index, java.util.Optional<Long> axis) {
        return new ArgMax(resultType, data, keepdims, select_last_index, axis);
    }

    @OpFactoryHelper.OpDeclaration(ArgMin.NAME)
    public static final class ArgMin extends OnnxOp {
        public static final String NAME = "ArgMin";

        public enum Attribute implements OnnxAttribute {
            keepdims(Long.class, true, 1),
            select_last_index(Long.class, true, 0),
            axis(Long.class, true, 0),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            data(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            reduced(OnnxType.tensor(OnnxType.int64()), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public ArgMin(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        ArgMin(ArgMin that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public ArgMin transform(CopyContext cc, OpTransformer ot) {
            return new ArgMin(this, cc);
        }

        ArgMin(TypeElement resultType, Value data, java.util.Optional<Long> keepdims, java.util.Optional<Long> select_last_index, java.util.Optional<Long> axis) {
            super(SCHEMA, resultType, Set.of(), List.of(data), List.of(keepdims, select_last_index, axis));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(data()));
        }

        public Value data() {
            return operands().get(0);
        }

        public java.util.Optional<Long> keepdims() {
            Long keepdims = Attribute.keepdims.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(keepdims);
        }

        public java.util.Optional<Long> select_last_index() {
            Long select_last_index = Attribute.select_last_index.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(select_last_index);
        }

        public java.util.Optional<Long> axis() {
            Long axis = Attribute.axis.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(axis);
        }

    }

    public static ArgMin ArgMin(TypeElement resultType, Value data, java.util.Optional<Long> keepdims, java.util.Optional<Long> select_last_index, java.util.Optional<Long> axis) {
        return new ArgMin(resultType, data, keepdims, select_last_index, axis);
    }

    @OpFactoryHelper.OpDeclaration(ArrayFeatureExtractor.NAME)
    public static final class ArrayFeatureExtractor extends OnnxOp {
        public static final String NAME = "ArrayFeatureExtractor";

        public enum Attribute implements OnnxAttribute.None { }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.string())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            Y(OnnxType.tensor(OnnxType.int64()), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            Z(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public ArrayFeatureExtractor(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        ArrayFeatureExtractor(ArrayFeatureExtractor that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public ArrayFeatureExtractor transform(CopyContext cc, OpTransformer ot) {
            return new ArrayFeatureExtractor(this, cc);
        }

        ArrayFeatureExtractor(TypeElement resultType, Value X, Value Y) {
            super(SCHEMA, resultType, Set.of(), List.of(X, Y), List.of());
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X(), Y()));
        }

        public Value X() {
            return operands().get(0);
        }

        public Value Y() {
            return operands().get(1);
        }

    }

    public static ArrayFeatureExtractor ArrayFeatureExtractor(TypeElement resultType, Value X, Value Y) {
        return new ArrayFeatureExtractor(resultType, X, Y);
    }

    @OpFactoryHelper.OpDeclaration(Asin.NAME)
    public static final class Asin extends OnnxOp {
        public static final String NAME = "Asin";

        public enum Attribute implements OnnxAttribute.None { }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            input(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public Asin(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        Asin(Asin that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public Asin transform(CopyContext cc, OpTransformer ot) {
            return new Asin(this, cc);
        }

        Asin(TypeElement resultType, Value input) {
            super(SCHEMA, resultType, Set.of(), List.of(input), List.of());
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(input()));
        }

        public Value input() {
            return operands().get(0);
        }

    }

    public static Asin Asin(TypeElement resultType, Value input) {
        return new Asin(resultType, input);
    }

    @OpFactoryHelper.OpDeclaration(Asinh.NAME)
    public static final class Asinh extends OnnxOp {
        public static final String NAME = "Asinh";

        public enum Attribute implements OnnxAttribute.None { }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            input(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public Asinh(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        Asinh(Asinh that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public Asinh transform(CopyContext cc, OpTransformer ot) {
            return new Asinh(this, cc);
        }

        Asinh(TypeElement resultType, Value input) {
            super(SCHEMA, resultType, Set.of(), List.of(input), List.of());
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(input()));
        }

        public Value input() {
            return operands().get(0);
        }

    }

    public static Asinh Asinh(TypeElement resultType, Value input) {
        return new Asinh(resultType, input);
    }

    @OpFactoryHelper.OpDeclaration(Atan.NAME)
    public static final class Atan extends OnnxOp {
        public static final String NAME = "Atan";

        public enum Attribute implements OnnxAttribute.None { }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            input(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public Atan(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        Atan(Atan that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public Atan transform(CopyContext cc, OpTransformer ot) {
            return new Atan(this, cc);
        }

        Atan(TypeElement resultType, Value input) {
            super(SCHEMA, resultType, Set.of(), List.of(input), List.of());
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(input()));
        }

        public Value input() {
            return operands().get(0);
        }

    }

    public static Atan Atan(TypeElement resultType, Value input) {
        return new Atan(resultType, input);
    }

    @OpFactoryHelper.OpDeclaration(Atanh.NAME)
    public static final class Atanh extends OnnxOp {
        public static final String NAME = "Atanh";

        public enum Attribute implements OnnxAttribute.None { }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            input(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public Atanh(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        Atanh(Atanh that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public Atanh transform(CopyContext cc, OpTransformer ot) {
            return new Atanh(this, cc);
        }

        Atanh(TypeElement resultType, Value input) {
            super(SCHEMA, resultType, Set.of(), List.of(input), List.of());
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(input()));
        }

        public Value input() {
            return operands().get(0);
        }

    }

    public static Atanh Atanh(TypeElement resultType, Value input) {
        return new Atanh(resultType, input);
    }

    @OpFactoryHelper.OpDeclaration(AveragePool.NAME)
    public static final class AveragePool extends OnnxOp {
        public static final String NAME = "AveragePool";

        public enum Attribute implements OnnxAttribute {
            pads(long[].class, true, null),
            dilations(long[].class, true, null),
            auto_pad(String.class, true, "NOTSET"),
            count_include_pad(Long.class, true, 0),
            ceil_mode(Long.class, true, 0),
            strides(long[].class, true, null),
            kernel_shape(long[].class, false, null),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public AveragePool(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        AveragePool(AveragePool that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public AveragePool transform(CopyContext cc, OpTransformer ot) {
            return new AveragePool(this, cc);
        }

        AveragePool(TypeElement resultType, Value X, java.util.Optional<long[]> pads, java.util.Optional<long[]> dilations, java.util.Optional<String> auto_pad, java.util.Optional<Long> count_include_pad, java.util.Optional<Long> ceil_mode, java.util.Optional<long[]> strides, long[] kernel_shape) {
            super(SCHEMA, resultType, Set.of(), List.of(X), List.of(pads, dilations, auto_pad, count_include_pad, ceil_mode, strides, kernel_shape));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X()));
        }

        public Value X() {
            return operands().get(0);
        }

        public java.util.Optional<long[]> pads() {
            long[] pads = Attribute.pads.access(long[].class, onnxAttributes);
            return java.util.Optional.ofNullable(pads).map(long[]::clone);
        }

        public java.util.Optional<long[]> dilations() {
            long[] dilations = Attribute.dilations.access(long[].class, onnxAttributes);
            return java.util.Optional.ofNullable(dilations).map(long[]::clone);
        }

        public java.util.Optional<String> auto_pad() {
            String auto_pad = Attribute.auto_pad.access(String.class, onnxAttributes);
            return java.util.Optional.ofNullable(auto_pad);
        }

        public java.util.Optional<Long> count_include_pad() {
            Long count_include_pad = Attribute.count_include_pad.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(count_include_pad);
        }

        public java.util.Optional<Long> ceil_mode() {
            Long ceil_mode = Attribute.ceil_mode.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(ceil_mode);
        }

        public java.util.Optional<long[]> strides() {
            long[] strides = Attribute.strides.access(long[].class, onnxAttributes);
            return java.util.Optional.ofNullable(strides).map(long[]::clone);
        }

        public long[] kernel_shape() {
            long[] kernel_shape = Attribute.kernel_shape.access(long[].class, onnxAttributes);
            return kernel_shape.clone();
        }

    }

    public static AveragePool AveragePool(TypeElement resultType, Value X, java.util.Optional<long[]> pads, java.util.Optional<long[]> dilations, java.util.Optional<String> auto_pad, java.util.Optional<Long> count_include_pad, java.util.Optional<Long> ceil_mode, java.util.Optional<long[]> strides, long[] kernel_shape) {
        return new AveragePool(resultType, X, pads, dilations, auto_pad, count_include_pad, ceil_mode, strides, kernel_shape);
    }

    @OpFactoryHelper.OpDeclaration(BatchNormalization.NAME)
    public static final class BatchNormalization extends OnnxOp {
        public static final String NAME = "BatchNormalization";

        public enum Attribute implements OnnxAttribute {
            epsilon(Float.class, true, 1.0E-5f),
            training_mode(Long.class, true, 0),
            momentum(Float.class, true, 0.9f),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),
            T1(new OnnxType.TypeVariable("T1", List.of(OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),
            T2(new OnnxType.TypeVariable("T2", List.of(OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            scale(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            B(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            input_mean(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),
            input_var(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            running_mean(TypeConstraint.T2.typeVariable(), Quantifier.OPTIONAL),
            running_var(TypeConstraint.T2.typeVariable(), Quantifier.OPTIONAL),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public BatchNormalization(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        BatchNormalization(BatchNormalization that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public BatchNormalization transform(CopyContext cc, OpTransformer ot) {
            return new BatchNormalization(this, cc);
        }

        BatchNormalization(TypeElement resultType, Set<OutputParameter> optionalOutputs, Value X, Value scale, Value B, Value input_mean, Value input_var, java.util.Optional<Float> epsilon, java.util.Optional<Long> training_mode, java.util.Optional<Float> momentum) {
            super(SCHEMA, resultType, optionalOutputs, List.of(X, scale, B, input_mean, input_var), List.of(epsilon, training_mode, momentum));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X(), scale(), B(), input_mean(), input_var()));
        }

        public Value X() {
            return operands().get(0);
        }

        public Value scale() {
            return operands().get(1);
        }

        public Value B() {
            return operands().get(2);
        }

        public Value input_mean() {
            return operands().get(3);
        }

        public Value input_var() {
            return operands().get(4);
        }

        public java.util.Optional<Float> epsilon() {
            Float epsilon = Attribute.epsilon.access(Float.class, onnxAttributes);
            return java.util.Optional.ofNullable(epsilon);
        }

        public java.util.Optional<Long> training_mode() {
            Long training_mode = Attribute.training_mode.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(training_mode);
        }

        public java.util.Optional<Float> momentum() {
            Float momentum = Attribute.momentum.access(Float.class, onnxAttributes);
            return java.util.Optional.ofNullable(momentum);
        }

    }

    public static BatchNormalization BatchNormalization(TypeElement resultType, Set<BatchNormalization.OutputParameter> optionalOutputs, Value X, Value scale, Value B, Value input_mean, Value input_var, java.util.Optional<Float> epsilon, java.util.Optional<Long> training_mode, java.util.Optional<Float> momentum) {
        return new BatchNormalization(resultType, optionalOutputs, X, scale, B, input_mean, input_var, epsilon, training_mode, momentum);
    }

    @OpFactoryHelper.OpDeclaration(Bernoulli.NAME)
    public static final class Bernoulli extends OnnxOp {
        public static final String NAME = "Bernoulli";

        public enum Attribute implements OnnxAttribute {
            seed(Float.class, true, null),
            dtype(Long.class, true, null),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T1(new OnnxType.TypeVariable("T1", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),
            T2(new OnnxType.TypeVariable("T2", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bool())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            input(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public Bernoulli(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        Bernoulli(Bernoulli that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public Bernoulli transform(CopyContext cc, OpTransformer ot) {
            return new Bernoulli(this, cc);
        }

        Bernoulli(TypeElement resultType, Value input, java.util.Optional<Float> seed, java.util.Optional<Long> dtype) {
            super(SCHEMA, resultType, Set.of(), List.of(input), List.of(seed, dtype));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(input()));
        }

        public Value input() {
            return operands().get(0);
        }

        public java.util.Optional<Float> seed() {
            Float seed = Attribute.seed.access(Float.class, onnxAttributes);
            return java.util.Optional.ofNullable(seed);
        }

        public java.util.Optional<Long> dtype() {
            Long dtype = Attribute.dtype.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(dtype);
        }

    }

    public static Bernoulli Bernoulli(TypeElement resultType, Value input, java.util.Optional<Float> seed, java.util.Optional<Long> dtype) {
        return new Bernoulli(resultType, input, seed, dtype);
    }

    @OpFactoryHelper.OpDeclaration(Binarizer.NAME)
    public static final class Binarizer extends OnnxOp {
        public static final String NAME = "Binarizer";

        public enum Attribute implements OnnxAttribute {
            threshold(Float.class, true, 0.0f),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.int32())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public Binarizer(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        Binarizer(Binarizer that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public Binarizer transform(CopyContext cc, OpTransformer ot) {
            return new Binarizer(this, cc);
        }

        Binarizer(TypeElement resultType, Value X, java.util.Optional<Float> threshold) {
            super(SCHEMA, resultType, Set.of(), List.of(X), List.of(threshold));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X()));
        }

        public Value X() {
            return operands().get(0);
        }

        public java.util.Optional<Float> threshold() {
            Float threshold = Attribute.threshold.access(Float.class, onnxAttributes);
            return java.util.Optional.ofNullable(threshold);
        }

    }

    public static Binarizer Binarizer(TypeElement resultType, Value X, java.util.Optional<Float> threshold) {
        return new Binarizer(resultType, X, threshold);
    }

    @OpFactoryHelper.OpDeclaration(BitShift.NAME)
    public static final class BitShift extends OnnxOp {
        public static final String NAME = "BitShift";

        public enum Attribute implements OnnxAttribute {
            direction(String.class, false, null),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            Z(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public BitShift(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        BitShift(BitShift that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public BitShift transform(CopyContext cc, OpTransformer ot) {
            return new BitShift(this, cc);
        }

        BitShift(TypeElement resultType, Value X, Value Y, String direction) {
            super(SCHEMA, resultType, Set.of(), List.of(X, Y), List.of(direction));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X(), Y()));
        }

        public Value X() {
            return operands().get(0);
        }

        public Value Y() {
            return operands().get(1);
        }

        public String direction() {
            String direction = Attribute.direction.access(String.class, onnxAttributes);
            return direction;
        }

    }

    public static BitShift BitShift(TypeElement resultType, Value X, Value Y, String direction) {
        return new BitShift(resultType, X, Y, direction);
    }

    @OpFactoryHelper.OpDeclaration(BitwiseAnd.NAME)
    public static final class BitwiseAnd extends OnnxOp {
        public static final String NAME = "BitwiseAnd";

        public enum Attribute implements OnnxAttribute.None { }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            A(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            B(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            C(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public BitwiseAnd(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        BitwiseAnd(BitwiseAnd that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public BitwiseAnd transform(CopyContext cc, OpTransformer ot) {
            return new BitwiseAnd(this, cc);
        }

        BitwiseAnd(TypeElement resultType, Value A, Value B) {
            super(SCHEMA, resultType, Set.of(), List.of(A, B), List.of());
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(A(), B()));
        }

        public Value A() {
            return operands().get(0);
        }

        public Value B() {
            return operands().get(1);
        }

    }

    public static BitwiseAnd BitwiseAnd(TypeElement resultType, Value A, Value B) {
        return new BitwiseAnd(resultType, A, B);
    }

    @OpFactoryHelper.OpDeclaration(BitwiseNot.NAME)
    public static final class BitwiseNot extends OnnxOp {
        public static final String NAME = "BitwiseNot";

        public enum Attribute implements OnnxAttribute.None { }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public BitwiseNot(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        BitwiseNot(BitwiseNot that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public BitwiseNot transform(CopyContext cc, OpTransformer ot) {
            return new BitwiseNot(this, cc);
        }

        BitwiseNot(TypeElement resultType, Value X) {
            super(SCHEMA, resultType, Set.of(), List.of(X), List.of());
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X()));
        }

        public Value X() {
            return operands().get(0);
        }

    }

    public static BitwiseNot BitwiseNot(TypeElement resultType, Value X) {
        return new BitwiseNot(resultType, X);
    }

    @OpFactoryHelper.OpDeclaration(BitwiseOr.NAME)
    public static final class BitwiseOr extends OnnxOp {
        public static final String NAME = "BitwiseOr";

        public enum Attribute implements OnnxAttribute.None { }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            A(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            B(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            C(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public BitwiseOr(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        BitwiseOr(BitwiseOr that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public BitwiseOr transform(CopyContext cc, OpTransformer ot) {
            return new BitwiseOr(this, cc);
        }

        BitwiseOr(TypeElement resultType, Value A, Value B) {
            super(SCHEMA, resultType, Set.of(), List.of(A, B), List.of());
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(A(), B()));
        }

        public Value A() {
            return operands().get(0);
        }

        public Value B() {
            return operands().get(1);
        }

    }

    public static BitwiseOr BitwiseOr(TypeElement resultType, Value A, Value B) {
        return new BitwiseOr(resultType, A, B);
    }

    @OpFactoryHelper.OpDeclaration(BitwiseXor.NAME)
    public static final class BitwiseXor extends OnnxOp {
        public static final String NAME = "BitwiseXor";

        public enum Attribute implements OnnxAttribute.None { }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            A(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            B(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            C(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public BitwiseXor(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        BitwiseXor(BitwiseXor that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public BitwiseXor transform(CopyContext cc, OpTransformer ot) {
            return new BitwiseXor(this, cc);
        }

        BitwiseXor(TypeElement resultType, Value A, Value B) {
            super(SCHEMA, resultType, Set.of(), List.of(A, B), List.of());
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(A(), B()));
        }

        public Value A() {
            return operands().get(0);
        }

        public Value B() {
            return operands().get(1);
        }

    }

    public static BitwiseXor BitwiseXor(TypeElement resultType, Value A, Value B) {
        return new BitwiseXor(resultType, A, B);
    }

    @OpFactoryHelper.OpDeclaration(BlackmanWindow.NAME)
    public static final class BlackmanWindow extends OnnxOp {
        public static final String NAME = "BlackmanWindow";

        public enum Attribute implements OnnxAttribute {
            periodic(Long.class, true, 1),
            output_datatype(Long.class, true, 1),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T1(new OnnxType.TypeVariable("T1", List.of(OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64())))),
            T2(new OnnxType.TypeVariable("T2", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            size(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public BlackmanWindow(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        BlackmanWindow(BlackmanWindow that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public BlackmanWindow transform(CopyContext cc, OpTransformer ot) {
            return new BlackmanWindow(this, cc);
        }

        BlackmanWindow(TypeElement resultType, Value size, java.util.Optional<Long> periodic, java.util.Optional<Long> output_datatype) {
            super(SCHEMA, resultType, Set.of(), List.of(size), List.of(periodic, output_datatype));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(size()));
        }

        public Value size() {
            return operands().get(0);
        }

        public java.util.Optional<Long> periodic() {
            Long periodic = Attribute.periodic.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(periodic);
        }

        public java.util.Optional<Long> output_datatype() {
            Long output_datatype = Attribute.output_datatype.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(output_datatype);
        }

    }

    public static BlackmanWindow BlackmanWindow(TypeElement resultType, Value size, java.util.Optional<Long> periodic, java.util.Optional<Long> output_datatype) {
        return new BlackmanWindow(resultType, size, periodic, output_datatype);
    }

    @OpFactoryHelper.OpDeclaration(Cast.NAME)
    public static final class Cast extends OnnxOp {
        public static final String NAME = "Cast";

        public enum Attribute implements OnnxAttribute {
            saturate(Long.class, true, 1),
            to(Long.class, false, null),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T1(new OnnxType.TypeVariable("T1", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.float8e4m3fn()), OnnxType.tensor(OnnxType.float8e4m3fnuz()), OnnxType.tensor(OnnxType.float8e5m2()), OnnxType.tensor(OnnxType.float8e5m2fnuz()), OnnxType.tensor(OnnxType.uint4()), OnnxType.tensor(OnnxType.int4()), OnnxType.tensor(OnnxType.float4e2m1())))),
            T2(new OnnxType.TypeVariable("T2", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.float8e4m3fn()), OnnxType.tensor(OnnxType.float8e4m3fnuz()), OnnxType.tensor(OnnxType.float8e5m2()), OnnxType.tensor(OnnxType.float8e5m2fnuz()), OnnxType.tensor(OnnxType.uint4()), OnnxType.tensor(OnnxType.int4()), OnnxType.tensor(OnnxType.float4e2m1())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            input(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public Cast(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        Cast(Cast that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public Cast transform(CopyContext cc, OpTransformer ot) {
            return new Cast(this, cc);
        }

        Cast(TypeElement resultType, Value input, java.util.Optional<Long> saturate, long to) {
            super(SCHEMA, resultType, Set.of(), List.of(input), List.of(saturate, to));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(input()));
        }

        public Value input() {
            return operands().get(0);
        }

        public java.util.Optional<Long> saturate() {
            Long saturate = Attribute.saturate.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(saturate);
        }

        public long to() {
            long to = Attribute.to.access(Long.class, onnxAttributes);
            return to;
        }

    }

    public static Cast Cast(TypeElement resultType, Value input, java.util.Optional<Long> saturate, long to) {
        return new Cast(resultType, input, saturate, to);
    }

    @OpFactoryHelper.OpDeclaration(CastLike.NAME)
    public static final class CastLike extends OnnxOp {
        public static final String NAME = "CastLike";

        public enum Attribute implements OnnxAttribute {
            saturate(Long.class, true, 1),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T1(new OnnxType.TypeVariable("T1", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.float8e4m3fn()), OnnxType.tensor(OnnxType.float8e4m3fnuz()), OnnxType.tensor(OnnxType.float8e5m2()), OnnxType.tensor(OnnxType.float8e5m2fnuz()), OnnxType.tensor(OnnxType.uint4()), OnnxType.tensor(OnnxType.int4()), OnnxType.tensor(OnnxType.float4e2m1())))),
            T2(new OnnxType.TypeVariable("T2", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.float8e4m3fn()), OnnxType.tensor(OnnxType.float8e4m3fnuz()), OnnxType.tensor(OnnxType.float8e5m2()), OnnxType.tensor(OnnxType.float8e5m2fnuz()), OnnxType.tensor(OnnxType.uint4()), OnnxType.tensor(OnnxType.int4()), OnnxType.tensor(OnnxType.float4e2m1())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            input(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            target_type(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public CastLike(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        CastLike(CastLike that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public CastLike transform(CopyContext cc, OpTransformer ot) {
            return new CastLike(this, cc);
        }

        CastLike(TypeElement resultType, Value input, Value target_type, java.util.Optional<Long> saturate) {
            super(SCHEMA, resultType, Set.of(), List.of(input, target_type), List.of(saturate));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(input(), target_type()));
        }

        public Value input() {
            return operands().get(0);
        }

        public Value target_type() {
            return operands().get(1);
        }

        public java.util.Optional<Long> saturate() {
            Long saturate = Attribute.saturate.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(saturate);
        }

    }

    public static CastLike CastLike(TypeElement resultType, Value input, Value target_type, java.util.Optional<Long> saturate) {
        return new CastLike(resultType, input, target_type, saturate);
    }

    @OpFactoryHelper.OpDeclaration(CastMap.NAME)
    public static final class CastMap extends OnnxOp {
        public static final String NAME = "CastMap";

        public enum Attribute implements OnnxAttribute {
            map_form(String.class, true, "DENSE"),
            cast_to(String.class, true, "TO_FLOAT"),
            max_map(Long.class, true, 1),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T1(new OnnxType.TypeVariable("T1", List.of(OnnxType.map(OnnxType.int64(), OnnxType.string()), OnnxType.map(OnnxType.int64(), OnnxType.float32())))),
            T2(new OnnxType.TypeVariable("T2", List.of(OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.int64())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public CastMap(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        CastMap(CastMap that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public CastMap transform(CopyContext cc, OpTransformer ot) {
            return new CastMap(this, cc);
        }

        CastMap(TypeElement resultType, Value X, java.util.Optional<String> map_form, java.util.Optional<String> cast_to, java.util.Optional<Long> max_map) {
            super(SCHEMA, resultType, Set.of(), List.of(X), List.of(map_form, cast_to, max_map));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X()));
        }

        public Value X() {
            return operands().get(0);
        }

        public java.util.Optional<String> map_form() {
            String map_form = Attribute.map_form.access(String.class, onnxAttributes);
            return java.util.Optional.ofNullable(map_form);
        }

        public java.util.Optional<String> cast_to() {
            String cast_to = Attribute.cast_to.access(String.class, onnxAttributes);
            return java.util.Optional.ofNullable(cast_to);
        }

        public java.util.Optional<Long> max_map() {
            Long max_map = Attribute.max_map.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(max_map);
        }

    }

    public static CastMap CastMap(TypeElement resultType, Value X, java.util.Optional<String> map_form, java.util.Optional<String> cast_to, java.util.Optional<Long> max_map) {
        return new CastMap(resultType, X, map_form, cast_to, max_map);
    }

    @OpFactoryHelper.OpDeclaration(CategoryMapper.NAME)
    public static final class CategoryMapper extends OnnxOp {
        public static final String NAME = "CategoryMapper";

        public enum Attribute implements OnnxAttribute {
            cats_int64s(long[].class, true, null),
            cats_strings(String[].class, true, null),
            default_int64(Long.class, true, -1),
            default_string(String.class, true, "_Unused"),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T1(new OnnxType.TypeVariable("T1", List.of(OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.int64())))),
            T2(new OnnxType.TypeVariable("T2", List.of(OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.int64())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public CategoryMapper(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        CategoryMapper(CategoryMapper that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public CategoryMapper transform(CopyContext cc, OpTransformer ot) {
            return new CategoryMapper(this, cc);
        }

        CategoryMapper(TypeElement resultType, Value X, java.util.Optional<long[]> cats_int64s, java.util.Optional<String[]> cats_strings, java.util.Optional<Long> default_int64, java.util.Optional<String> default_string) {
            super(SCHEMA, resultType, Set.of(), List.of(X), List.of(cats_int64s, cats_strings, default_int64, default_string));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X()));
        }

        public Value X() {
            return operands().get(0);
        }

        public java.util.Optional<long[]> cats_int64s() {
            long[] cats_int64s = Attribute.cats_int64s.access(long[].class, onnxAttributes);
            return java.util.Optional.ofNullable(cats_int64s).map(long[]::clone);
        }

        public java.util.Optional<String[]> cats_strings() {
            String[] cats_strings = Attribute.cats_strings.access(String[].class, onnxAttributes);
            return java.util.Optional.ofNullable(cats_strings).map(String[]::clone);
        }

        public java.util.Optional<Long> default_int64() {
            Long default_int64 = Attribute.default_int64.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(default_int64);
        }

        public java.util.Optional<String> default_string() {
            String default_string = Attribute.default_string.access(String.class, onnxAttributes);
            return java.util.Optional.ofNullable(default_string);
        }

    }

    public static CategoryMapper CategoryMapper(TypeElement resultType, Value X, java.util.Optional<long[]> cats_int64s, java.util.Optional<String[]> cats_strings, java.util.Optional<Long> default_int64, java.util.Optional<String> default_string) {
        return new CategoryMapper(resultType, X, cats_int64s, cats_strings, default_int64, default_string);
    }

    @OpFactoryHelper.OpDeclaration(Ceil.NAME)
    public static final class Ceil extends OnnxOp {
        public static final String NAME = "Ceil";

        public enum Attribute implements OnnxAttribute.None { }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public Ceil(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        Ceil(Ceil that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public Ceil transform(CopyContext cc, OpTransformer ot) {
            return new Ceil(this, cc);
        }

        Ceil(TypeElement resultType, Value X) {
            super(SCHEMA, resultType, Set.of(), List.of(X), List.of());
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X()));
        }

        public Value X() {
            return operands().get(0);
        }

    }

    public static Ceil Ceil(TypeElement resultType, Value X) {
        return new Ceil(resultType, X);
    }

    @OpFactoryHelper.OpDeclaration(Celu.NAME)
    public static final class Celu extends OnnxOp {
        public static final String NAME = "Celu";

        public enum Attribute implements OnnxAttribute {
            alpha(Float.class, true, 1.0f),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.float32())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public Celu(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        Celu(Celu that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public Celu transform(CopyContext cc, OpTransformer ot) {
            return new Celu(this, cc);
        }

        Celu(TypeElement resultType, Value X, java.util.Optional<Float> alpha) {
            super(SCHEMA, resultType, Set.of(), List.of(X), List.of(alpha));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X()));
        }

        public Value X() {
            return operands().get(0);
        }

        public java.util.Optional<Float> alpha() {
            Float alpha = Attribute.alpha.access(Float.class, onnxAttributes);
            return java.util.Optional.ofNullable(alpha);
        }

    }

    public static Celu Celu(TypeElement resultType, Value X, java.util.Optional<Float> alpha) {
        return new Celu(resultType, X, alpha);
    }

    @OpFactoryHelper.OpDeclaration(CenterCropPad.NAME)
    public static final class CenterCropPad extends OnnxOp {
        public static final String NAME = "CenterCropPad";

        public enum Attribute implements OnnxAttribute {
            axes(long[].class, true, null),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128())))),
            Tind(new OnnxType.TypeVariable("Tind", List.of(OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            input_data(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            shape(TypeConstraint.Tind.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            output_data(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public CenterCropPad(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        CenterCropPad(CenterCropPad that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public CenterCropPad transform(CopyContext cc, OpTransformer ot) {
            return new CenterCropPad(this, cc);
        }

        CenterCropPad(TypeElement resultType, Value input_data, Value shape, java.util.Optional<long[]> axes) {
            super(SCHEMA, resultType, Set.of(), List.of(input_data, shape), List.of(axes));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(input_data(), shape()));
        }

        public Value input_data() {
            return operands().get(0);
        }

        public Value shape() {
            return operands().get(1);
        }

        public java.util.Optional<long[]> axes() {
            long[] axes = Attribute.axes.access(long[].class, onnxAttributes);
            return java.util.Optional.ofNullable(axes).map(long[]::clone);
        }

    }

    public static CenterCropPad CenterCropPad(TypeElement resultType, Value input_data, Value shape, java.util.Optional<long[]> axes) {
        return new CenterCropPad(resultType, input_data, shape, axes);
    }

    @OpFactoryHelper.OpDeclaration(Clip.NAME)
    public static final class Clip extends OnnxOp {
        public static final String NAME = "Clip";

        public enum Attribute implements OnnxAttribute.None { }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            input(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            min(TypeConstraint.T.typeVariable(), Quantifier.OPTIONAL),
            max(TypeConstraint.T.typeVariable(), Quantifier.OPTIONAL),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public Clip(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        Clip(Clip that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public Clip transform(CopyContext cc, OpTransformer ot) {
            return new Clip(this, cc);
        }

        Clip(TypeElement resultType, Value input, java.util.Optional<Value> min, java.util.Optional<Value> max) {
            super(SCHEMA, resultType, Set.of(), List.of(input, min, max), List.of());
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(input(), min(), max()));
        }

        public Value input() {
            return operands().get(0);
        }

        public java.util.Optional<Value> min() {
            int i = optionalInputArguments.indexOf(InputParameter.min);
            return i != -1 ? java.util.Optional.of(operands().get(1 + i)) : java.util.Optional.empty();
        }

        public java.util.Optional<Value> max() {
            int i = optionalInputArguments.indexOf(InputParameter.max);
            return i != -1 ? java.util.Optional.of(operands().get(1 + i)) : java.util.Optional.empty();
        }

    }

    public static Clip Clip(TypeElement resultType, Value input, java.util.Optional<Value> min, java.util.Optional<Value> max) {
        return new Clip(resultType, input, min, max);
    }

    @OpFactoryHelper.OpDeclaration(Col2Im.NAME)
    public static final class Col2Im extends OnnxOp {
        public static final String NAME = "Col2Im";

        public enum Attribute implements OnnxAttribute {
            pads(long[].class, true, null),
            dilations(long[].class, true, null),
            strides(long[].class, true, null),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            input(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            image_shape(OnnxType.tensor(OnnxType.int64()), Quantifier.REQUIRED),
            block_shape(OnnxType.tensor(OnnxType.int64()), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public Col2Im(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        Col2Im(Col2Im that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public Col2Im transform(CopyContext cc, OpTransformer ot) {
            return new Col2Im(this, cc);
        }

        Col2Im(TypeElement resultType, Value input, Value image_shape, Value block_shape, java.util.Optional<long[]> pads, java.util.Optional<long[]> dilations, java.util.Optional<long[]> strides) {
            super(SCHEMA, resultType, Set.of(), List.of(input, image_shape, block_shape), List.of(pads, dilations, strides));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(input(), image_shape(), block_shape()));
        }

        public Value input() {
            return operands().get(0);
        }

        public Value image_shape() {
            return operands().get(1);
        }

        public Value block_shape() {
            return operands().get(2);
        }

        public java.util.Optional<long[]> pads() {
            long[] pads = Attribute.pads.access(long[].class, onnxAttributes);
            return java.util.Optional.ofNullable(pads).map(long[]::clone);
        }

        public java.util.Optional<long[]> dilations() {
            long[] dilations = Attribute.dilations.access(long[].class, onnxAttributes);
            return java.util.Optional.ofNullable(dilations).map(long[]::clone);
        }

        public java.util.Optional<long[]> strides() {
            long[] strides = Attribute.strides.access(long[].class, onnxAttributes);
            return java.util.Optional.ofNullable(strides).map(long[]::clone);
        }

    }

    public static Col2Im Col2Im(TypeElement resultType, Value input, Value image_shape, Value block_shape, java.util.Optional<long[]> pads, java.util.Optional<long[]> dilations, java.util.Optional<long[]> strides) {
        return new Col2Im(resultType, input, image_shape, block_shape, pads, dilations, strides);
    }

    @OpFactoryHelper.OpDeclaration(Compress.NAME)
    public static final class Compress extends OnnxOp {
        public static final String NAME = "Compress";

        public enum Attribute implements OnnxAttribute {
            axis(Long.class, true, null),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128())))),
            T1(new OnnxType.TypeVariable("T1", List.of(OnnxType.tensor(OnnxType.bool())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            input(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            condition(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public Compress(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        Compress(Compress that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public Compress transform(CopyContext cc, OpTransformer ot) {
            return new Compress(this, cc);
        }

        Compress(TypeElement resultType, Value input, Value condition, java.util.Optional<Long> axis) {
            super(SCHEMA, resultType, Set.of(), List.of(input, condition), List.of(axis));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(input(), condition()));
        }

        public Value input() {
            return operands().get(0);
        }

        public Value condition() {
            return operands().get(1);
        }

        public java.util.Optional<Long> axis() {
            Long axis = Attribute.axis.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(axis);
        }

    }

    public static Compress Compress(TypeElement resultType, Value input, Value condition, java.util.Optional<Long> axis) {
        return new Compress(resultType, input, condition, axis);
    }

    @OpFactoryHelper.OpDeclaration(Concat.NAME)
    public static final class Concat extends OnnxOp {
        public static final String NAME = "Concat";

        public enum Attribute implements OnnxAttribute {
            axis(Long.class, false, null),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            inputs(TypeConstraint.T.typeVariable(), Quantifier.VARIADIC),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            concat_result(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public Concat(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        Concat(Concat that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public Concat transform(CopyContext cc, OpTransformer ot) {
            return new Concat(this, cc);
        }

        Concat(TypeElement resultType, List<Value> inputs, long axis) {
            super(SCHEMA, resultType, Set.of(), List.of(inputs), List.of(axis));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(inputs()));
        }

        public List<Value> inputs() {
            return operands();
        }

        public long axis() {
            long axis = Attribute.axis.access(Long.class, onnxAttributes);
            return axis;
        }

    }

    public static Concat Concat(TypeElement resultType, List<Value> inputs, long axis) {
        return new Concat(resultType, inputs, axis);
    }

    @OpFactoryHelper.OpDeclaration(ConcatFromSequence.NAME)
    public static final class ConcatFromSequence extends OnnxOp {
        public static final String NAME = "ConcatFromSequence";

        public enum Attribute implements OnnxAttribute {
            axis(Long.class, false, null),
            new_axis(Long.class, true, 0),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            S(new OnnxType.TypeVariable("S", List.of(OnnxType.seq(OnnxType.tensor(OnnxType.uint8())), OnnxType.seq(OnnxType.tensor(OnnxType.uint16())), OnnxType.seq(OnnxType.tensor(OnnxType.uint32())), OnnxType.seq(OnnxType.tensor(OnnxType.uint64())), OnnxType.seq(OnnxType.tensor(OnnxType.int8())), OnnxType.seq(OnnxType.tensor(OnnxType.int16())), OnnxType.seq(OnnxType.tensor(OnnxType.int32())), OnnxType.seq(OnnxType.tensor(OnnxType.int64())), OnnxType.seq(OnnxType.tensor(OnnxType.float16())), OnnxType.seq(OnnxType.tensor(OnnxType.float32())), OnnxType.seq(OnnxType.tensor(OnnxType.float64())), OnnxType.seq(OnnxType.tensor(OnnxType.string())), OnnxType.seq(OnnxType.tensor(OnnxType.bool())), OnnxType.seq(OnnxType.tensor(OnnxType.complex64())), OnnxType.seq(OnnxType.tensor(OnnxType.complex128()))))),
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            input_sequence(TypeConstraint.S.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            concat_result(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public ConcatFromSequence(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        ConcatFromSequence(ConcatFromSequence that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public ConcatFromSequence transform(CopyContext cc, OpTransformer ot) {
            return new ConcatFromSequence(this, cc);
        }

        ConcatFromSequence(TypeElement resultType, Value input_sequence, long axis, java.util.Optional<Long> new_axis) {
            super(SCHEMA, resultType, Set.of(), List.of(input_sequence), List.of(axis, new_axis));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(input_sequence()));
        }

        public Value input_sequence() {
            return operands().get(0);
        }

        public long axis() {
            long axis = Attribute.axis.access(Long.class, onnxAttributes);
            return axis;
        }

        public java.util.Optional<Long> new_axis() {
            Long new_axis = Attribute.new_axis.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(new_axis);
        }

    }

    public static ConcatFromSequence ConcatFromSequence(TypeElement resultType, Value input_sequence, long axis, java.util.Optional<Long> new_axis) {
        return new ConcatFromSequence(resultType, input_sequence, axis, new_axis);
    }

    @OpFactoryHelper.OpDeclaration(Constant.NAME)
    public static final class Constant extends OnnxOp {
        public static final String NAME = "Constant";

        public enum Attribute implements OnnxAttribute {
            value_int(Long.class, true, null),
            value_floats(float[].class, true, null),
            value_strings(String[].class, true, null),
            value_float(Float.class, true, null),
            value_string(String.class, true, null),
            value_ints(long[].class, true, null),
            sparse_value(byte[].class, true, null),
            value(Tensor.class, true, null),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128()), OnnxType.tensor(OnnxType.float8e4m3fn()), OnnxType.tensor(OnnxType.float8e4m3fnuz()), OnnxType.tensor(OnnxType.float8e5m2()), OnnxType.tensor(OnnxType.float8e5m2fnuz()), OnnxType.tensor(OnnxType.uint4()), OnnxType.tensor(OnnxType.int4()), OnnxType.tensor(OnnxType.float4e2m1())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter.None { }

        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public Constant(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        Constant(Constant that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public Constant transform(CopyContext cc, OpTransformer ot) {
            return new Constant(this, cc);
        }

        Constant(TypeElement resultType, java.util.Optional<Long> value_int, java.util.Optional<float[]> value_floats, java.util.Optional<String[]> value_strings, java.util.Optional<Float> value_float, java.util.Optional<String> value_string, java.util.Optional<long[]> value_ints, java.util.Optional<byte[]> sparse_value, java.util.Optional<Tensor> value) {
            super(SCHEMA, resultType, Set.of(), List.of(), List.of(value_int, value_floats, value_strings, value_float, value_string, value_ints, sparse_value, value));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of());
        }

        public java.util.Optional<Long> value_int() {
            Long value_int = Attribute.value_int.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(value_int);
        }

        public java.util.Optional<float[]> value_floats() {
            float[] value_floats = Attribute.value_floats.access(float[].class, onnxAttributes);
            return java.util.Optional.ofNullable(value_floats).map(float[]::clone);
        }

        public java.util.Optional<String[]> value_strings() {
            String[] value_strings = Attribute.value_strings.access(String[].class, onnxAttributes);
            return java.util.Optional.ofNullable(value_strings).map(String[]::clone);
        }

        public java.util.Optional<Float> value_float() {
            Float value_float = Attribute.value_float.access(Float.class, onnxAttributes);
            return java.util.Optional.ofNullable(value_float);
        }

        public java.util.Optional<String> value_string() {
            String value_string = Attribute.value_string.access(String.class, onnxAttributes);
            return java.util.Optional.ofNullable(value_string);
        }

        public java.util.Optional<long[]> value_ints() {
            long[] value_ints = Attribute.value_ints.access(long[].class, onnxAttributes);
            return java.util.Optional.ofNullable(value_ints).map(long[]::clone);
        }

        public java.util.Optional<byte[]> sparse_value() {
            byte[] sparse_value = Attribute.sparse_value.access(byte[].class, onnxAttributes);
            return java.util.Optional.ofNullable(sparse_value).map(byte[]::clone);
        }

        public java.util.Optional<Tensor> value() {
            Tensor value = Attribute.value.access(Tensor.class, onnxAttributes);
            return java.util.Optional.ofNullable(value);
        }

    }

    public static Constant Constant(TypeElement resultType, java.util.Optional<Long> value_int, java.util.Optional<float[]> value_floats, java.util.Optional<String[]> value_strings, java.util.Optional<Float> value_float, java.util.Optional<String> value_string, java.util.Optional<long[]> value_ints, java.util.Optional<byte[]> sparse_value, java.util.Optional<Tensor> value) {
        return new Constant(resultType, value_int, value_floats, value_strings, value_float, value_string, value_ints, sparse_value, value);
    }

    @OpFactoryHelper.OpDeclaration(ConstantOfShape.NAME)
    public static final class ConstantOfShape extends OnnxOp {
        public static final String NAME = "ConstantOfShape";

        public enum Attribute implements OnnxAttribute {
            value(Tensor.class, true, null),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T1(new OnnxType.TypeVariable("T1", List.of(OnnxType.tensor(OnnxType.int64())))),
            T2(new OnnxType.TypeVariable("T2", List.of(OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.uint4()), OnnxType.tensor(OnnxType.int4()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float8e4m3fn()), OnnxType.tensor(OnnxType.float8e4m3fnuz()), OnnxType.tensor(OnnxType.float8e5m2()), OnnxType.tensor(OnnxType.float8e5m2fnuz()), OnnxType.tensor(OnnxType.float4e2m1())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            input(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public ConstantOfShape(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        ConstantOfShape(ConstantOfShape that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public ConstantOfShape transform(CopyContext cc, OpTransformer ot) {
            return new ConstantOfShape(this, cc);
        }

        ConstantOfShape(TypeElement resultType, Value input, java.util.Optional<Tensor> value) {
            super(SCHEMA, resultType, Set.of(), List.of(input), List.of(value));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(input()));
        }

        public Value input() {
            return operands().get(0);
        }

        public java.util.Optional<Tensor> value() {
            Tensor value = Attribute.value.access(Tensor.class, onnxAttributes);
            return java.util.Optional.ofNullable(value);
        }

    }

    public static ConstantOfShape ConstantOfShape(TypeElement resultType, Value input, java.util.Optional<Tensor> value) {
        return new ConstantOfShape(resultType, input, value);
    }

    @OpFactoryHelper.OpDeclaration(Conv.NAME)
    public static final class Conv extends OnnxOp {
        public static final String NAME = "Conv";

        public enum Attribute implements OnnxAttribute {
            pads(long[].class, true, null),
            dilations(long[].class, true, null),
            auto_pad(String.class, true, "NOTSET"),
            strides(long[].class, true, null),
            group(Long.class, true, 1),
            kernel_shape(long[].class, true, null),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            W(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            B(TypeConstraint.T.typeVariable(), Quantifier.OPTIONAL),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public Conv(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        Conv(Conv that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public Conv transform(CopyContext cc, OpTransformer ot) {
            return new Conv(this, cc);
        }

        Conv(TypeElement resultType, Value X, Value W, java.util.Optional<Value> B, java.util.Optional<long[]> pads, java.util.Optional<long[]> dilations, java.util.Optional<String> auto_pad, java.util.Optional<long[]> strides, java.util.Optional<Long> group, java.util.Optional<long[]> kernel_shape) {
            super(SCHEMA, resultType, Set.of(), List.of(X, W, B), List.of(pads, dilations, auto_pad, strides, group, kernel_shape));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X(), W(), B()));
        }

        public Value X() {
            return operands().get(0);
        }

        public Value W() {
            return operands().get(1);
        }

        public java.util.Optional<Value> B() {
            int i = optionalInputArguments.indexOf(InputParameter.B);
            return i != -1 ? java.util.Optional.of(operands().get(2 + i)) : java.util.Optional.empty();
        }

        public java.util.Optional<long[]> pads() {
            long[] pads = Attribute.pads.access(long[].class, onnxAttributes);
            return java.util.Optional.ofNullable(pads).map(long[]::clone);
        }

        public java.util.Optional<long[]> dilations() {
            long[] dilations = Attribute.dilations.access(long[].class, onnxAttributes);
            return java.util.Optional.ofNullable(dilations).map(long[]::clone);
        }

        public java.util.Optional<String> auto_pad() {
            String auto_pad = Attribute.auto_pad.access(String.class, onnxAttributes);
            return java.util.Optional.ofNullable(auto_pad);
        }

        public java.util.Optional<long[]> strides() {
            long[] strides = Attribute.strides.access(long[].class, onnxAttributes);
            return java.util.Optional.ofNullable(strides).map(long[]::clone);
        }

        public java.util.Optional<Long> group() {
            Long group = Attribute.group.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(group);
        }

        public java.util.Optional<long[]> kernel_shape() {
            long[] kernel_shape = Attribute.kernel_shape.access(long[].class, onnxAttributes);
            return java.util.Optional.ofNullable(kernel_shape).map(long[]::clone);
        }

    }

    public static Conv Conv(TypeElement resultType, Value X, Value W, java.util.Optional<Value> B, java.util.Optional<long[]> pads, java.util.Optional<long[]> dilations, java.util.Optional<String> auto_pad, java.util.Optional<long[]> strides, java.util.Optional<Long> group, java.util.Optional<long[]> kernel_shape) {
        return new Conv(resultType, X, W, B, pads, dilations, auto_pad, strides, group, kernel_shape);
    }

    @OpFactoryHelper.OpDeclaration(ConvInteger.NAME)
    public static final class ConvInteger extends OnnxOp {
        public static final String NAME = "ConvInteger";

        public enum Attribute implements OnnxAttribute {
            pads(long[].class, true, null),
            dilations(long[].class, true, null),
            auto_pad(String.class, true, "NOTSET"),
            strides(long[].class, true, null),
            group(Long.class, true, 1),
            kernel_shape(long[].class, true, null),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T1(new OnnxType.TypeVariable("T1", List.of(OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.uint8())))),
            T2(new OnnxType.TypeVariable("T2", List.of(OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.uint8())))),
            T3(new OnnxType.TypeVariable("T3", List.of(OnnxType.tensor(OnnxType.int32())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            x(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            w(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),
            x_zero_point(TypeConstraint.T1.typeVariable(), Quantifier.OPTIONAL),
            w_zero_point(TypeConstraint.T2.typeVariable(), Quantifier.OPTIONAL),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            y(TypeConstraint.T3.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public ConvInteger(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        ConvInteger(ConvInteger that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public ConvInteger transform(CopyContext cc, OpTransformer ot) {
            return new ConvInteger(this, cc);
        }

        ConvInteger(TypeElement resultType, Value x, Value w, java.util.Optional<Value> x_zero_point, java.util.Optional<Value> w_zero_point, java.util.Optional<long[]> pads, java.util.Optional<long[]> dilations, java.util.Optional<String> auto_pad, java.util.Optional<long[]> strides, java.util.Optional<Long> group, java.util.Optional<long[]> kernel_shape) {
            super(SCHEMA, resultType, Set.of(), List.of(x, w, x_zero_point, w_zero_point), List.of(pads, dilations, auto_pad, strides, group, kernel_shape));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(x(), w(), x_zero_point(), w_zero_point()));
        }

        public Value x() {
            return operands().get(0);
        }

        public Value w() {
            return operands().get(1);
        }

        public java.util.Optional<Value> x_zero_point() {
            int i = optionalInputArguments.indexOf(InputParameter.x_zero_point);
            return i != -1 ? java.util.Optional.of(operands().get(2 + i)) : java.util.Optional.empty();
        }

        public java.util.Optional<Value> w_zero_point() {
            int i = optionalInputArguments.indexOf(InputParameter.w_zero_point);
            return i != -1 ? java.util.Optional.of(operands().get(2 + i)) : java.util.Optional.empty();
        }

        public java.util.Optional<long[]> pads() {
            long[] pads = Attribute.pads.access(long[].class, onnxAttributes);
            return java.util.Optional.ofNullable(pads).map(long[]::clone);
        }

        public java.util.Optional<long[]> dilations() {
            long[] dilations = Attribute.dilations.access(long[].class, onnxAttributes);
            return java.util.Optional.ofNullable(dilations).map(long[]::clone);
        }

        public java.util.Optional<String> auto_pad() {
            String auto_pad = Attribute.auto_pad.access(String.class, onnxAttributes);
            return java.util.Optional.ofNullable(auto_pad);
        }

        public java.util.Optional<long[]> strides() {
            long[] strides = Attribute.strides.access(long[].class, onnxAttributes);
            return java.util.Optional.ofNullable(strides).map(long[]::clone);
        }

        public java.util.Optional<Long> group() {
            Long group = Attribute.group.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(group);
        }

        public java.util.Optional<long[]> kernel_shape() {
            long[] kernel_shape = Attribute.kernel_shape.access(long[].class, onnxAttributes);
            return java.util.Optional.ofNullable(kernel_shape).map(long[]::clone);
        }

    }

    public static ConvInteger ConvInteger(TypeElement resultType, Value x, Value w, java.util.Optional<Value> x_zero_point, java.util.Optional<Value> w_zero_point, java.util.Optional<long[]> pads, java.util.Optional<long[]> dilations, java.util.Optional<String> auto_pad, java.util.Optional<long[]> strides, java.util.Optional<Long> group, java.util.Optional<long[]> kernel_shape) {
        return new ConvInteger(resultType, x, w, x_zero_point, w_zero_point, pads, dilations, auto_pad, strides, group, kernel_shape);
    }

    @OpFactoryHelper.OpDeclaration(ConvTranspose.NAME)
    public static final class ConvTranspose extends OnnxOp {
        public static final String NAME = "ConvTranspose";

        public enum Attribute implements OnnxAttribute {
            output_shape(long[].class, true, null),
            pads(long[].class, true, null),
            dilations(long[].class, true, null),
            auto_pad(String.class, true, "NOTSET"),
            strides(long[].class, true, null),
            group(Long.class, true, 1),
            kernel_shape(long[].class, true, null),
            output_padding(long[].class, true, null),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            W(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            B(TypeConstraint.T.typeVariable(), Quantifier.OPTIONAL),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public ConvTranspose(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        ConvTranspose(ConvTranspose that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public ConvTranspose transform(CopyContext cc, OpTransformer ot) {
            return new ConvTranspose(this, cc);
        }

        ConvTranspose(TypeElement resultType, Value X, Value W, java.util.Optional<Value> B, java.util.Optional<long[]> output_shape, java.util.Optional<long[]> pads, java.util.Optional<long[]> dilations, java.util.Optional<String> auto_pad, java.util.Optional<long[]> strides, java.util.Optional<Long> group, java.util.Optional<long[]> kernel_shape, java.util.Optional<long[]> output_padding) {
            super(SCHEMA, resultType, Set.of(), List.of(X, W, B), List.of(output_shape, pads, dilations, auto_pad, strides, group, kernel_shape, output_padding));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X(), W(), B()));
        }

        public Value X() {
            return operands().get(0);
        }

        public Value W() {
            return operands().get(1);
        }

        public java.util.Optional<Value> B() {
            int i = optionalInputArguments.indexOf(InputParameter.B);
            return i != -1 ? java.util.Optional.of(operands().get(2 + i)) : java.util.Optional.empty();
        }

        public java.util.Optional<long[]> output_shape() {
            long[] output_shape = Attribute.output_shape.access(long[].class, onnxAttributes);
            return java.util.Optional.ofNullable(output_shape).map(long[]::clone);
        }

        public java.util.Optional<long[]> pads() {
            long[] pads = Attribute.pads.access(long[].class, onnxAttributes);
            return java.util.Optional.ofNullable(pads).map(long[]::clone);
        }

        public java.util.Optional<long[]> dilations() {
            long[] dilations = Attribute.dilations.access(long[].class, onnxAttributes);
            return java.util.Optional.ofNullable(dilations).map(long[]::clone);
        }

        public java.util.Optional<String> auto_pad() {
            String auto_pad = Attribute.auto_pad.access(String.class, onnxAttributes);
            return java.util.Optional.ofNullable(auto_pad);
        }

        public java.util.Optional<long[]> strides() {
            long[] strides = Attribute.strides.access(long[].class, onnxAttributes);
            return java.util.Optional.ofNullable(strides).map(long[]::clone);
        }

        public java.util.Optional<Long> group() {
            Long group = Attribute.group.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(group);
        }

        public java.util.Optional<long[]> kernel_shape() {
            long[] kernel_shape = Attribute.kernel_shape.access(long[].class, onnxAttributes);
            return java.util.Optional.ofNullable(kernel_shape).map(long[]::clone);
        }

        public java.util.Optional<long[]> output_padding() {
            long[] output_padding = Attribute.output_padding.access(long[].class, onnxAttributes);
            return java.util.Optional.ofNullable(output_padding).map(long[]::clone);
        }

    }

    public static ConvTranspose ConvTranspose(TypeElement resultType, Value X, Value W, java.util.Optional<Value> B, java.util.Optional<long[]> output_shape, java.util.Optional<long[]> pads, java.util.Optional<long[]> dilations, java.util.Optional<String> auto_pad, java.util.Optional<long[]> strides, java.util.Optional<Long> group, java.util.Optional<long[]> kernel_shape, java.util.Optional<long[]> output_padding) {
        return new ConvTranspose(resultType, X, W, B, output_shape, pads, dilations, auto_pad, strides, group, kernel_shape, output_padding);
    }

    @OpFactoryHelper.OpDeclaration(Cos.NAME)
    public static final class Cos extends OnnxOp {
        public static final String NAME = "Cos";

        public enum Attribute implements OnnxAttribute.None { }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            input(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public Cos(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        Cos(Cos that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public Cos transform(CopyContext cc, OpTransformer ot) {
            return new Cos(this, cc);
        }

        Cos(TypeElement resultType, Value input) {
            super(SCHEMA, resultType, Set.of(), List.of(input), List.of());
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(input()));
        }

        public Value input() {
            return operands().get(0);
        }

    }

    public static Cos Cos(TypeElement resultType, Value input) {
        return new Cos(resultType, input);
    }

    @OpFactoryHelper.OpDeclaration(Cosh.NAME)
    public static final class Cosh extends OnnxOp {
        public static final String NAME = "Cosh";

        public enum Attribute implements OnnxAttribute.None { }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            input(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public Cosh(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        Cosh(Cosh that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public Cosh transform(CopyContext cc, OpTransformer ot) {
            return new Cosh(this, cc);
        }

        Cosh(TypeElement resultType, Value input) {
            super(SCHEMA, resultType, Set.of(), List.of(input), List.of());
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(input()));
        }

        public Value input() {
            return operands().get(0);
        }

    }

    public static Cosh Cosh(TypeElement resultType, Value input) {
        return new Cosh(resultType, input);
    }

    @OpFactoryHelper.OpDeclaration(CumSum.NAME)
    public static final class CumSum extends OnnxOp {
        public static final String NAME = "CumSum";

        public enum Attribute implements OnnxAttribute {
            exclusive(Long.class, true, 0),
            reverse(Long.class, true, 0),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),
            T2(new OnnxType.TypeVariable("T2", List.of(OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            x(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            axis(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public CumSum(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        CumSum(CumSum that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public CumSum transform(CopyContext cc, OpTransformer ot) {
            return new CumSum(this, cc);
        }

        CumSum(TypeElement resultType, Value x, Value axis, java.util.Optional<Long> exclusive, java.util.Optional<Long> reverse) {
            super(SCHEMA, resultType, Set.of(), List.of(x, axis), List.of(exclusive, reverse));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(x(), axis()));
        }

        public Value x() {
            return operands().get(0);
        }

        public Value axis() {
            return operands().get(1);
        }

        public java.util.Optional<Long> exclusive() {
            Long exclusive = Attribute.exclusive.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(exclusive);
        }

        public java.util.Optional<Long> reverse() {
            Long reverse = Attribute.reverse.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(reverse);
        }

    }

    public static CumSum CumSum(TypeElement resultType, Value x, Value axis, java.util.Optional<Long> exclusive, java.util.Optional<Long> reverse) {
        return new CumSum(resultType, x, axis, exclusive, reverse);
    }

    @OpFactoryHelper.OpDeclaration(DFT.NAME)
    public static final class DFT extends OnnxOp {
        public static final String NAME = "DFT";

        public enum Attribute implements OnnxAttribute {
            inverse(Long.class, true, 0),
            onesided(Long.class, true, 0),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T1(new OnnxType.TypeVariable("T1", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),
            T2(new OnnxType.TypeVariable("T2", List.of(OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            input(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            dft_length(TypeConstraint.T2.typeVariable(), Quantifier.OPTIONAL),
            axis(OnnxType.tensor(OnnxType.int64()), Quantifier.OPTIONAL),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public DFT(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        DFT(DFT that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public DFT transform(CopyContext cc, OpTransformer ot) {
            return new DFT(this, cc);
        }

        DFT(TypeElement resultType, Value input, java.util.Optional<Value> dft_length, java.util.Optional<Value> axis, java.util.Optional<Long> inverse, java.util.Optional<Long> onesided) {
            super(SCHEMA, resultType, Set.of(), List.of(input, dft_length, axis), List.of(inverse, onesided));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(input(), dft_length(), axis()));
        }

        public Value input() {
            return operands().get(0);
        }

        public java.util.Optional<Value> dft_length() {
            int i = optionalInputArguments.indexOf(InputParameter.dft_length);
            return i != -1 ? java.util.Optional.of(operands().get(1 + i)) : java.util.Optional.empty();
        }

        public java.util.Optional<Value> axis() {
            int i = optionalInputArguments.indexOf(InputParameter.axis);
            return i != -1 ? java.util.Optional.of(operands().get(1 + i)) : java.util.Optional.empty();
        }

        public java.util.Optional<Long> inverse() {
            Long inverse = Attribute.inverse.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(inverse);
        }

        public java.util.Optional<Long> onesided() {
            Long onesided = Attribute.onesided.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(onesided);
        }

    }

    public static DFT DFT(TypeElement resultType, Value input, java.util.Optional<Value> dft_length, java.util.Optional<Value> axis, java.util.Optional<Long> inverse, java.util.Optional<Long> onesided) {
        return new DFT(resultType, input, dft_length, axis, inverse, onesided);
    }

    @OpFactoryHelper.OpDeclaration(DeformConv.NAME)
    public static final class DeformConv extends OnnxOp {
        public static final String NAME = "DeformConv";

        public enum Attribute implements OnnxAttribute {
            pads(long[].class, true, null),
            dilations(long[].class, true, null),
            strides(long[].class, true, null),
            offset_group(Long.class, true, 1),
            group(Long.class, true, 1),
            kernel_shape(long[].class, true, null),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            W(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            offset(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            B(TypeConstraint.T.typeVariable(), Quantifier.OPTIONAL),
            mask(TypeConstraint.T.typeVariable(), Quantifier.OPTIONAL),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public DeformConv(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        DeformConv(DeformConv that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public DeformConv transform(CopyContext cc, OpTransformer ot) {
            return new DeformConv(this, cc);
        }

        DeformConv(TypeElement resultType, Value X, Value W, Value offset, java.util.Optional<Value> B, java.util.Optional<Value> mask, java.util.Optional<long[]> pads, java.util.Optional<long[]> dilations, java.util.Optional<long[]> strides, java.util.Optional<Long> offset_group, java.util.Optional<Long> group, java.util.Optional<long[]> kernel_shape) {
            super(SCHEMA, resultType, Set.of(), List.of(X, W, offset, B, mask), List.of(pads, dilations, strides, offset_group, group, kernel_shape));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X(), W(), offset(), B(), mask()));
        }

        public Value X() {
            return operands().get(0);
        }

        public Value W() {
            return operands().get(1);
        }

        public Value offset() {
            return operands().get(2);
        }

        public java.util.Optional<Value> B() {
            int i = optionalInputArguments.indexOf(InputParameter.B);
            return i != -1 ? java.util.Optional.of(operands().get(3 + i)) : java.util.Optional.empty();
        }

        public java.util.Optional<Value> mask() {
            int i = optionalInputArguments.indexOf(InputParameter.mask);
            return i != -1 ? java.util.Optional.of(operands().get(3 + i)) : java.util.Optional.empty();
        }

        public java.util.Optional<long[]> pads() {
            long[] pads = Attribute.pads.access(long[].class, onnxAttributes);
            return java.util.Optional.ofNullable(pads).map(long[]::clone);
        }

        public java.util.Optional<long[]> dilations() {
            long[] dilations = Attribute.dilations.access(long[].class, onnxAttributes);
            return java.util.Optional.ofNullable(dilations).map(long[]::clone);
        }

        public java.util.Optional<long[]> strides() {
            long[] strides = Attribute.strides.access(long[].class, onnxAttributes);
            return java.util.Optional.ofNullable(strides).map(long[]::clone);
        }

        public java.util.Optional<Long> offset_group() {
            Long offset_group = Attribute.offset_group.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(offset_group);
        }

        public java.util.Optional<Long> group() {
            Long group = Attribute.group.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(group);
        }

        public java.util.Optional<long[]> kernel_shape() {
            long[] kernel_shape = Attribute.kernel_shape.access(long[].class, onnxAttributes);
            return java.util.Optional.ofNullable(kernel_shape).map(long[]::clone);
        }

    }

    public static DeformConv DeformConv(TypeElement resultType, Value X, Value W, Value offset, java.util.Optional<Value> B, java.util.Optional<Value> mask, java.util.Optional<long[]> pads, java.util.Optional<long[]> dilations, java.util.Optional<long[]> strides, java.util.Optional<Long> offset_group, java.util.Optional<Long> group, java.util.Optional<long[]> kernel_shape) {
        return new DeformConv(resultType, X, W, offset, B, mask, pads, dilations, strides, offset_group, group, kernel_shape);
    }

    @OpFactoryHelper.OpDeclaration(DepthToSpace.NAME)
    public static final class DepthToSpace extends OnnxOp {
        public static final String NAME = "DepthToSpace";

        public enum Attribute implements OnnxAttribute {
            mode(String.class, true, "DCR"),
            blocksize(Long.class, false, null),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            input(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public DepthToSpace(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        DepthToSpace(DepthToSpace that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public DepthToSpace transform(CopyContext cc, OpTransformer ot) {
            return new DepthToSpace(this, cc);
        }

        DepthToSpace(TypeElement resultType, Value input, java.util.Optional<String> mode, long blocksize) {
            super(SCHEMA, resultType, Set.of(), List.of(input), List.of(mode, blocksize));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(input()));
        }

        public Value input() {
            return operands().get(0);
        }

        public java.util.Optional<String> mode() {
            String mode = Attribute.mode.access(String.class, onnxAttributes);
            return java.util.Optional.ofNullable(mode);
        }

        public long blocksize() {
            long blocksize = Attribute.blocksize.access(Long.class, onnxAttributes);
            return blocksize;
        }

    }

    public static DepthToSpace DepthToSpace(TypeElement resultType, Value input, java.util.Optional<String> mode, long blocksize) {
        return new DepthToSpace(resultType, input, mode, blocksize);
    }

    @OpFactoryHelper.OpDeclaration(DequantizeLinear.NAME)
    public static final class DequantizeLinear extends OnnxOp {
        public static final String NAME = "DequantizeLinear";

        public enum Attribute implements OnnxAttribute {
            axis(Long.class, true, 1),
            block_size(Long.class, true, 0),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T1(new OnnxType.TypeVariable("T1", List.of(OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.float8e4m3fn()), OnnxType.tensor(OnnxType.float8e4m3fnuz()), OnnxType.tensor(OnnxType.float8e5m2()), OnnxType.tensor(OnnxType.float8e5m2fnuz()), OnnxType.tensor(OnnxType.uint4()), OnnxType.tensor(OnnxType.int4()), OnnxType.tensor(OnnxType.float4e2m1())))),
            T2(new OnnxType.TypeVariable("T2", List.of(OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.bfloat16())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            x(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            x_scale(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),
            x_zero_point(TypeConstraint.T1.typeVariable(), Quantifier.OPTIONAL),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            y(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public DequantizeLinear(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        DequantizeLinear(DequantizeLinear that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public DequantizeLinear transform(CopyContext cc, OpTransformer ot) {
            return new DequantizeLinear(this, cc);
        }

        DequantizeLinear(TypeElement resultType, Value x, Value x_scale, java.util.Optional<Value> x_zero_point, java.util.Optional<Long> axis, java.util.Optional<Long> block_size) {
            super(SCHEMA, resultType, Set.of(), List.of(x, x_scale, x_zero_point), List.of(axis, block_size));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(x(), x_scale(), x_zero_point()));
        }

        public Value x() {
            return operands().get(0);
        }

        public Value x_scale() {
            return operands().get(1);
        }

        public java.util.Optional<Value> x_zero_point() {
            int i = optionalInputArguments.indexOf(InputParameter.x_zero_point);
            return i != -1 ? java.util.Optional.of(operands().get(2 + i)) : java.util.Optional.empty();
        }

        public java.util.Optional<Long> axis() {
            Long axis = Attribute.axis.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(axis);
        }

        public java.util.Optional<Long> block_size() {
            Long block_size = Attribute.block_size.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(block_size);
        }

    }

    public static DequantizeLinear DequantizeLinear(TypeElement resultType, Value x, Value x_scale, java.util.Optional<Value> x_zero_point, java.util.Optional<Long> axis, java.util.Optional<Long> block_size) {
        return new DequantizeLinear(resultType, x, x_scale, x_zero_point, axis, block_size);
    }

    @OpFactoryHelper.OpDeclaration(Det.NAME)
    public static final class Det extends OnnxOp {
        public static final String NAME = "Det";

        public enum Attribute implements OnnxAttribute.None { }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public Det(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        Det(Det that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public Det transform(CopyContext cc, OpTransformer ot) {
            return new Det(this, cc);
        }

        Det(TypeElement resultType, Value X) {
            super(SCHEMA, resultType, Set.of(), List.of(X), List.of());
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X()));
        }

        public Value X() {
            return operands().get(0);
        }

    }

    public static Det Det(TypeElement resultType, Value X) {
        return new Det(resultType, X);
    }

    @OpFactoryHelper.OpDeclaration(DictVectorizer.NAME)
    public static final class DictVectorizer extends OnnxOp {
        public static final String NAME = "DictVectorizer";

        public enum Attribute implements OnnxAttribute {
            string_vocabulary(String[].class, true, null),
            int64_vocabulary(long[].class, true, null),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T1(new OnnxType.TypeVariable("T1", List.of(OnnxType.map(OnnxType.string(), OnnxType.int64()), OnnxType.map(OnnxType.int64(), OnnxType.string()), OnnxType.map(OnnxType.int64(), OnnxType.float32()), OnnxType.map(OnnxType.int64(), OnnxType.float64()), OnnxType.map(OnnxType.string(), OnnxType.float32()), OnnxType.map(OnnxType.string(), OnnxType.float64())))),
            T2(new OnnxType.TypeVariable("T2", List.of(OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public DictVectorizer(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        DictVectorizer(DictVectorizer that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public DictVectorizer transform(CopyContext cc, OpTransformer ot) {
            return new DictVectorizer(this, cc);
        }

        DictVectorizer(TypeElement resultType, Value X, java.util.Optional<String[]> string_vocabulary, java.util.Optional<long[]> int64_vocabulary) {
            super(SCHEMA, resultType, Set.of(), List.of(X), List.of(string_vocabulary, int64_vocabulary));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X()));
        }

        public Value X() {
            return operands().get(0);
        }

        public java.util.Optional<String[]> string_vocabulary() {
            String[] string_vocabulary = Attribute.string_vocabulary.access(String[].class, onnxAttributes);
            return java.util.Optional.ofNullable(string_vocabulary).map(String[]::clone);
        }

        public java.util.Optional<long[]> int64_vocabulary() {
            long[] int64_vocabulary = Attribute.int64_vocabulary.access(long[].class, onnxAttributes);
            return java.util.Optional.ofNullable(int64_vocabulary).map(long[]::clone);
        }

    }

    public static DictVectorizer DictVectorizer(TypeElement resultType, Value X, java.util.Optional<String[]> string_vocabulary, java.util.Optional<long[]> int64_vocabulary) {
        return new DictVectorizer(resultType, X, string_vocabulary, int64_vocabulary);
    }

    @OpFactoryHelper.OpDeclaration(Div.NAME)
    public static final class Div extends OnnxOp {
        public static final String NAME = "Div";

        public enum Attribute implements OnnxAttribute.None { }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            A(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            B(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            C(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public Div(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        Div(Div that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public Div transform(CopyContext cc, OpTransformer ot) {
            return new Div(this, cc);
        }

        Div(TypeElement resultType, Value A, Value B) {
            super(SCHEMA, resultType, Set.of(), List.of(A, B), List.of());
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(A(), B()));
        }

        public Value A() {
            return operands().get(0);
        }

        public Value B() {
            return operands().get(1);
        }

    }

    public static Div Div(TypeElement resultType, Value A, Value B) {
        return new Div(resultType, A, B);
    }

    @OpFactoryHelper.OpDeclaration(Dropout.NAME)
    public static final class Dropout extends OnnxOp {
        public static final String NAME = "Dropout";

        public enum Attribute implements OnnxAttribute {
            seed(Long.class, true, null),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.float8e4m3fn()), OnnxType.tensor(OnnxType.float8e4m3fnuz()), OnnxType.tensor(OnnxType.float8e5m2()), OnnxType.tensor(OnnxType.float8e5m2fnuz())))),
            T1(new OnnxType.TypeVariable("T1", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.float8e4m3fn()), OnnxType.tensor(OnnxType.float8e4m3fnuz()), OnnxType.tensor(OnnxType.float8e5m2()), OnnxType.tensor(OnnxType.float8e5m2fnuz())))),
            T2(new OnnxType.TypeVariable("T2", List.of(OnnxType.tensor(OnnxType.bool())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            data(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ratio(TypeConstraint.T1.typeVariable(), Quantifier.OPTIONAL),
            training_mode(TypeConstraint.T2.typeVariable(), Quantifier.OPTIONAL),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            mask(TypeConstraint.T2.typeVariable(), Quantifier.OPTIONAL),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public Dropout(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        Dropout(Dropout that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public Dropout transform(CopyContext cc, OpTransformer ot) {
            return new Dropout(this, cc);
        }

        Dropout(TypeElement resultType, Set<OutputParameter> optionalOutputs, Value data, java.util.Optional<Value> ratio, java.util.Optional<Value> training_mode, java.util.Optional<Long> seed) {
            super(SCHEMA, resultType, optionalOutputs, List.of(data, ratio, training_mode), List.of(seed));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(data(), ratio(), training_mode()));
        }

        public Value data() {
            return operands().get(0);
        }

        public java.util.Optional<Value> ratio() {
            int i = optionalInputArguments.indexOf(InputParameter.ratio);
            return i != -1 ? java.util.Optional.of(operands().get(1 + i)) : java.util.Optional.empty();
        }

        public java.util.Optional<Value> training_mode() {
            int i = optionalInputArguments.indexOf(InputParameter.training_mode);
            return i != -1 ? java.util.Optional.of(operands().get(1 + i)) : java.util.Optional.empty();
        }

        public java.util.Optional<Long> seed() {
            Long seed = Attribute.seed.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(seed);
        }

    }

    public static Dropout Dropout(TypeElement resultType, Set<Dropout.OutputParameter> optionalOutputs, Value data, java.util.Optional<Value> ratio, java.util.Optional<Value> training_mode, java.util.Optional<Long> seed) {
        return new Dropout(resultType, optionalOutputs, data, ratio, training_mode, seed);
    }

    @OpFactoryHelper.OpDeclaration(DynamicQuantizeLinear.NAME)
    public static final class DynamicQuantizeLinear extends OnnxOp {
        public static final String NAME = "DynamicQuantizeLinear";

        public enum Attribute implements OnnxAttribute.None { }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T1(new OnnxType.TypeVariable("T1", List.of(OnnxType.tensor(OnnxType.float32())))),
            T2(new OnnxType.TypeVariable("T2", List.of(OnnxType.tensor(OnnxType.uint8())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            x(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            y(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),
            y_scale(OnnxType.tensor(OnnxType.float32()), Quantifier.REQUIRED),
            y_zero_point(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public DynamicQuantizeLinear(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        DynamicQuantizeLinear(DynamicQuantizeLinear that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public DynamicQuantizeLinear transform(CopyContext cc, OpTransformer ot) {
            return new DynamicQuantizeLinear(this, cc);
        }

        DynamicQuantizeLinear(TypeElement resultType, Value x) {
            super(SCHEMA, resultType, Set.of(), List.of(x), List.of());
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(x()));
        }

        public Value x() {
            return operands().get(0);
        }

    }

    public static DynamicQuantizeLinear DynamicQuantizeLinear(TypeElement resultType, Value x) {
        return new DynamicQuantizeLinear(resultType, x);
    }

    @OpFactoryHelper.OpDeclaration(Einsum.NAME)
    public static final class Einsum extends OnnxOp {
        public static final String NAME = "Einsum";

        public enum Attribute implements OnnxAttribute {
            equation(String.class, false, null),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            Inputs(TypeConstraint.T.typeVariable(), Quantifier.VARIADIC),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            Output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public Einsum(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        Einsum(Einsum that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public Einsum transform(CopyContext cc, OpTransformer ot) {
            return new Einsum(this, cc);
        }

        Einsum(TypeElement resultType, List<Value> Inputs, String equation) {
            super(SCHEMA, resultType, Set.of(), List.of(Inputs), List.of(equation));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(Inputs()));
        }

        public List<Value> Inputs() {
            return operands();
        }

        public String equation() {
            String equation = Attribute.equation.access(String.class, onnxAttributes);
            return equation;
        }

    }

    public static Einsum Einsum(TypeElement resultType, List<Value> Inputs, String equation) {
        return new Einsum(resultType, Inputs, equation);
    }

    @OpFactoryHelper.OpDeclaration(Elu.NAME)
    public static final class Elu extends OnnxOp {
        public static final String NAME = "Elu";

        public enum Attribute implements OnnxAttribute {
            alpha(Float.class, true, 1.0f),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public Elu(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        Elu(Elu that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public Elu transform(CopyContext cc, OpTransformer ot) {
            return new Elu(this, cc);
        }

        Elu(TypeElement resultType, Value X, java.util.Optional<Float> alpha) {
            super(SCHEMA, resultType, Set.of(), List.of(X), List.of(alpha));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X()));
        }

        public Value X() {
            return operands().get(0);
        }

        public java.util.Optional<Float> alpha() {
            Float alpha = Attribute.alpha.access(Float.class, onnxAttributes);
            return java.util.Optional.ofNullable(alpha);
        }

    }

    public static Elu Elu(TypeElement resultType, Value X, java.util.Optional<Float> alpha) {
        return new Elu(resultType, X, alpha);
    }

    @OpFactoryHelper.OpDeclaration(Equal.NAME)
    public static final class Equal extends OnnxOp {
        public static final String NAME = "Equal";

        public enum Attribute implements OnnxAttribute.None { }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.string())))),
            T1(new OnnxType.TypeVariable("T1", List.of(OnnxType.tensor(OnnxType.bool())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            A(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            B(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            C(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public Equal(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        Equal(Equal that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public Equal transform(CopyContext cc, OpTransformer ot) {
            return new Equal(this, cc);
        }

        Equal(TypeElement resultType, Value A, Value B) {
            super(SCHEMA, resultType, Set.of(), List.of(A, B), List.of());
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(A(), B()));
        }

        public Value A() {
            return operands().get(0);
        }

        public Value B() {
            return operands().get(1);
        }

    }

    public static Equal Equal(TypeElement resultType, Value A, Value B) {
        return new Equal(resultType, A, B);
    }

    @OpFactoryHelper.OpDeclaration(Erf.NAME)
    public static final class Erf extends OnnxOp {
        public static final String NAME = "Erf";

        public enum Attribute implements OnnxAttribute.None { }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            input(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public Erf(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        Erf(Erf that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public Erf transform(CopyContext cc, OpTransformer ot) {
            return new Erf(this, cc);
        }

        Erf(TypeElement resultType, Value input) {
            super(SCHEMA, resultType, Set.of(), List.of(input), List.of());
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(input()));
        }

        public Value input() {
            return operands().get(0);
        }

    }

    public static Erf Erf(TypeElement resultType, Value input) {
        return new Erf(resultType, input);
    }

    @OpFactoryHelper.OpDeclaration(Exp.NAME)
    public static final class Exp extends OnnxOp {
        public static final String NAME = "Exp";

        public enum Attribute implements OnnxAttribute.None { }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            input(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public Exp(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        Exp(Exp that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public Exp transform(CopyContext cc, OpTransformer ot) {
            return new Exp(this, cc);
        }

        Exp(TypeElement resultType, Value input) {
            super(SCHEMA, resultType, Set.of(), List.of(input), List.of());
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(input()));
        }

        public Value input() {
            return operands().get(0);
        }

    }

    public static Exp Exp(TypeElement resultType, Value input) {
        return new Exp(resultType, input);
    }

    @OpFactoryHelper.OpDeclaration(Expand.NAME)
    public static final class Expand extends OnnxOp {
        public static final String NAME = "Expand";

        public enum Attribute implements OnnxAttribute.None { }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            input(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            shape(OnnxType.tensor(OnnxType.int64()), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public Expand(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        Expand(Expand that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public Expand transform(CopyContext cc, OpTransformer ot) {
            return new Expand(this, cc);
        }

        Expand(TypeElement resultType, Value input, Value shape) {
            super(SCHEMA, resultType, Set.of(), List.of(input, shape), List.of());
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(input(), shape()));
        }

        public Value input() {
            return operands().get(0);
        }

        public Value shape() {
            return operands().get(1);
        }

    }

    public static Expand Expand(TypeElement resultType, Value input, Value shape) {
        return new Expand(resultType, input, shape);
    }

    @OpFactoryHelper.OpDeclaration(EyeLike.NAME)
    public static final class EyeLike extends OnnxOp {
        public static final String NAME = "EyeLike";

        public enum Attribute implements OnnxAttribute {
            dtype(Long.class, true, null),
            k(Long.class, true, 0),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T1(new OnnxType.TypeVariable("T1", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bool())))),
            T2(new OnnxType.TypeVariable("T2", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bool())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            input(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public EyeLike(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        EyeLike(EyeLike that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public EyeLike transform(CopyContext cc, OpTransformer ot) {
            return new EyeLike(this, cc);
        }

        EyeLike(TypeElement resultType, Value input, java.util.Optional<Long> dtype, java.util.Optional<Long> k) {
            super(SCHEMA, resultType, Set.of(), List.of(input), List.of(dtype, k));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(input()));
        }

        public Value input() {
            return operands().get(0);
        }

        public java.util.Optional<Long> dtype() {
            Long dtype = Attribute.dtype.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(dtype);
        }

        public java.util.Optional<Long> k() {
            Long k = Attribute.k.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(k);
        }

    }

    public static EyeLike EyeLike(TypeElement resultType, Value input, java.util.Optional<Long> dtype, java.util.Optional<Long> k) {
        return new EyeLike(resultType, input, dtype, k);
    }

    @OpFactoryHelper.OpDeclaration(FeatureVectorizer.NAME)
    public static final class FeatureVectorizer extends OnnxOp {
        public static final String NAME = "FeatureVectorizer";

        public enum Attribute implements OnnxAttribute {
            inputdimensions(long[].class, true, null),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T1(new OnnxType.TypeVariable("T1", List.of(OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T1.typeVariable(), Quantifier.VARIADIC),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            Y(OnnxType.tensor(OnnxType.float32()), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public FeatureVectorizer(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        FeatureVectorizer(FeatureVectorizer that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public FeatureVectorizer transform(CopyContext cc, OpTransformer ot) {
            return new FeatureVectorizer(this, cc);
        }

        FeatureVectorizer(TypeElement resultType, List<Value> X, java.util.Optional<long[]> inputdimensions) {
            super(SCHEMA, resultType, Set.of(), List.of(X), List.of(inputdimensions));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X()));
        }

        public List<Value> X() {
            return operands();
        }

        public java.util.Optional<long[]> inputdimensions() {
            long[] inputdimensions = Attribute.inputdimensions.access(long[].class, onnxAttributes);
            return java.util.Optional.ofNullable(inputdimensions).map(long[]::clone);
        }

    }

    public static FeatureVectorizer FeatureVectorizer(TypeElement resultType, List<Value> X, java.util.Optional<long[]> inputdimensions) {
        return new FeatureVectorizer(resultType, X, inputdimensions);
    }

    @OpFactoryHelper.OpDeclaration(Flatten.NAME)
    public static final class Flatten extends OnnxOp {
        public static final String NAME = "Flatten";

        public enum Attribute implements OnnxAttribute {
            axis(Long.class, true, 1),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128()), OnnxType.tensor(OnnxType.float8e4m3fn()), OnnxType.tensor(OnnxType.float8e4m3fnuz()), OnnxType.tensor(OnnxType.float8e5m2()), OnnxType.tensor(OnnxType.float8e5m2fnuz()), OnnxType.tensor(OnnxType.uint4()), OnnxType.tensor(OnnxType.int4()), OnnxType.tensor(OnnxType.float4e2m1())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            input(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public Flatten(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        Flatten(Flatten that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public Flatten transform(CopyContext cc, OpTransformer ot) {
            return new Flatten(this, cc);
        }

        Flatten(TypeElement resultType, Value input, java.util.Optional<Long> axis) {
            super(SCHEMA, resultType, Set.of(), List.of(input), List.of(axis));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(input()));
        }

        public Value input() {
            return operands().get(0);
        }

        public java.util.Optional<Long> axis() {
            Long axis = Attribute.axis.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(axis);
        }

    }

    public static Flatten Flatten(TypeElement resultType, Value input, java.util.Optional<Long> axis) {
        return new Flatten(resultType, input, axis);
    }

    @OpFactoryHelper.OpDeclaration(Floor.NAME)
    public static final class Floor extends OnnxOp {
        public static final String NAME = "Floor";

        public enum Attribute implements OnnxAttribute.None { }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public Floor(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        Floor(Floor that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public Floor transform(CopyContext cc, OpTransformer ot) {
            return new Floor(this, cc);
        }

        Floor(TypeElement resultType, Value X) {
            super(SCHEMA, resultType, Set.of(), List.of(X), List.of());
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X()));
        }

        public Value X() {
            return operands().get(0);
        }

    }

    public static Floor Floor(TypeElement resultType, Value X) {
        return new Floor(resultType, X);
    }

    @OpFactoryHelper.OpDeclaration(GRU.NAME)
    public static final class GRU extends OnnxOp {
        public static final String NAME = "GRU";

        public enum Attribute implements OnnxAttribute {
            layout(Long.class, true, 0),
            activation_alpha(float[].class, true, null),
            hidden_size(Long.class, true, null),
            activation_beta(float[].class, true, null),
            activations(String[].class, true, null),
            linear_before_reset(Long.class, true, 0),
            clip(Float.class, true, null),
            direction(String.class, true, "forward"),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),
            T1(new OnnxType.TypeVariable("T1", List.of(OnnxType.tensor(OnnxType.int32())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            W(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            R(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            B(TypeConstraint.T.typeVariable(), Quantifier.OPTIONAL),
            sequence_lens(TypeConstraint.T1.typeVariable(), Quantifier.OPTIONAL),
            initial_h(TypeConstraint.T.typeVariable(), Quantifier.OPTIONAL),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T.typeVariable(), Quantifier.OPTIONAL),
            Y_h(TypeConstraint.T.typeVariable(), Quantifier.OPTIONAL),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public GRU(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        GRU(GRU that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public GRU transform(CopyContext cc, OpTransformer ot) {
            return new GRU(this, cc);
        }

        GRU(TypeElement resultType, Set<OutputParameter> optionalOutputs, Value X, Value W, Value R, java.util.Optional<Value> B, java.util.Optional<Value> sequence_lens, java.util.Optional<Value> initial_h, java.util.Optional<Long> layout, java.util.Optional<float[]> activation_alpha, java.util.Optional<Long> hidden_size, java.util.Optional<float[]> activation_beta, java.util.Optional<String[]> activations, java.util.Optional<Long> linear_before_reset, java.util.Optional<Float> clip, java.util.Optional<String> direction) {
            super(SCHEMA, resultType, optionalOutputs, List.of(X, W, R, B, sequence_lens, initial_h), List.of(layout, activation_alpha, hidden_size, activation_beta, activations, linear_before_reset, clip, direction));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X(), W(), R(), B(), sequence_lens(), initial_h()));
        }

        public Value X() {
            return operands().get(0);
        }

        public Value W() {
            return operands().get(1);
        }

        public Value R() {
            return operands().get(2);
        }

        public java.util.Optional<Value> B() {
            int i = optionalInputArguments.indexOf(InputParameter.B);
            return i != -1 ? java.util.Optional.of(operands().get(3 + i)) : java.util.Optional.empty();
        }

        public java.util.Optional<Value> sequence_lens() {
            int i = optionalInputArguments.indexOf(InputParameter.sequence_lens);
            return i != -1 ? java.util.Optional.of(operands().get(3 + i)) : java.util.Optional.empty();
        }

        public java.util.Optional<Value> initial_h() {
            int i = optionalInputArguments.indexOf(InputParameter.initial_h);
            return i != -1 ? java.util.Optional.of(operands().get(3 + i)) : java.util.Optional.empty();
        }

        public java.util.Optional<Long> layout() {
            Long layout = Attribute.layout.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(layout);
        }

        public java.util.Optional<float[]> activation_alpha() {
            float[] activation_alpha = Attribute.activation_alpha.access(float[].class, onnxAttributes);
            return java.util.Optional.ofNullable(activation_alpha).map(float[]::clone);
        }

        public java.util.Optional<Long> hidden_size() {
            Long hidden_size = Attribute.hidden_size.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(hidden_size);
        }

        public java.util.Optional<float[]> activation_beta() {
            float[] activation_beta = Attribute.activation_beta.access(float[].class, onnxAttributes);
            return java.util.Optional.ofNullable(activation_beta).map(float[]::clone);
        }

        public java.util.Optional<String[]> activations() {
            String[] activations = Attribute.activations.access(String[].class, onnxAttributes);
            return java.util.Optional.ofNullable(activations).map(String[]::clone);
        }

        public java.util.Optional<Long> linear_before_reset() {
            Long linear_before_reset = Attribute.linear_before_reset.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(linear_before_reset);
        }

        public java.util.Optional<Float> clip() {
            Float clip = Attribute.clip.access(Float.class, onnxAttributes);
            return java.util.Optional.ofNullable(clip);
        }

        public java.util.Optional<String> direction() {
            String direction = Attribute.direction.access(String.class, onnxAttributes);
            return java.util.Optional.ofNullable(direction);
        }

    }

    public static GRU GRU(TypeElement resultType, Set<GRU.OutputParameter> optionalOutputs, Value X, Value W, Value R, java.util.Optional<Value> B, java.util.Optional<Value> sequence_lens, java.util.Optional<Value> initial_h, java.util.Optional<Long> layout, java.util.Optional<float[]> activation_alpha, java.util.Optional<Long> hidden_size, java.util.Optional<float[]> activation_beta, java.util.Optional<String[]> activations, java.util.Optional<Long> linear_before_reset, java.util.Optional<Float> clip, java.util.Optional<String> direction) {
        return new GRU(resultType, optionalOutputs, X, W, R, B, sequence_lens, initial_h, layout, activation_alpha, hidden_size, activation_beta, activations, linear_before_reset, clip, direction);
    }

    @OpFactoryHelper.OpDeclaration(Gather.NAME)
    public static final class Gather extends OnnxOp {
        public static final String NAME = "Gather";

        public enum Attribute implements OnnxAttribute {
            axis(Long.class, true, 0),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128())))),
            Tind(new OnnxType.TypeVariable("Tind", List.of(OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            data(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            indices(TypeConstraint.Tind.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public Gather(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        Gather(Gather that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public Gather transform(CopyContext cc, OpTransformer ot) {
            return new Gather(this, cc);
        }

        Gather(TypeElement resultType, Value data, Value indices, java.util.Optional<Long> axis) {
            super(SCHEMA, resultType, Set.of(), List.of(data, indices), List.of(axis));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(data(), indices()));
        }

        public Value data() {
            return operands().get(0);
        }

        public Value indices() {
            return operands().get(1);
        }

        public java.util.Optional<Long> axis() {
            Long axis = Attribute.axis.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(axis);
        }

    }

    public static Gather Gather(TypeElement resultType, Value data, Value indices, java.util.Optional<Long> axis) {
        return new Gather(resultType, data, indices, axis);
    }

    @OpFactoryHelper.OpDeclaration(GatherElements.NAME)
    public static final class GatherElements extends OnnxOp {
        public static final String NAME = "GatherElements";

        public enum Attribute implements OnnxAttribute {
            axis(Long.class, true, 0),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128())))),
            Tind(new OnnxType.TypeVariable("Tind", List.of(OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            data(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            indices(TypeConstraint.Tind.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public GatherElements(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        GatherElements(GatherElements that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public GatherElements transform(CopyContext cc, OpTransformer ot) {
            return new GatherElements(this, cc);
        }

        GatherElements(TypeElement resultType, Value data, Value indices, java.util.Optional<Long> axis) {
            super(SCHEMA, resultType, Set.of(), List.of(data, indices), List.of(axis));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(data(), indices()));
        }

        public Value data() {
            return operands().get(0);
        }

        public Value indices() {
            return operands().get(1);
        }

        public java.util.Optional<Long> axis() {
            Long axis = Attribute.axis.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(axis);
        }

    }

    public static GatherElements GatherElements(TypeElement resultType, Value data, Value indices, java.util.Optional<Long> axis) {
        return new GatherElements(resultType, data, indices, axis);
    }

    @OpFactoryHelper.OpDeclaration(GatherND.NAME)
    public static final class GatherND extends OnnxOp {
        public static final String NAME = "GatherND";

        public enum Attribute implements OnnxAttribute {
            batch_dims(Long.class, true, 0),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            data(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            indices(OnnxType.tensor(OnnxType.int64()), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public GatherND(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        GatherND(GatherND that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public GatherND transform(CopyContext cc, OpTransformer ot) {
            return new GatherND(this, cc);
        }

        GatherND(TypeElement resultType, Value data, Value indices, java.util.Optional<Long> batch_dims) {
            super(SCHEMA, resultType, Set.of(), List.of(data, indices), List.of(batch_dims));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(data(), indices()));
        }

        public Value data() {
            return operands().get(0);
        }

        public Value indices() {
            return operands().get(1);
        }

        public java.util.Optional<Long> batch_dims() {
            Long batch_dims = Attribute.batch_dims.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(batch_dims);
        }

    }

    public static GatherND GatherND(TypeElement resultType, Value data, Value indices, java.util.Optional<Long> batch_dims) {
        return new GatherND(resultType, data, indices, batch_dims);
    }

    @OpFactoryHelper.OpDeclaration(Gelu.NAME)
    public static final class Gelu extends OnnxOp {
        public static final String NAME = "Gelu";

        public enum Attribute implements OnnxAttribute {
            approximate(String.class, true, "none"),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public Gelu(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        Gelu(Gelu that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public Gelu transform(CopyContext cc, OpTransformer ot) {
            return new Gelu(this, cc);
        }

        Gelu(TypeElement resultType, Value X, java.util.Optional<String> approximate) {
            super(SCHEMA, resultType, Set.of(), List.of(X), List.of(approximate));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X()));
        }

        public Value X() {
            return operands().get(0);
        }

        public java.util.Optional<String> approximate() {
            String approximate = Attribute.approximate.access(String.class, onnxAttributes);
            return java.util.Optional.ofNullable(approximate);
        }

    }

    public static Gelu Gelu(TypeElement resultType, Value X, java.util.Optional<String> approximate) {
        return new Gelu(resultType, X, approximate);
    }

    @OpFactoryHelper.OpDeclaration(Gemm.NAME)
    public static final class Gemm extends OnnxOp {
        public static final String NAME = "Gemm";

        public enum Attribute implements OnnxAttribute {
            alpha(Float.class, true, 1.0f),
            transB(Long.class, true, 0),
            beta(Float.class, true, 1.0f),
            transA(Long.class, true, 0),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            A(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            B(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            C(TypeConstraint.T.typeVariable(), Quantifier.OPTIONAL),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public Gemm(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        Gemm(Gemm that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public Gemm transform(CopyContext cc, OpTransformer ot) {
            return new Gemm(this, cc);
        }

        Gemm(TypeElement resultType, Value A, Value B, java.util.Optional<Value> C, java.util.Optional<Float> alpha, java.util.Optional<Long> transB, java.util.Optional<Float> beta, java.util.Optional<Long> transA) {
            super(SCHEMA, resultType, Set.of(), List.of(A, B, C), List.of(alpha, transB, beta, transA));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(A(), B(), C()));
        }

        public Value A() {
            return operands().get(0);
        }

        public Value B() {
            return operands().get(1);
        }

        public java.util.Optional<Value> C() {
            int i = optionalInputArguments.indexOf(InputParameter.C);
            return i != -1 ? java.util.Optional.of(operands().get(2 + i)) : java.util.Optional.empty();
        }

        public java.util.Optional<Float> alpha() {
            Float alpha = Attribute.alpha.access(Float.class, onnxAttributes);
            return java.util.Optional.ofNullable(alpha);
        }

        public java.util.Optional<Long> transB() {
            Long transB = Attribute.transB.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(transB);
        }

        public java.util.Optional<Float> beta() {
            Float beta = Attribute.beta.access(Float.class, onnxAttributes);
            return java.util.Optional.ofNullable(beta);
        }

        public java.util.Optional<Long> transA() {
            Long transA = Attribute.transA.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(transA);
        }

    }

    public static Gemm Gemm(TypeElement resultType, Value A, Value B, java.util.Optional<Value> C, java.util.Optional<Float> alpha, java.util.Optional<Long> transB, java.util.Optional<Float> beta, java.util.Optional<Long> transA) {
        return new Gemm(resultType, A, B, C, alpha, transB, beta, transA);
    }

    @OpFactoryHelper.OpDeclaration(GlobalAveragePool.NAME)
    public static final class GlobalAveragePool extends OnnxOp {
        public static final String NAME = "GlobalAveragePool";

        public enum Attribute implements OnnxAttribute.None { }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public GlobalAveragePool(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        GlobalAveragePool(GlobalAveragePool that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public GlobalAveragePool transform(CopyContext cc, OpTransformer ot) {
            return new GlobalAveragePool(this, cc);
        }

        GlobalAveragePool(TypeElement resultType, Value X) {
            super(SCHEMA, resultType, Set.of(), List.of(X), List.of());
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X()));
        }

        public Value X() {
            return operands().get(0);
        }

    }

    public static GlobalAveragePool GlobalAveragePool(TypeElement resultType, Value X) {
        return new GlobalAveragePool(resultType, X);
    }

    @OpFactoryHelper.OpDeclaration(GlobalLpPool.NAME)
    public static final class GlobalLpPool extends OnnxOp {
        public static final String NAME = "GlobalLpPool";

        public enum Attribute implements OnnxAttribute {
            p(Long.class, true, 2),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public GlobalLpPool(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        GlobalLpPool(GlobalLpPool that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public GlobalLpPool transform(CopyContext cc, OpTransformer ot) {
            return new GlobalLpPool(this, cc);
        }

        GlobalLpPool(TypeElement resultType, Value X, java.util.Optional<Long> p) {
            super(SCHEMA, resultType, Set.of(), List.of(X), List.of(p));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X()));
        }

        public Value X() {
            return operands().get(0);
        }

        public java.util.Optional<Long> p() {
            Long p = Attribute.p.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(p);
        }

    }

    public static GlobalLpPool GlobalLpPool(TypeElement resultType, Value X, java.util.Optional<Long> p) {
        return new GlobalLpPool(resultType, X, p);
    }

    @OpFactoryHelper.OpDeclaration(GlobalMaxPool.NAME)
    public static final class GlobalMaxPool extends OnnxOp {
        public static final String NAME = "GlobalMaxPool";

        public enum Attribute implements OnnxAttribute.None { }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public GlobalMaxPool(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        GlobalMaxPool(GlobalMaxPool that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public GlobalMaxPool transform(CopyContext cc, OpTransformer ot) {
            return new GlobalMaxPool(this, cc);
        }

        GlobalMaxPool(TypeElement resultType, Value X) {
            super(SCHEMA, resultType, Set.of(), List.of(X), List.of());
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X()));
        }

        public Value X() {
            return operands().get(0);
        }

    }

    public static GlobalMaxPool GlobalMaxPool(TypeElement resultType, Value X) {
        return new GlobalMaxPool(resultType, X);
    }

    @OpFactoryHelper.OpDeclaration(Gradient.NAME)
    public static final class Gradient extends OnnxOp {
        public static final String NAME = "Gradient";

        public enum Attribute implements OnnxAttribute {
            y(String.class, false, null),
            zs(String[].class, true, null),
            xs(String[].class, false, null),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T1(new OnnxType.TypeVariable("T1", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128())))),
            T2(new OnnxType.TypeVariable("T2", List.of(OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            Inputs(TypeConstraint.T1.typeVariable(), Quantifier.VARIADIC),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            Outputs(TypeConstraint.T2.typeVariable(), Quantifier.VARIADIC),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public Gradient(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        Gradient(Gradient that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public Gradient transform(CopyContext cc, OpTransformer ot) {
            return new Gradient(this, cc);
        }

        Gradient(TypeElement resultType, List<Value> Inputs, String y, java.util.Optional<String[]> zs, String[] xs) {
            super(SCHEMA, resultType, Set.of(), List.of(Inputs), List.of(y, zs, xs));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(Inputs()));
        }

        public List<Value> Inputs() {
            return operands();
        }

        public String y() {
            String y = Attribute.y.access(String.class, onnxAttributes);
            return y;
        }

        public java.util.Optional<String[]> zs() {
            String[] zs = Attribute.zs.access(String[].class, onnxAttributes);
            return java.util.Optional.ofNullable(zs).map(String[]::clone);
        }

        public String[] xs() {
            String[] xs = Attribute.xs.access(String[].class, onnxAttributes);
            return xs.clone();
        }

    }

    public static Gradient Gradient(TypeElement resultType, List<Value> Inputs, String y, java.util.Optional<String[]> zs, String[] xs) {
        return new Gradient(resultType, Inputs, y, zs, xs);
    }

    @OpFactoryHelper.OpDeclaration(Greater.NAME)
    public static final class Greater extends OnnxOp {
        public static final String NAME = "Greater";

        public enum Attribute implements OnnxAttribute.None { }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),
            T1(new OnnxType.TypeVariable("T1", List.of(OnnxType.tensor(OnnxType.bool())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            A(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            B(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            C(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public Greater(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        Greater(Greater that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public Greater transform(CopyContext cc, OpTransformer ot) {
            return new Greater(this, cc);
        }

        Greater(TypeElement resultType, Value A, Value B) {
            super(SCHEMA, resultType, Set.of(), List.of(A, B), List.of());
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(A(), B()));
        }

        public Value A() {
            return operands().get(0);
        }

        public Value B() {
            return operands().get(1);
        }

    }

    public static Greater Greater(TypeElement resultType, Value A, Value B) {
        return new Greater(resultType, A, B);
    }

    @OpFactoryHelper.OpDeclaration(GreaterOrEqual.NAME)
    public static final class GreaterOrEqual extends OnnxOp {
        public static final String NAME = "GreaterOrEqual";

        public enum Attribute implements OnnxAttribute.None { }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),
            T1(new OnnxType.TypeVariable("T1", List.of(OnnxType.tensor(OnnxType.bool())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            A(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            B(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            C(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public GreaterOrEqual(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        GreaterOrEqual(GreaterOrEqual that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public GreaterOrEqual transform(CopyContext cc, OpTransformer ot) {
            return new GreaterOrEqual(this, cc);
        }

        GreaterOrEqual(TypeElement resultType, Value A, Value B) {
            super(SCHEMA, resultType, Set.of(), List.of(A, B), List.of());
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(A(), B()));
        }

        public Value A() {
            return operands().get(0);
        }

        public Value B() {
            return operands().get(1);
        }

    }

    public static GreaterOrEqual GreaterOrEqual(TypeElement resultType, Value A, Value B) {
        return new GreaterOrEqual(resultType, A, B);
    }

    @OpFactoryHelper.OpDeclaration(GridSample.NAME)
    public static final class GridSample extends OnnxOp {
        public static final String NAME = "GridSample";

        public enum Attribute implements OnnxAttribute {
            mode(String.class, true, "linear"),
            align_corners(Long.class, true, 0),
            padding_mode(String.class, true, "zeros"),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T1(new OnnxType.TypeVariable("T1", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128())))),
            T2(new OnnxType.TypeVariable("T2", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            grid(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public GridSample(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        GridSample(GridSample that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public GridSample transform(CopyContext cc, OpTransformer ot) {
            return new GridSample(this, cc);
        }

        GridSample(TypeElement resultType, Value X, Value grid, java.util.Optional<String> mode, java.util.Optional<Long> align_corners, java.util.Optional<String> padding_mode) {
            super(SCHEMA, resultType, Set.of(), List.of(X, grid), List.of(mode, align_corners, padding_mode));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X(), grid()));
        }

        public Value X() {
            return operands().get(0);
        }

        public Value grid() {
            return operands().get(1);
        }

        public java.util.Optional<String> mode() {
            String mode = Attribute.mode.access(String.class, onnxAttributes);
            return java.util.Optional.ofNullable(mode);
        }

        public java.util.Optional<Long> align_corners() {
            Long align_corners = Attribute.align_corners.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(align_corners);
        }

        public java.util.Optional<String> padding_mode() {
            String padding_mode = Attribute.padding_mode.access(String.class, onnxAttributes);
            return java.util.Optional.ofNullable(padding_mode);
        }

    }

    public static GridSample GridSample(TypeElement resultType, Value X, Value grid, java.util.Optional<String> mode, java.util.Optional<Long> align_corners, java.util.Optional<String> padding_mode) {
        return new GridSample(resultType, X, grid, mode, align_corners, padding_mode);
    }

    @OpFactoryHelper.OpDeclaration(GroupNormalization.NAME)
    public static final class GroupNormalization extends OnnxOp {
        public static final String NAME = "GroupNormalization";

        public enum Attribute implements OnnxAttribute {
            epsilon(Float.class, true, 1.0E-5f),
            stash_type(Long.class, true, 1),
            num_groups(Long.class, false, null),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            scale(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            bias(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public GroupNormalization(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        GroupNormalization(GroupNormalization that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public GroupNormalization transform(CopyContext cc, OpTransformer ot) {
            return new GroupNormalization(this, cc);
        }

        GroupNormalization(TypeElement resultType, Value X, Value scale, Value bias, java.util.Optional<Float> epsilon, java.util.Optional<Long> stash_type, long num_groups) {
            super(SCHEMA, resultType, Set.of(), List.of(X, scale, bias), List.of(epsilon, stash_type, num_groups));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X(), scale(), bias()));
        }

        public Value X() {
            return operands().get(0);
        }

        public Value scale() {
            return operands().get(1);
        }

        public Value bias() {
            return operands().get(2);
        }

        public java.util.Optional<Float> epsilon() {
            Float epsilon = Attribute.epsilon.access(Float.class, onnxAttributes);
            return java.util.Optional.ofNullable(epsilon);
        }

        public java.util.Optional<Long> stash_type() {
            Long stash_type = Attribute.stash_type.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(stash_type);
        }

        public long num_groups() {
            long num_groups = Attribute.num_groups.access(Long.class, onnxAttributes);
            return num_groups;
        }

    }

    public static GroupNormalization GroupNormalization(TypeElement resultType, Value X, Value scale, Value bias, java.util.Optional<Float> epsilon, java.util.Optional<Long> stash_type, long num_groups) {
        return new GroupNormalization(resultType, X, scale, bias, epsilon, stash_type, num_groups);
    }

    @OpFactoryHelper.OpDeclaration(HammingWindow.NAME)
    public static final class HammingWindow extends OnnxOp {
        public static final String NAME = "HammingWindow";

        public enum Attribute implements OnnxAttribute {
            periodic(Long.class, true, 1),
            output_datatype(Long.class, true, 1),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T1(new OnnxType.TypeVariable("T1", List.of(OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64())))),
            T2(new OnnxType.TypeVariable("T2", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            size(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public HammingWindow(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        HammingWindow(HammingWindow that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public HammingWindow transform(CopyContext cc, OpTransformer ot) {
            return new HammingWindow(this, cc);
        }

        HammingWindow(TypeElement resultType, Value size, java.util.Optional<Long> periodic, java.util.Optional<Long> output_datatype) {
            super(SCHEMA, resultType, Set.of(), List.of(size), List.of(periodic, output_datatype));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(size()));
        }

        public Value size() {
            return operands().get(0);
        }

        public java.util.Optional<Long> periodic() {
            Long periodic = Attribute.periodic.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(periodic);
        }

        public java.util.Optional<Long> output_datatype() {
            Long output_datatype = Attribute.output_datatype.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(output_datatype);
        }

    }

    public static HammingWindow HammingWindow(TypeElement resultType, Value size, java.util.Optional<Long> periodic, java.util.Optional<Long> output_datatype) {
        return new HammingWindow(resultType, size, periodic, output_datatype);
    }

    @OpFactoryHelper.OpDeclaration(HannWindow.NAME)
    public static final class HannWindow extends OnnxOp {
        public static final String NAME = "HannWindow";

        public enum Attribute implements OnnxAttribute {
            periodic(Long.class, true, 1),
            output_datatype(Long.class, true, 1),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T1(new OnnxType.TypeVariable("T1", List.of(OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64())))),
            T2(new OnnxType.TypeVariable("T2", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            size(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public HannWindow(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        HannWindow(HannWindow that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public HannWindow transform(CopyContext cc, OpTransformer ot) {
            return new HannWindow(this, cc);
        }

        HannWindow(TypeElement resultType, Value size, java.util.Optional<Long> periodic, java.util.Optional<Long> output_datatype) {
            super(SCHEMA, resultType, Set.of(), List.of(size), List.of(periodic, output_datatype));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(size()));
        }

        public Value size() {
            return operands().get(0);
        }

        public java.util.Optional<Long> periodic() {
            Long periodic = Attribute.periodic.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(periodic);
        }

        public java.util.Optional<Long> output_datatype() {
            Long output_datatype = Attribute.output_datatype.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(output_datatype);
        }

    }

    public static HannWindow HannWindow(TypeElement resultType, Value size, java.util.Optional<Long> periodic, java.util.Optional<Long> output_datatype) {
        return new HannWindow(resultType, size, periodic, output_datatype);
    }

    @OpFactoryHelper.OpDeclaration(HardSigmoid.NAME)
    public static final class HardSigmoid extends OnnxOp {
        public static final String NAME = "HardSigmoid";

        public enum Attribute implements OnnxAttribute {
            alpha(Float.class, true, 0.2f),
            beta(Float.class, true, 0.5f),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public HardSigmoid(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        HardSigmoid(HardSigmoid that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public HardSigmoid transform(CopyContext cc, OpTransformer ot) {
            return new HardSigmoid(this, cc);
        }

        HardSigmoid(TypeElement resultType, Value X, java.util.Optional<Float> alpha, java.util.Optional<Float> beta) {
            super(SCHEMA, resultType, Set.of(), List.of(X), List.of(alpha, beta));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X()));
        }

        public Value X() {
            return operands().get(0);
        }

        public java.util.Optional<Float> alpha() {
            Float alpha = Attribute.alpha.access(Float.class, onnxAttributes);
            return java.util.Optional.ofNullable(alpha);
        }

        public java.util.Optional<Float> beta() {
            Float beta = Attribute.beta.access(Float.class, onnxAttributes);
            return java.util.Optional.ofNullable(beta);
        }

    }

    public static HardSigmoid HardSigmoid(TypeElement resultType, Value X, java.util.Optional<Float> alpha, java.util.Optional<Float> beta) {
        return new HardSigmoid(resultType, X, alpha, beta);
    }

    @OpFactoryHelper.OpDeclaration(HardSwish.NAME)
    public static final class HardSwish extends OnnxOp {
        public static final String NAME = "HardSwish";

        public enum Attribute implements OnnxAttribute.None { }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public HardSwish(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        HardSwish(HardSwish that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public HardSwish transform(CopyContext cc, OpTransformer ot) {
            return new HardSwish(this, cc);
        }

        HardSwish(TypeElement resultType, Value X) {
            super(SCHEMA, resultType, Set.of(), List.of(X), List.of());
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X()));
        }

        public Value X() {
            return operands().get(0);
        }

    }

    public static HardSwish HardSwish(TypeElement resultType, Value X) {
        return new HardSwish(resultType, X);
    }

    @OpFactoryHelper.OpDeclaration(Hardmax.NAME)
    public static final class Hardmax extends OnnxOp {
        public static final String NAME = "Hardmax";

        public enum Attribute implements OnnxAttribute {
            axis(Long.class, true, -1),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            input(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public Hardmax(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        Hardmax(Hardmax that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public Hardmax transform(CopyContext cc, OpTransformer ot) {
            return new Hardmax(this, cc);
        }

        Hardmax(TypeElement resultType, Value input, java.util.Optional<Long> axis) {
            super(SCHEMA, resultType, Set.of(), List.of(input), List.of(axis));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(input()));
        }

        public Value input() {
            return operands().get(0);
        }

        public java.util.Optional<Long> axis() {
            Long axis = Attribute.axis.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(axis);
        }

    }

    public static Hardmax Hardmax(TypeElement resultType, Value input, java.util.Optional<Long> axis) {
        return new Hardmax(resultType, input, axis);
    }

    @OpFactoryHelper.OpDeclaration(Identity.NAME)
    public static final class Identity extends OnnxOp {
        public static final String NAME = "Identity";

        public enum Attribute implements OnnxAttribute.None { }

        public enum TypeConstraint implements OnnxTypeConstraint {
            V(new OnnxType.TypeVariable("V", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128()), OnnxType.tensor(OnnxType.float8e4m3fn()), OnnxType.tensor(OnnxType.float8e4m3fnuz()), OnnxType.tensor(OnnxType.float8e5m2()), OnnxType.tensor(OnnxType.float8e5m2fnuz()), OnnxType.tensor(OnnxType.uint4()), OnnxType.tensor(OnnxType.int4()), OnnxType.tensor(OnnxType.float4e2m1()), OnnxType.seq(OnnxType.tensor(OnnxType.uint8())), OnnxType.seq(OnnxType.tensor(OnnxType.uint16())), OnnxType.seq(OnnxType.tensor(OnnxType.uint32())), OnnxType.seq(OnnxType.tensor(OnnxType.uint64())), OnnxType.seq(OnnxType.tensor(OnnxType.int8())), OnnxType.seq(OnnxType.tensor(OnnxType.int16())), OnnxType.seq(OnnxType.tensor(OnnxType.int32())), OnnxType.seq(OnnxType.tensor(OnnxType.int64())), OnnxType.seq(OnnxType.tensor(OnnxType.float16())), OnnxType.seq(OnnxType.tensor(OnnxType.float32())), OnnxType.seq(OnnxType.tensor(OnnxType.float64())), OnnxType.seq(OnnxType.tensor(OnnxType.string())), OnnxType.seq(OnnxType.tensor(OnnxType.bool())), OnnxType.seq(OnnxType.tensor(OnnxType.complex64())), OnnxType.seq(OnnxType.tensor(OnnxType.complex128())), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.uint8()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.uint16()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.uint32()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.uint64()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.int8()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.int16()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.int32()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.int64()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.float16()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.float32()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.float64()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.string()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.bool()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.complex64()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.complex128()))), OnnxType.optional(OnnxType.tensor(OnnxType.uint8())), OnnxType.optional(OnnxType.tensor(OnnxType.uint16())), OnnxType.optional(OnnxType.tensor(OnnxType.uint32())), OnnxType.optional(OnnxType.tensor(OnnxType.uint64())), OnnxType.optional(OnnxType.tensor(OnnxType.int8())), OnnxType.optional(OnnxType.tensor(OnnxType.int16())), OnnxType.optional(OnnxType.tensor(OnnxType.int32())), OnnxType.optional(OnnxType.tensor(OnnxType.int64())), OnnxType.optional(OnnxType.tensor(OnnxType.float16())), OnnxType.optional(OnnxType.tensor(OnnxType.float32())), OnnxType.optional(OnnxType.tensor(OnnxType.float64())), OnnxType.optional(OnnxType.tensor(OnnxType.string())), OnnxType.optional(OnnxType.tensor(OnnxType.bool())), OnnxType.optional(OnnxType.tensor(OnnxType.complex64())), OnnxType.optional(OnnxType.tensor(OnnxType.complex128()))))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            input(TypeConstraint.V.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.V.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public Identity(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        Identity(Identity that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public Identity transform(CopyContext cc, OpTransformer ot) {
            return new Identity(this, cc);
        }

        Identity(TypeElement resultType, Value input) {
            super(SCHEMA, resultType, Set.of(), List.of(input), List.of());
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(input()));
        }

        public Value input() {
            return operands().get(0);
        }

    }

    public static Identity Identity(TypeElement resultType, Value input) {
        return new Identity(resultType, input);
    }

    @OpFactoryHelper.OpDeclaration(ImageDecoder.NAME)
    public static final class ImageDecoder extends OnnxOp {
        public static final String NAME = "ImageDecoder";

        public enum Attribute implements OnnxAttribute {
            pixel_format(String.class, true, "RGB"),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T1(new OnnxType.TypeVariable("T1", List.of(OnnxType.tensor(OnnxType.uint8())))),
            T2(new OnnxType.TypeVariable("T2", List.of(OnnxType.tensor(OnnxType.uint8())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            encoded_stream(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            image(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public ImageDecoder(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        ImageDecoder(ImageDecoder that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public ImageDecoder transform(CopyContext cc, OpTransformer ot) {
            return new ImageDecoder(this, cc);
        }

        ImageDecoder(TypeElement resultType, Value encoded_stream, java.util.Optional<String> pixel_format) {
            super(SCHEMA, resultType, Set.of(), List.of(encoded_stream), List.of(pixel_format));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(encoded_stream()));
        }

        public Value encoded_stream() {
            return operands().get(0);
        }

        public java.util.Optional<String> pixel_format() {
            String pixel_format = Attribute.pixel_format.access(String.class, onnxAttributes);
            return java.util.Optional.ofNullable(pixel_format);
        }

    }

    public static ImageDecoder ImageDecoder(TypeElement resultType, Value encoded_stream, java.util.Optional<String> pixel_format) {
        return new ImageDecoder(resultType, encoded_stream, pixel_format);
    }

    @OpFactoryHelper.OpDeclaration(Imputer.NAME)
    public static final class Imputer extends OnnxOp {
        public static final String NAME = "Imputer";

        public enum Attribute implements OnnxAttribute {
            replaced_value_int64(Long.class, true, 0),
            replaced_value_float(Float.class, true, 0.0f),
            imputed_value_int64s(long[].class, true, null),
            imputed_value_floats(float[].class, true, null),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.int32())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public Imputer(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        Imputer(Imputer that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public Imputer transform(CopyContext cc, OpTransformer ot) {
            return new Imputer(this, cc);
        }

        Imputer(TypeElement resultType, Value X, java.util.Optional<Long> replaced_value_int64, java.util.Optional<Float> replaced_value_float, java.util.Optional<long[]> imputed_value_int64s, java.util.Optional<float[]> imputed_value_floats) {
            super(SCHEMA, resultType, Set.of(), List.of(X), List.of(replaced_value_int64, replaced_value_float, imputed_value_int64s, imputed_value_floats));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X()));
        }

        public Value X() {
            return operands().get(0);
        }

        public java.util.Optional<Long> replaced_value_int64() {
            Long replaced_value_int64 = Attribute.replaced_value_int64.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(replaced_value_int64);
        }

        public java.util.Optional<Float> replaced_value_float() {
            Float replaced_value_float = Attribute.replaced_value_float.access(Float.class, onnxAttributes);
            return java.util.Optional.ofNullable(replaced_value_float);
        }

        public java.util.Optional<long[]> imputed_value_int64s() {
            long[] imputed_value_int64s = Attribute.imputed_value_int64s.access(long[].class, onnxAttributes);
            return java.util.Optional.ofNullable(imputed_value_int64s).map(long[]::clone);
        }

        public java.util.Optional<float[]> imputed_value_floats() {
            float[] imputed_value_floats = Attribute.imputed_value_floats.access(float[].class, onnxAttributes);
            return java.util.Optional.ofNullable(imputed_value_floats).map(float[]::clone);
        }

    }

    public static Imputer Imputer(TypeElement resultType, Value X, java.util.Optional<Long> replaced_value_int64, java.util.Optional<Float> replaced_value_float, java.util.Optional<long[]> imputed_value_int64s, java.util.Optional<float[]> imputed_value_floats) {
        return new Imputer(resultType, X, replaced_value_int64, replaced_value_float, imputed_value_int64s, imputed_value_floats);
    }

    @OpFactoryHelper.OpDeclaration(InstanceNormalization.NAME)
    public static final class InstanceNormalization extends OnnxOp {
        public static final String NAME = "InstanceNormalization";

        public enum Attribute implements OnnxAttribute {
            epsilon(Float.class, true, 1.0E-5f),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            input(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            scale(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            B(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public InstanceNormalization(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        InstanceNormalization(InstanceNormalization that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public InstanceNormalization transform(CopyContext cc, OpTransformer ot) {
            return new InstanceNormalization(this, cc);
        }

        InstanceNormalization(TypeElement resultType, Value input, Value scale, Value B, java.util.Optional<Float> epsilon) {
            super(SCHEMA, resultType, Set.of(), List.of(input, scale, B), List.of(epsilon));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(input(), scale(), B()));
        }

        public Value input() {
            return operands().get(0);
        }

        public Value scale() {
            return operands().get(1);
        }

        public Value B() {
            return operands().get(2);
        }

        public java.util.Optional<Float> epsilon() {
            Float epsilon = Attribute.epsilon.access(Float.class, onnxAttributes);
            return java.util.Optional.ofNullable(epsilon);
        }

    }

    public static InstanceNormalization InstanceNormalization(TypeElement resultType, Value input, Value scale, Value B, java.util.Optional<Float> epsilon) {
        return new InstanceNormalization(resultType, input, scale, B, epsilon);
    }

    @OpFactoryHelper.OpDeclaration(IsInf.NAME)
    public static final class IsInf extends OnnxOp {
        public static final String NAME = "IsInf";

        public enum Attribute implements OnnxAttribute {
            detect_negative(Long.class, true, 1),
            detect_positive(Long.class, true, 1),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T1(new OnnxType.TypeVariable("T1", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.float8e4m3fn()), OnnxType.tensor(OnnxType.float8e4m3fnuz()), OnnxType.tensor(OnnxType.float8e5m2()), OnnxType.tensor(OnnxType.float8e5m2fnuz())))),
            T2(new OnnxType.TypeVariable("T2", List.of(OnnxType.tensor(OnnxType.bool())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public IsInf(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        IsInf(IsInf that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public IsInf transform(CopyContext cc, OpTransformer ot) {
            return new IsInf(this, cc);
        }

        IsInf(TypeElement resultType, Value X, java.util.Optional<Long> detect_negative, java.util.Optional<Long> detect_positive) {
            super(SCHEMA, resultType, Set.of(), List.of(X), List.of(detect_negative, detect_positive));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X()));
        }

        public Value X() {
            return operands().get(0);
        }

        public java.util.Optional<Long> detect_negative() {
            Long detect_negative = Attribute.detect_negative.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(detect_negative);
        }

        public java.util.Optional<Long> detect_positive() {
            Long detect_positive = Attribute.detect_positive.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(detect_positive);
        }

    }

    public static IsInf IsInf(TypeElement resultType, Value X, java.util.Optional<Long> detect_negative, java.util.Optional<Long> detect_positive) {
        return new IsInf(resultType, X, detect_negative, detect_positive);
    }

    @OpFactoryHelper.OpDeclaration(IsNaN.NAME)
    public static final class IsNaN extends OnnxOp {
        public static final String NAME = "IsNaN";

        public enum Attribute implements OnnxAttribute.None { }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T1(new OnnxType.TypeVariable("T1", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.float8e4m3fn()), OnnxType.tensor(OnnxType.float8e4m3fnuz()), OnnxType.tensor(OnnxType.float8e5m2()), OnnxType.tensor(OnnxType.float8e5m2fnuz())))),
            T2(new OnnxType.TypeVariable("T2", List.of(OnnxType.tensor(OnnxType.bool())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public IsNaN(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        IsNaN(IsNaN that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public IsNaN transform(CopyContext cc, OpTransformer ot) {
            return new IsNaN(this, cc);
        }

        IsNaN(TypeElement resultType, Value X) {
            super(SCHEMA, resultType, Set.of(), List.of(X), List.of());
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X()));
        }

        public Value X() {
            return operands().get(0);
        }

    }

    public static IsNaN IsNaN(TypeElement resultType, Value X) {
        return new IsNaN(resultType, X);
    }

    @OpFactoryHelper.OpDeclaration(LRN.NAME)
    public static final class LRN extends OnnxOp {
        public static final String NAME = "LRN";

        public enum Attribute implements OnnxAttribute {
            size(Long.class, false, null),
            alpha(Float.class, true, 1.0E-4f),
            bias(Float.class, true, 1.0f),
            beta(Float.class, true, 0.75f),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public LRN(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        LRN(LRN that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public LRN transform(CopyContext cc, OpTransformer ot) {
            return new LRN(this, cc);
        }

        LRN(TypeElement resultType, Value X, long size, java.util.Optional<Float> alpha, java.util.Optional<Float> bias, java.util.Optional<Float> beta) {
            super(SCHEMA, resultType, Set.of(), List.of(X), List.of(size, alpha, bias, beta));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X()));
        }

        public Value X() {
            return operands().get(0);
        }

        public long size() {
            long size = Attribute.size.access(Long.class, onnxAttributes);
            return size;
        }

        public java.util.Optional<Float> alpha() {
            Float alpha = Attribute.alpha.access(Float.class, onnxAttributes);
            return java.util.Optional.ofNullable(alpha);
        }

        public java.util.Optional<Float> bias() {
            Float bias = Attribute.bias.access(Float.class, onnxAttributes);
            return java.util.Optional.ofNullable(bias);
        }

        public java.util.Optional<Float> beta() {
            Float beta = Attribute.beta.access(Float.class, onnxAttributes);
            return java.util.Optional.ofNullable(beta);
        }

    }

    public static LRN LRN(TypeElement resultType, Value X, long size, java.util.Optional<Float> alpha, java.util.Optional<Float> bias, java.util.Optional<Float> beta) {
        return new LRN(resultType, X, size, alpha, bias, beta);
    }

    @OpFactoryHelper.OpDeclaration(LSTM.NAME)
    public static final class LSTM extends OnnxOp {
        public static final String NAME = "LSTM";

        public enum Attribute implements OnnxAttribute {
            layout(Long.class, true, 0),
            input_forget(Long.class, true, 0),
            activation_alpha(float[].class, true, null),
            hidden_size(Long.class, true, null),
            activation_beta(float[].class, true, null),
            activations(String[].class, true, null),
            clip(Float.class, true, null),
            direction(String.class, true, "forward"),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),
            T1(new OnnxType.TypeVariable("T1", List.of(OnnxType.tensor(OnnxType.int32())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            W(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            R(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            B(TypeConstraint.T.typeVariable(), Quantifier.OPTIONAL),
            sequence_lens(TypeConstraint.T1.typeVariable(), Quantifier.OPTIONAL),
            initial_h(TypeConstraint.T.typeVariable(), Quantifier.OPTIONAL),
            initial_c(TypeConstraint.T.typeVariable(), Quantifier.OPTIONAL),
            P(TypeConstraint.T.typeVariable(), Quantifier.OPTIONAL),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T.typeVariable(), Quantifier.OPTIONAL),
            Y_h(TypeConstraint.T.typeVariable(), Quantifier.OPTIONAL),
            Y_c(TypeConstraint.T.typeVariable(), Quantifier.OPTIONAL),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public LSTM(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        LSTM(LSTM that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public LSTM transform(CopyContext cc, OpTransformer ot) {
            return new LSTM(this, cc);
        }

        LSTM(TypeElement resultType, Set<OutputParameter> optionalOutputs, Value X, Value W, Value R, java.util.Optional<Value> B, java.util.Optional<Value> sequence_lens, java.util.Optional<Value> initial_h, java.util.Optional<Value> initial_c, java.util.Optional<Value> P, java.util.Optional<Long> layout, java.util.Optional<Long> input_forget, java.util.Optional<float[]> activation_alpha, java.util.Optional<Long> hidden_size, java.util.Optional<float[]> activation_beta, java.util.Optional<String[]> activations, java.util.Optional<Float> clip, java.util.Optional<String> direction) {
            super(SCHEMA, resultType, optionalOutputs, List.of(X, W, R, B, sequence_lens, initial_h, initial_c, P), List.of(layout, input_forget, activation_alpha, hidden_size, activation_beta, activations, clip, direction));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X(), W(), R(), B(), sequence_lens(), initial_h(), initial_c(), P()));
        }

        public Value X() {
            return operands().get(0);
        }

        public Value W() {
            return operands().get(1);
        }

        public Value R() {
            return operands().get(2);
        }

        public java.util.Optional<Value> B() {
            int i = optionalInputArguments.indexOf(InputParameter.B);
            return i != -1 ? java.util.Optional.of(operands().get(3 + i)) : java.util.Optional.empty();
        }

        public java.util.Optional<Value> sequence_lens() {
            int i = optionalInputArguments.indexOf(InputParameter.sequence_lens);
            return i != -1 ? java.util.Optional.of(operands().get(3 + i)) : java.util.Optional.empty();
        }

        public java.util.Optional<Value> initial_h() {
            int i = optionalInputArguments.indexOf(InputParameter.initial_h);
            return i != -1 ? java.util.Optional.of(operands().get(3 + i)) : java.util.Optional.empty();
        }

        public java.util.Optional<Value> initial_c() {
            int i = optionalInputArguments.indexOf(InputParameter.initial_c);
            return i != -1 ? java.util.Optional.of(operands().get(3 + i)) : java.util.Optional.empty();
        }

        public java.util.Optional<Value> P() {
            int i = optionalInputArguments.indexOf(InputParameter.P);
            return i != -1 ? java.util.Optional.of(operands().get(3 + i)) : java.util.Optional.empty();
        }

        public java.util.Optional<Long> layout() {
            Long layout = Attribute.layout.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(layout);
        }

        public java.util.Optional<Long> input_forget() {
            Long input_forget = Attribute.input_forget.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(input_forget);
        }

        public java.util.Optional<float[]> activation_alpha() {
            float[] activation_alpha = Attribute.activation_alpha.access(float[].class, onnxAttributes);
            return java.util.Optional.ofNullable(activation_alpha).map(float[]::clone);
        }

        public java.util.Optional<Long> hidden_size() {
            Long hidden_size = Attribute.hidden_size.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(hidden_size);
        }

        public java.util.Optional<float[]> activation_beta() {
            float[] activation_beta = Attribute.activation_beta.access(float[].class, onnxAttributes);
            return java.util.Optional.ofNullable(activation_beta).map(float[]::clone);
        }

        public java.util.Optional<String[]> activations() {
            String[] activations = Attribute.activations.access(String[].class, onnxAttributes);
            return java.util.Optional.ofNullable(activations).map(String[]::clone);
        }

        public java.util.Optional<Float> clip() {
            Float clip = Attribute.clip.access(Float.class, onnxAttributes);
            return java.util.Optional.ofNullable(clip);
        }

        public java.util.Optional<String> direction() {
            String direction = Attribute.direction.access(String.class, onnxAttributes);
            return java.util.Optional.ofNullable(direction);
        }

    }

    public static LSTM LSTM(TypeElement resultType, Set<LSTM.OutputParameter> optionalOutputs, Value X, Value W, Value R, java.util.Optional<Value> B, java.util.Optional<Value> sequence_lens, java.util.Optional<Value> initial_h, java.util.Optional<Value> initial_c, java.util.Optional<Value> P, java.util.Optional<Long> layout, java.util.Optional<Long> input_forget, java.util.Optional<float[]> activation_alpha, java.util.Optional<Long> hidden_size, java.util.Optional<float[]> activation_beta, java.util.Optional<String[]> activations, java.util.Optional<Float> clip, java.util.Optional<String> direction) {
        return new LSTM(resultType, optionalOutputs, X, W, R, B, sequence_lens, initial_h, initial_c, P, layout, input_forget, activation_alpha, hidden_size, activation_beta, activations, clip, direction);
    }

    @OpFactoryHelper.OpDeclaration(LabelEncoder.NAME)
    public static final class LabelEncoder extends OnnxOp {
        public static final String NAME = "LabelEncoder";

        public enum Attribute implements OnnxAttribute {
            values_strings(String[].class, true, null),
            keys_int64s(long[].class, true, null),
            keys_tensor(Tensor.class, true, null),
            keys_strings(String[].class, true, null),
            default_float(Float.class, true, -0.0f),
            keys_floats(float[].class, true, null),
            default_tensor(Tensor.class, true, null),
            default_int64(Long.class, true, -1),
            values_tensor(Tensor.class, true, null),
            values_int64s(long[].class, true, null),
            default_string(String.class, true, "_Unused"),
            values_floats(float[].class, true, null),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T1(new OnnxType.TypeVariable("T1", List.of(OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.float64())))),
            T2(new OnnxType.TypeVariable("T2", List.of(OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.float64())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public LabelEncoder(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        LabelEncoder(LabelEncoder that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public LabelEncoder transform(CopyContext cc, OpTransformer ot) {
            return new LabelEncoder(this, cc);
        }

        LabelEncoder(TypeElement resultType, Value X, java.util.Optional<String[]> values_strings, java.util.Optional<long[]> keys_int64s, java.util.Optional<Tensor> keys_tensor, java.util.Optional<String[]> keys_strings, java.util.Optional<Float> default_float, java.util.Optional<float[]> keys_floats, java.util.Optional<Tensor> default_tensor, java.util.Optional<Long> default_int64, java.util.Optional<Tensor> values_tensor, java.util.Optional<long[]> values_int64s, java.util.Optional<String> default_string, java.util.Optional<float[]> values_floats) {
            super(SCHEMA, resultType, Set.of(), List.of(X), List.of(values_strings, keys_int64s, keys_tensor, keys_strings, default_float, keys_floats, default_tensor, default_int64, values_tensor, values_int64s, default_string, values_floats));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X()));
        }

        public Value X() {
            return operands().get(0);
        }

        public java.util.Optional<String[]> values_strings() {
            String[] values_strings = Attribute.values_strings.access(String[].class, onnxAttributes);
            return java.util.Optional.ofNullable(values_strings).map(String[]::clone);
        }

        public java.util.Optional<long[]> keys_int64s() {
            long[] keys_int64s = Attribute.keys_int64s.access(long[].class, onnxAttributes);
            return java.util.Optional.ofNullable(keys_int64s).map(long[]::clone);
        }

        public java.util.Optional<Tensor> keys_tensor() {
            Tensor keys_tensor = Attribute.keys_tensor.access(Tensor.class, onnxAttributes);
            return java.util.Optional.ofNullable(keys_tensor);
        }

        public java.util.Optional<String[]> keys_strings() {
            String[] keys_strings = Attribute.keys_strings.access(String[].class, onnxAttributes);
            return java.util.Optional.ofNullable(keys_strings).map(String[]::clone);
        }

        public java.util.Optional<Float> default_float() {
            Float default_float = Attribute.default_float.access(Float.class, onnxAttributes);
            return java.util.Optional.ofNullable(default_float);
        }

        public java.util.Optional<float[]> keys_floats() {
            float[] keys_floats = Attribute.keys_floats.access(float[].class, onnxAttributes);
            return java.util.Optional.ofNullable(keys_floats).map(float[]::clone);
        }

        public java.util.Optional<Tensor> default_tensor() {
            Tensor default_tensor = Attribute.default_tensor.access(Tensor.class, onnxAttributes);
            return java.util.Optional.ofNullable(default_tensor);
        }

        public java.util.Optional<Long> default_int64() {
            Long default_int64 = Attribute.default_int64.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(default_int64);
        }

        public java.util.Optional<Tensor> values_tensor() {
            Tensor values_tensor = Attribute.values_tensor.access(Tensor.class, onnxAttributes);
            return java.util.Optional.ofNullable(values_tensor);
        }

        public java.util.Optional<long[]> values_int64s() {
            long[] values_int64s = Attribute.values_int64s.access(long[].class, onnxAttributes);
            return java.util.Optional.ofNullable(values_int64s).map(long[]::clone);
        }

        public java.util.Optional<String> default_string() {
            String default_string = Attribute.default_string.access(String.class, onnxAttributes);
            return java.util.Optional.ofNullable(default_string);
        }

        public java.util.Optional<float[]> values_floats() {
            float[] values_floats = Attribute.values_floats.access(float[].class, onnxAttributes);
            return java.util.Optional.ofNullable(values_floats).map(float[]::clone);
        }

    }

    public static LabelEncoder LabelEncoder(TypeElement resultType, Value X, java.util.Optional<String[]> values_strings, java.util.Optional<long[]> keys_int64s, java.util.Optional<Tensor> keys_tensor, java.util.Optional<String[]> keys_strings, java.util.Optional<Float> default_float, java.util.Optional<float[]> keys_floats, java.util.Optional<Tensor> default_tensor, java.util.Optional<Long> default_int64, java.util.Optional<Tensor> values_tensor, java.util.Optional<long[]> values_int64s, java.util.Optional<String> default_string, java.util.Optional<float[]> values_floats) {
        return new LabelEncoder(resultType, X, values_strings, keys_int64s, keys_tensor, keys_strings, default_float, keys_floats, default_tensor, default_int64, values_tensor, values_int64s, default_string, values_floats);
    }

    @OpFactoryHelper.OpDeclaration(LayerNormalization.NAME)
    public static final class LayerNormalization extends OnnxOp {
        public static final String NAME = "LayerNormalization";

        public enum Attribute implements OnnxAttribute {
            epsilon(Float.class, true, 1.0E-5f),
            stash_type(Long.class, true, 1),
            axis(Long.class, true, -1),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),
            U(new OnnxType.TypeVariable("U", List.of(OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.bfloat16())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            Scale(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            B(TypeConstraint.T.typeVariable(), Quantifier.OPTIONAL),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            Mean(TypeConstraint.U.typeVariable(), Quantifier.OPTIONAL),
            InvStdDev(TypeConstraint.U.typeVariable(), Quantifier.OPTIONAL),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public LayerNormalization(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        LayerNormalization(LayerNormalization that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public LayerNormalization transform(CopyContext cc, OpTransformer ot) {
            return new LayerNormalization(this, cc);
        }

        LayerNormalization(TypeElement resultType, Set<OutputParameter> optionalOutputs, Value X, Value Scale, java.util.Optional<Value> B, java.util.Optional<Float> epsilon, java.util.Optional<Long> stash_type, java.util.Optional<Long> axis) {
            super(SCHEMA, resultType, optionalOutputs, List.of(X, Scale, B), List.of(epsilon, stash_type, axis));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X(), Scale(), B()));
        }

        public Value X() {
            return operands().get(0);
        }

        public Value Scale() {
            return operands().get(1);
        }

        public java.util.Optional<Value> B() {
            int i = optionalInputArguments.indexOf(InputParameter.B);
            return i != -1 ? java.util.Optional.of(operands().get(2 + i)) : java.util.Optional.empty();
        }

        public java.util.Optional<Float> epsilon() {
            Float epsilon = Attribute.epsilon.access(Float.class, onnxAttributes);
            return java.util.Optional.ofNullable(epsilon);
        }

        public java.util.Optional<Long> stash_type() {
            Long stash_type = Attribute.stash_type.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(stash_type);
        }

        public java.util.Optional<Long> axis() {
            Long axis = Attribute.axis.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(axis);
        }

    }

    public static LayerNormalization LayerNormalization(TypeElement resultType, Set<LayerNormalization.OutputParameter> optionalOutputs, Value X, Value Scale, java.util.Optional<Value> B, java.util.Optional<Float> epsilon, java.util.Optional<Long> stash_type, java.util.Optional<Long> axis) {
        return new LayerNormalization(resultType, optionalOutputs, X, Scale, B, epsilon, stash_type, axis);
    }

    @OpFactoryHelper.OpDeclaration(LeakyRelu.NAME)
    public static final class LeakyRelu extends OnnxOp {
        public static final String NAME = "LeakyRelu";

        public enum Attribute implements OnnxAttribute {
            alpha(Float.class, true, 0.01f),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public LeakyRelu(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        LeakyRelu(LeakyRelu that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public LeakyRelu transform(CopyContext cc, OpTransformer ot) {
            return new LeakyRelu(this, cc);
        }

        LeakyRelu(TypeElement resultType, Value X, java.util.Optional<Float> alpha) {
            super(SCHEMA, resultType, Set.of(), List.of(X), List.of(alpha));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X()));
        }

        public Value X() {
            return operands().get(0);
        }

        public java.util.Optional<Float> alpha() {
            Float alpha = Attribute.alpha.access(Float.class, onnxAttributes);
            return java.util.Optional.ofNullable(alpha);
        }

    }

    public static LeakyRelu LeakyRelu(TypeElement resultType, Value X, java.util.Optional<Float> alpha) {
        return new LeakyRelu(resultType, X, alpha);
    }

    @OpFactoryHelper.OpDeclaration(Less.NAME)
    public static final class Less extends OnnxOp {
        public static final String NAME = "Less";

        public enum Attribute implements OnnxAttribute.None { }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),
            T1(new OnnxType.TypeVariable("T1", List.of(OnnxType.tensor(OnnxType.bool())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            A(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            B(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            C(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public Less(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        Less(Less that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public Less transform(CopyContext cc, OpTransformer ot) {
            return new Less(this, cc);
        }

        Less(TypeElement resultType, Value A, Value B) {
            super(SCHEMA, resultType, Set.of(), List.of(A, B), List.of());
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(A(), B()));
        }

        public Value A() {
            return operands().get(0);
        }

        public Value B() {
            return operands().get(1);
        }

    }

    public static Less Less(TypeElement resultType, Value A, Value B) {
        return new Less(resultType, A, B);
    }

    @OpFactoryHelper.OpDeclaration(LessOrEqual.NAME)
    public static final class LessOrEqual extends OnnxOp {
        public static final String NAME = "LessOrEqual";

        public enum Attribute implements OnnxAttribute.None { }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),
            T1(new OnnxType.TypeVariable("T1", List.of(OnnxType.tensor(OnnxType.bool())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            A(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            B(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            C(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public LessOrEqual(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        LessOrEqual(LessOrEqual that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public LessOrEqual transform(CopyContext cc, OpTransformer ot) {
            return new LessOrEqual(this, cc);
        }

        LessOrEqual(TypeElement resultType, Value A, Value B) {
            super(SCHEMA, resultType, Set.of(), List.of(A, B), List.of());
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(A(), B()));
        }

        public Value A() {
            return operands().get(0);
        }

        public Value B() {
            return operands().get(1);
        }

    }

    public static LessOrEqual LessOrEqual(TypeElement resultType, Value A, Value B) {
        return new LessOrEqual(resultType, A, B);
    }

    @OpFactoryHelper.OpDeclaration(LinearClassifier.NAME)
    public static final class LinearClassifier extends OnnxOp {
        public static final String NAME = "LinearClassifier";

        public enum Attribute implements OnnxAttribute {
            classlabels_ints(long[].class, true, null),
            post_transform(String.class, true, "NONE"),
            coefficients(float[].class, false, null),
            multi_class(Long.class, true, 0),
            intercepts(float[].class, true, null),
            classlabels_strings(String[].class, true, null),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T1(new OnnxType.TypeVariable("T1", List.of(OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.int32())))),
            T2(new OnnxType.TypeVariable("T2", List.of(OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.int64())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),
            Z(OnnxType.tensor(OnnxType.float32()), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public LinearClassifier(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        LinearClassifier(LinearClassifier that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public LinearClassifier transform(CopyContext cc, OpTransformer ot) {
            return new LinearClassifier(this, cc);
        }

        LinearClassifier(TypeElement resultType, Value X, java.util.Optional<long[]> classlabels_ints, java.util.Optional<String> post_transform, float[] coefficients, java.util.Optional<Long> multi_class, java.util.Optional<float[]> intercepts, java.util.Optional<String[]> classlabels_strings) {
            super(SCHEMA, resultType, Set.of(), List.of(X), List.of(classlabels_ints, post_transform, coefficients, multi_class, intercepts, classlabels_strings));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X()));
        }

        public Value X() {
            return operands().get(0);
        }

        public java.util.Optional<long[]> classlabels_ints() {
            long[] classlabels_ints = Attribute.classlabels_ints.access(long[].class, onnxAttributes);
            return java.util.Optional.ofNullable(classlabels_ints).map(long[]::clone);
        }

        public java.util.Optional<String> post_transform() {
            String post_transform = Attribute.post_transform.access(String.class, onnxAttributes);
            return java.util.Optional.ofNullable(post_transform);
        }

        public float[] coefficients() {
            float[] coefficients = Attribute.coefficients.access(float[].class, onnxAttributes);
            return coefficients.clone();
        }

        public java.util.Optional<Long> multi_class() {
            Long multi_class = Attribute.multi_class.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(multi_class);
        }

        public java.util.Optional<float[]> intercepts() {
            float[] intercepts = Attribute.intercepts.access(float[].class, onnxAttributes);
            return java.util.Optional.ofNullable(intercepts).map(float[]::clone);
        }

        public java.util.Optional<String[]> classlabels_strings() {
            String[] classlabels_strings = Attribute.classlabels_strings.access(String[].class, onnxAttributes);
            return java.util.Optional.ofNullable(classlabels_strings).map(String[]::clone);
        }

    }

    public static LinearClassifier LinearClassifier(TypeElement resultType, Value X, java.util.Optional<long[]> classlabels_ints, java.util.Optional<String> post_transform, float[] coefficients, java.util.Optional<Long> multi_class, java.util.Optional<float[]> intercepts, java.util.Optional<String[]> classlabels_strings) {
        return new LinearClassifier(resultType, X, classlabels_ints, post_transform, coefficients, multi_class, intercepts, classlabels_strings);
    }

    @OpFactoryHelper.OpDeclaration(LinearRegressor.NAME)
    public static final class LinearRegressor extends OnnxOp {
        public static final String NAME = "LinearRegressor";

        public enum Attribute implements OnnxAttribute {
            post_transform(String.class, true, "NONE"),
            coefficients(float[].class, true, null),
            targets(Long.class, true, 1),
            intercepts(float[].class, true, null),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.int32())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            Y(OnnxType.tensor(OnnxType.float32()), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public LinearRegressor(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        LinearRegressor(LinearRegressor that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public LinearRegressor transform(CopyContext cc, OpTransformer ot) {
            return new LinearRegressor(this, cc);
        }

        LinearRegressor(TypeElement resultType, Value X, java.util.Optional<String> post_transform, java.util.Optional<float[]> coefficients, java.util.Optional<Long> targets, java.util.Optional<float[]> intercepts) {
            super(SCHEMA, resultType, Set.of(), List.of(X), List.of(post_transform, coefficients, targets, intercepts));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X()));
        }

        public Value X() {
            return operands().get(0);
        }

        public java.util.Optional<String> post_transform() {
            String post_transform = Attribute.post_transform.access(String.class, onnxAttributes);
            return java.util.Optional.ofNullable(post_transform);
        }

        public java.util.Optional<float[]> coefficients() {
            float[] coefficients = Attribute.coefficients.access(float[].class, onnxAttributes);
            return java.util.Optional.ofNullable(coefficients).map(float[]::clone);
        }

        public java.util.Optional<Long> targets() {
            Long targets = Attribute.targets.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(targets);
        }

        public java.util.Optional<float[]> intercepts() {
            float[] intercepts = Attribute.intercepts.access(float[].class, onnxAttributes);
            return java.util.Optional.ofNullable(intercepts).map(float[]::clone);
        }

    }

    public static LinearRegressor LinearRegressor(TypeElement resultType, Value X, java.util.Optional<String> post_transform, java.util.Optional<float[]> coefficients, java.util.Optional<Long> targets, java.util.Optional<float[]> intercepts) {
        return new LinearRegressor(resultType, X, post_transform, coefficients, targets, intercepts);
    }

    @OpFactoryHelper.OpDeclaration(Log.NAME)
    public static final class Log extends OnnxOp {
        public static final String NAME = "Log";

        public enum Attribute implements OnnxAttribute.None { }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            input(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public Log(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        Log(Log that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public Log transform(CopyContext cc, OpTransformer ot) {
            return new Log(this, cc);
        }

        Log(TypeElement resultType, Value input) {
            super(SCHEMA, resultType, Set.of(), List.of(input), List.of());
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(input()));
        }

        public Value input() {
            return operands().get(0);
        }

    }

    public static Log Log(TypeElement resultType, Value input) {
        return new Log(resultType, input);
    }

    @OpFactoryHelper.OpDeclaration(LogSoftmax.NAME)
    public static final class LogSoftmax extends OnnxOp {
        public static final String NAME = "LogSoftmax";

        public enum Attribute implements OnnxAttribute {
            axis(Long.class, true, -1),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            input(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public LogSoftmax(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        LogSoftmax(LogSoftmax that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public LogSoftmax transform(CopyContext cc, OpTransformer ot) {
            return new LogSoftmax(this, cc);
        }

        LogSoftmax(TypeElement resultType, Value input, java.util.Optional<Long> axis) {
            super(SCHEMA, resultType, Set.of(), List.of(input), List.of(axis));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(input()));
        }

        public Value input() {
            return operands().get(0);
        }

        public java.util.Optional<Long> axis() {
            Long axis = Attribute.axis.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(axis);
        }

    }

    public static LogSoftmax LogSoftmax(TypeElement resultType, Value input, java.util.Optional<Long> axis) {
        return new LogSoftmax(resultType, input, axis);
    }

    @OpFactoryHelper.OpDeclaration(LpNormalization.NAME)
    public static final class LpNormalization extends OnnxOp {
        public static final String NAME = "LpNormalization";

        public enum Attribute implements OnnxAttribute {
            p(Long.class, true, 2),
            axis(Long.class, true, -1),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            input(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public LpNormalization(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        LpNormalization(LpNormalization that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public LpNormalization transform(CopyContext cc, OpTransformer ot) {
            return new LpNormalization(this, cc);
        }

        LpNormalization(TypeElement resultType, Value input, java.util.Optional<Long> p, java.util.Optional<Long> axis) {
            super(SCHEMA, resultType, Set.of(), List.of(input), List.of(p, axis));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(input()));
        }

        public Value input() {
            return operands().get(0);
        }

        public java.util.Optional<Long> p() {
            Long p = Attribute.p.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(p);
        }

        public java.util.Optional<Long> axis() {
            Long axis = Attribute.axis.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(axis);
        }

    }

    public static LpNormalization LpNormalization(TypeElement resultType, Value input, java.util.Optional<Long> p, java.util.Optional<Long> axis) {
        return new LpNormalization(resultType, input, p, axis);
    }

    @OpFactoryHelper.OpDeclaration(LpPool.NAME)
    public static final class LpPool extends OnnxOp {
        public static final String NAME = "LpPool";

        public enum Attribute implements OnnxAttribute {
            p(Long.class, true, 2),
            pads(long[].class, true, null),
            dilations(long[].class, true, null),
            auto_pad(String.class, true, "NOTSET"),
            ceil_mode(Long.class, true, 0),
            strides(long[].class, true, null),
            kernel_shape(long[].class, false, null),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public LpPool(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        LpPool(LpPool that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public LpPool transform(CopyContext cc, OpTransformer ot) {
            return new LpPool(this, cc);
        }

        LpPool(TypeElement resultType, Value X, java.util.Optional<Long> p, java.util.Optional<long[]> pads, java.util.Optional<long[]> dilations, java.util.Optional<String> auto_pad, java.util.Optional<Long> ceil_mode, java.util.Optional<long[]> strides, long[] kernel_shape) {
            super(SCHEMA, resultType, Set.of(), List.of(X), List.of(p, pads, dilations, auto_pad, ceil_mode, strides, kernel_shape));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X()));
        }

        public Value X() {
            return operands().get(0);
        }

        public java.util.Optional<Long> p() {
            Long p = Attribute.p.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(p);
        }

        public java.util.Optional<long[]> pads() {
            long[] pads = Attribute.pads.access(long[].class, onnxAttributes);
            return java.util.Optional.ofNullable(pads).map(long[]::clone);
        }

        public java.util.Optional<long[]> dilations() {
            long[] dilations = Attribute.dilations.access(long[].class, onnxAttributes);
            return java.util.Optional.ofNullable(dilations).map(long[]::clone);
        }

        public java.util.Optional<String> auto_pad() {
            String auto_pad = Attribute.auto_pad.access(String.class, onnxAttributes);
            return java.util.Optional.ofNullable(auto_pad);
        }

        public java.util.Optional<Long> ceil_mode() {
            Long ceil_mode = Attribute.ceil_mode.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(ceil_mode);
        }

        public java.util.Optional<long[]> strides() {
            long[] strides = Attribute.strides.access(long[].class, onnxAttributes);
            return java.util.Optional.ofNullable(strides).map(long[]::clone);
        }

        public long[] kernel_shape() {
            long[] kernel_shape = Attribute.kernel_shape.access(long[].class, onnxAttributes);
            return kernel_shape.clone();
        }

    }

    public static LpPool LpPool(TypeElement resultType, Value X, java.util.Optional<Long> p, java.util.Optional<long[]> pads, java.util.Optional<long[]> dilations, java.util.Optional<String> auto_pad, java.util.Optional<Long> ceil_mode, java.util.Optional<long[]> strides, long[] kernel_shape) {
        return new LpPool(resultType, X, p, pads, dilations, auto_pad, ceil_mode, strides, kernel_shape);
    }

    @OpFactoryHelper.OpDeclaration(MatMul.NAME)
    public static final class MatMul extends OnnxOp {
        public static final String NAME = "MatMul";

        public enum Attribute implements OnnxAttribute.None { }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            A(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            B(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public MatMul(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        MatMul(MatMul that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public MatMul transform(CopyContext cc, OpTransformer ot) {
            return new MatMul(this, cc);
        }

        MatMul(TypeElement resultType, Value A, Value B) {
            super(SCHEMA, resultType, Set.of(), List.of(A, B), List.of());
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(A(), B()));
        }

        public Value A() {
            return operands().get(0);
        }

        public Value B() {
            return operands().get(1);
        }

    }

    public static MatMul MatMul(TypeElement resultType, Value A, Value B) {
        return new MatMul(resultType, A, B);
    }

    @OpFactoryHelper.OpDeclaration(MatMulInteger.NAME)
    public static final class MatMulInteger extends OnnxOp {
        public static final String NAME = "MatMulInteger";

        public enum Attribute implements OnnxAttribute.None { }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T1(new OnnxType.TypeVariable("T1", List.of(OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.uint8())))),
            T2(new OnnxType.TypeVariable("T2", List.of(OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.uint8())))),
            T3(new OnnxType.TypeVariable("T3", List.of(OnnxType.tensor(OnnxType.int32())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            A(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            B(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),
            a_zero_point(TypeConstraint.T1.typeVariable(), Quantifier.OPTIONAL),
            b_zero_point(TypeConstraint.T2.typeVariable(), Quantifier.OPTIONAL),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T3.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public MatMulInteger(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        MatMulInteger(MatMulInteger that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public MatMulInteger transform(CopyContext cc, OpTransformer ot) {
            return new MatMulInteger(this, cc);
        }

        MatMulInteger(TypeElement resultType, Value A, Value B, java.util.Optional<Value> a_zero_point, java.util.Optional<Value> b_zero_point) {
            super(SCHEMA, resultType, Set.of(), List.of(A, B, a_zero_point, b_zero_point), List.of());
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(A(), B(), a_zero_point(), b_zero_point()));
        }

        public Value A() {
            return operands().get(0);
        }

        public Value B() {
            return operands().get(1);
        }

        public java.util.Optional<Value> a_zero_point() {
            int i = optionalInputArguments.indexOf(InputParameter.a_zero_point);
            return i != -1 ? java.util.Optional.of(operands().get(2 + i)) : java.util.Optional.empty();
        }

        public java.util.Optional<Value> b_zero_point() {
            int i = optionalInputArguments.indexOf(InputParameter.b_zero_point);
            return i != -1 ? java.util.Optional.of(operands().get(2 + i)) : java.util.Optional.empty();
        }

    }

    public static MatMulInteger MatMulInteger(TypeElement resultType, Value A, Value B, java.util.Optional<Value> a_zero_point, java.util.Optional<Value> b_zero_point) {
        return new MatMulInteger(resultType, A, B, a_zero_point, b_zero_point);
    }

    @OpFactoryHelper.OpDeclaration(Max.NAME)
    public static final class Max extends OnnxOp {
        public static final String NAME = "Max";

        public enum Attribute implements OnnxAttribute.None { }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            data_0(TypeConstraint.T.typeVariable(), Quantifier.VARIADIC),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            max(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public Max(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        Max(Max that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public Max transform(CopyContext cc, OpTransformer ot) {
            return new Max(this, cc);
        }

        Max(TypeElement resultType, List<Value> data_0) {
            super(SCHEMA, resultType, Set.of(), List.of(data_0), List.of());
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(data_0()));
        }

        public List<Value> data_0() {
            return operands();
        }

    }

    public static Max Max(TypeElement resultType, List<Value> data_0) {
        return new Max(resultType, data_0);
    }

    @OpFactoryHelper.OpDeclaration(MaxPool.NAME)
    public static final class MaxPool extends OnnxOp {
        public static final String NAME = "MaxPool";

        public enum Attribute implements OnnxAttribute {
            pads(long[].class, true, null),
            dilations(long[].class, true, null),
            auto_pad(String.class, true, "NOTSET"),
            ceil_mode(Long.class, true, 0),
            storage_order(Long.class, true, 0),
            strides(long[].class, true, null),
            kernel_shape(long[].class, false, null),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.uint8())))),
            I(new OnnxType.TypeVariable("I", List.of(OnnxType.tensor(OnnxType.int64())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            Indices(TypeConstraint.I.typeVariable(), Quantifier.OPTIONAL),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public MaxPool(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        MaxPool(MaxPool that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public MaxPool transform(CopyContext cc, OpTransformer ot) {
            return new MaxPool(this, cc);
        }

        MaxPool(TypeElement resultType, Set<OutputParameter> optionalOutputs, Value X, java.util.Optional<long[]> pads, java.util.Optional<long[]> dilations, java.util.Optional<String> auto_pad, java.util.Optional<Long> ceil_mode, java.util.Optional<Long> storage_order, java.util.Optional<long[]> strides, long[] kernel_shape) {
            super(SCHEMA, resultType, optionalOutputs, List.of(X), List.of(pads, dilations, auto_pad, ceil_mode, storage_order, strides, kernel_shape));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X()));
        }

        public Value X() {
            return operands().get(0);
        }

        public java.util.Optional<long[]> pads() {
            long[] pads = Attribute.pads.access(long[].class, onnxAttributes);
            return java.util.Optional.ofNullable(pads).map(long[]::clone);
        }

        public java.util.Optional<long[]> dilations() {
            long[] dilations = Attribute.dilations.access(long[].class, onnxAttributes);
            return java.util.Optional.ofNullable(dilations).map(long[]::clone);
        }

        public java.util.Optional<String> auto_pad() {
            String auto_pad = Attribute.auto_pad.access(String.class, onnxAttributes);
            return java.util.Optional.ofNullable(auto_pad);
        }

        public java.util.Optional<Long> ceil_mode() {
            Long ceil_mode = Attribute.ceil_mode.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(ceil_mode);
        }

        public java.util.Optional<Long> storage_order() {
            Long storage_order = Attribute.storage_order.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(storage_order);
        }

        public java.util.Optional<long[]> strides() {
            long[] strides = Attribute.strides.access(long[].class, onnxAttributes);
            return java.util.Optional.ofNullable(strides).map(long[]::clone);
        }

        public long[] kernel_shape() {
            long[] kernel_shape = Attribute.kernel_shape.access(long[].class, onnxAttributes);
            return kernel_shape.clone();
        }

    }

    public static MaxPool MaxPool(TypeElement resultType, Set<MaxPool.OutputParameter> optionalOutputs, Value X, java.util.Optional<long[]> pads, java.util.Optional<long[]> dilations, java.util.Optional<String> auto_pad, java.util.Optional<Long> ceil_mode, java.util.Optional<Long> storage_order, java.util.Optional<long[]> strides, long[] kernel_shape) {
        return new MaxPool(resultType, optionalOutputs, X, pads, dilations, auto_pad, ceil_mode, storage_order, strides, kernel_shape);
    }

    @OpFactoryHelper.OpDeclaration(MaxRoiPool.NAME)
    public static final class MaxRoiPool extends OnnxOp {
        public static final String NAME = "MaxRoiPool";

        public enum Attribute implements OnnxAttribute {
            spatial_scale(Float.class, true, 1.0f),
            pooled_shape(long[].class, false, null),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            rois(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public MaxRoiPool(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        MaxRoiPool(MaxRoiPool that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public MaxRoiPool transform(CopyContext cc, OpTransformer ot) {
            return new MaxRoiPool(this, cc);
        }

        MaxRoiPool(TypeElement resultType, Value X, Value rois, java.util.Optional<Float> spatial_scale, long[] pooled_shape) {
            super(SCHEMA, resultType, Set.of(), List.of(X, rois), List.of(spatial_scale, pooled_shape));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X(), rois()));
        }

        public Value X() {
            return operands().get(0);
        }

        public Value rois() {
            return operands().get(1);
        }

        public java.util.Optional<Float> spatial_scale() {
            Float spatial_scale = Attribute.spatial_scale.access(Float.class, onnxAttributes);
            return java.util.Optional.ofNullable(spatial_scale);
        }

        public long[] pooled_shape() {
            long[] pooled_shape = Attribute.pooled_shape.access(long[].class, onnxAttributes);
            return pooled_shape.clone();
        }

    }

    public static MaxRoiPool MaxRoiPool(TypeElement resultType, Value X, Value rois, java.util.Optional<Float> spatial_scale, long[] pooled_shape) {
        return new MaxRoiPool(resultType, X, rois, spatial_scale, pooled_shape);
    }

    @OpFactoryHelper.OpDeclaration(MaxUnpool.NAME)
    public static final class MaxUnpool extends OnnxOp {
        public static final String NAME = "MaxUnpool";

        public enum Attribute implements OnnxAttribute {
            pads(long[].class, true, null),
            strides(long[].class, true, null),
            kernel_shape(long[].class, false, null),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T1(new OnnxType.TypeVariable("T1", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),
            T2(new OnnxType.TypeVariable("T2", List.of(OnnxType.tensor(OnnxType.int64())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            I(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),
            output_shape(TypeConstraint.T2.typeVariable(), Quantifier.OPTIONAL),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public MaxUnpool(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        MaxUnpool(MaxUnpool that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public MaxUnpool transform(CopyContext cc, OpTransformer ot) {
            return new MaxUnpool(this, cc);
        }

        MaxUnpool(TypeElement resultType, Value X, Value I, java.util.Optional<Value> output_shape, java.util.Optional<long[]> pads, java.util.Optional<long[]> strides, long[] kernel_shape) {
            super(SCHEMA, resultType, Set.of(), List.of(X, I, output_shape), List.of(pads, strides, kernel_shape));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X(), I(), output_shape()));
        }

        public Value X() {
            return operands().get(0);
        }

        public Value I() {
            return operands().get(1);
        }

        public java.util.Optional<Value> output_shape() {
            int i = optionalInputArguments.indexOf(InputParameter.output_shape);
            return i != -1 ? java.util.Optional.of(operands().get(2 + i)) : java.util.Optional.empty();
        }

        public java.util.Optional<long[]> pads() {
            long[] pads = Attribute.pads.access(long[].class, onnxAttributes);
            return java.util.Optional.ofNullable(pads).map(long[]::clone);
        }

        public java.util.Optional<long[]> strides() {
            long[] strides = Attribute.strides.access(long[].class, onnxAttributes);
            return java.util.Optional.ofNullable(strides).map(long[]::clone);
        }

        public long[] kernel_shape() {
            long[] kernel_shape = Attribute.kernel_shape.access(long[].class, onnxAttributes);
            return kernel_shape.clone();
        }

    }

    public static MaxUnpool MaxUnpool(TypeElement resultType, Value X, Value I, java.util.Optional<Value> output_shape, java.util.Optional<long[]> pads, java.util.Optional<long[]> strides, long[] kernel_shape) {
        return new MaxUnpool(resultType, X, I, output_shape, pads, strides, kernel_shape);
    }

    @OpFactoryHelper.OpDeclaration(Mean.NAME)
    public static final class Mean extends OnnxOp {
        public static final String NAME = "Mean";

        public enum Attribute implements OnnxAttribute.None { }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            data_0(TypeConstraint.T.typeVariable(), Quantifier.VARIADIC),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            mean(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public Mean(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        Mean(Mean that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public Mean transform(CopyContext cc, OpTransformer ot) {
            return new Mean(this, cc);
        }

        Mean(TypeElement resultType, List<Value> data_0) {
            super(SCHEMA, resultType, Set.of(), List.of(data_0), List.of());
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(data_0()));
        }

        public List<Value> data_0() {
            return operands();
        }

    }

    public static Mean Mean(TypeElement resultType, List<Value> data_0) {
        return new Mean(resultType, data_0);
    }

    @OpFactoryHelper.OpDeclaration(MeanVarianceNormalization.NAME)
    public static final class MeanVarianceNormalization extends OnnxOp {
        public static final String NAME = "MeanVarianceNormalization";

        public enum Attribute implements OnnxAttribute {
            axes(long[].class, true, null),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public MeanVarianceNormalization(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        MeanVarianceNormalization(MeanVarianceNormalization that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public MeanVarianceNormalization transform(CopyContext cc, OpTransformer ot) {
            return new MeanVarianceNormalization(this, cc);
        }

        MeanVarianceNormalization(TypeElement resultType, Value X, java.util.Optional<long[]> axes) {
            super(SCHEMA, resultType, Set.of(), List.of(X), List.of(axes));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X()));
        }

        public Value X() {
            return operands().get(0);
        }

        public java.util.Optional<long[]> axes() {
            long[] axes = Attribute.axes.access(long[].class, onnxAttributes);
            return java.util.Optional.ofNullable(axes).map(long[]::clone);
        }

    }

    public static MeanVarianceNormalization MeanVarianceNormalization(TypeElement resultType, Value X, java.util.Optional<long[]> axes) {
        return new MeanVarianceNormalization(resultType, X, axes);
    }

    @OpFactoryHelper.OpDeclaration(MelWeightMatrix.NAME)
    public static final class MelWeightMatrix extends OnnxOp {
        public static final String NAME = "MelWeightMatrix";

        public enum Attribute implements OnnxAttribute {
            output_datatype(Long.class, true, 1),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T1(new OnnxType.TypeVariable("T1", List.of(OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64())))),
            T2(new OnnxType.TypeVariable("T2", List.of(OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),
            T3(new OnnxType.TypeVariable("T3", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            num_mel_bins(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            dft_length(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            sample_rate(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            lower_edge_hertz(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),
            upper_edge_hertz(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T3.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public MelWeightMatrix(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        MelWeightMatrix(MelWeightMatrix that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public MelWeightMatrix transform(CopyContext cc, OpTransformer ot) {
            return new MelWeightMatrix(this, cc);
        }

        MelWeightMatrix(TypeElement resultType, Value num_mel_bins, Value dft_length, Value sample_rate, Value lower_edge_hertz, Value upper_edge_hertz, java.util.Optional<Long> output_datatype) {
            super(SCHEMA, resultType, Set.of(), List.of(num_mel_bins, dft_length, sample_rate, lower_edge_hertz, upper_edge_hertz), List.of(output_datatype));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(num_mel_bins(), dft_length(), sample_rate(), lower_edge_hertz(), upper_edge_hertz()));
        }

        public Value num_mel_bins() {
            return operands().get(0);
        }

        public Value dft_length() {
            return operands().get(1);
        }

        public Value sample_rate() {
            return operands().get(2);
        }

        public Value lower_edge_hertz() {
            return operands().get(3);
        }

        public Value upper_edge_hertz() {
            return operands().get(4);
        }

        public java.util.Optional<Long> output_datatype() {
            Long output_datatype = Attribute.output_datatype.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(output_datatype);
        }

    }

    public static MelWeightMatrix MelWeightMatrix(TypeElement resultType, Value num_mel_bins, Value dft_length, Value sample_rate, Value lower_edge_hertz, Value upper_edge_hertz, java.util.Optional<Long> output_datatype) {
        return new MelWeightMatrix(resultType, num_mel_bins, dft_length, sample_rate, lower_edge_hertz, upper_edge_hertz, output_datatype);
    }

    @OpFactoryHelper.OpDeclaration(Min.NAME)
    public static final class Min extends OnnxOp {
        public static final String NAME = "Min";

        public enum Attribute implements OnnxAttribute.None { }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            data_0(TypeConstraint.T.typeVariable(), Quantifier.VARIADIC),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            min(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public Min(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        Min(Min that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public Min transform(CopyContext cc, OpTransformer ot) {
            return new Min(this, cc);
        }

        Min(TypeElement resultType, List<Value> data_0) {
            super(SCHEMA, resultType, Set.of(), List.of(data_0), List.of());
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(data_0()));
        }

        public List<Value> data_0() {
            return operands();
        }

    }

    public static Min Min(TypeElement resultType, List<Value> data_0) {
        return new Min(resultType, data_0);
    }

    @OpFactoryHelper.OpDeclaration(Mish.NAME)
    public static final class Mish extends OnnxOp {
        public static final String NAME = "Mish";

        public enum Attribute implements OnnxAttribute.None { }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public Mish(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        Mish(Mish that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public Mish transform(CopyContext cc, OpTransformer ot) {
            return new Mish(this, cc);
        }

        Mish(TypeElement resultType, Value X) {
            super(SCHEMA, resultType, Set.of(), List.of(X), List.of());
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X()));
        }

        public Value X() {
            return operands().get(0);
        }

    }

    public static Mish Mish(TypeElement resultType, Value X) {
        return new Mish(resultType, X);
    }

    @OpFactoryHelper.OpDeclaration(Mod.NAME)
    public static final class Mod extends OnnxOp {
        public static final String NAME = "Mod";

        public enum Attribute implements OnnxAttribute {
            fmod(Long.class, true, 0),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            A(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            B(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            C(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public Mod(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        Mod(Mod that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public Mod transform(CopyContext cc, OpTransformer ot) {
            return new Mod(this, cc);
        }

        Mod(TypeElement resultType, Value A, Value B, java.util.Optional<Long> fmod) {
            super(SCHEMA, resultType, Set.of(), List.of(A, B), List.of(fmod));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(A(), B()));
        }

        public Value A() {
            return operands().get(0);
        }

        public Value B() {
            return operands().get(1);
        }

        public java.util.Optional<Long> fmod() {
            Long fmod = Attribute.fmod.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(fmod);
        }

    }

    public static Mod Mod(TypeElement resultType, Value A, Value B, java.util.Optional<Long> fmod) {
        return new Mod(resultType, A, B, fmod);
    }

    @OpFactoryHelper.OpDeclaration(Momentum.NAME)
    public static final class Momentum extends OnnxOp {
        public static final String NAME = "Momentum";

        public enum Attribute implements OnnxAttribute {
            mode(String.class, false, null),
            norm_coefficient(Float.class, false, null),
            alpha(Float.class, false, null),
            beta(Float.class, false, null),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T1(new OnnxType.TypeVariable("T1", List.of(OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),
            T2(new OnnxType.TypeVariable("T2", List.of(OnnxType.tensor(OnnxType.int64())))),
            T3(new OnnxType.TypeVariable("T3", List.of(OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            R(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            T(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),
            inputs(TypeConstraint.T3.typeVariable(), Quantifier.VARIADIC),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            outputs(TypeConstraint.T3.typeVariable(), Quantifier.VARIADIC),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public Momentum(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        Momentum(Momentum that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public Momentum transform(CopyContext cc, OpTransformer ot) {
            return new Momentum(this, cc);
        }

        Momentum(TypeElement resultType, Value R, Value T, List<Value> inputs, String mode, float norm_coefficient, float alpha, float beta) {
            super(SCHEMA, resultType, Set.of(), List.of(R, T, inputs), List.of(mode, norm_coefficient, alpha, beta));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(R(), T(), inputs()));
        }

        public Value R() {
            return operands().get(0);
        }

        public Value T() {
            return operands().get(1);
        }

        public List<Value> inputs() {
            return operands().subList(2, operands().size());
        }

        public String mode() {
            String mode = Attribute.mode.access(String.class, onnxAttributes);
            return mode;
        }

        public float norm_coefficient() {
            float norm_coefficient = Attribute.norm_coefficient.access(Float.class, onnxAttributes);
            return norm_coefficient;
        }

        public float alpha() {
            float alpha = Attribute.alpha.access(Float.class, onnxAttributes);
            return alpha;
        }

        public float beta() {
            float beta = Attribute.beta.access(Float.class, onnxAttributes);
            return beta;
        }

    }

    public static Momentum Momentum(TypeElement resultType, Value R, Value T, List<Value> inputs, String mode, float norm_coefficient, float alpha, float beta) {
        return new Momentum(resultType, R, T, inputs, mode, norm_coefficient, alpha, beta);
    }

    @OpFactoryHelper.OpDeclaration(Mul.NAME)
    public static final class Mul extends OnnxOp {
        public static final String NAME = "Mul";

        public enum Attribute implements OnnxAttribute.None { }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            A(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            B(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            C(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public Mul(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        Mul(Mul that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public Mul transform(CopyContext cc, OpTransformer ot) {
            return new Mul(this, cc);
        }

        Mul(TypeElement resultType, Value A, Value B) {
            super(SCHEMA, resultType, Set.of(), List.of(A, B), List.of());
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(A(), B()));
        }

        public Value A() {
            return operands().get(0);
        }

        public Value B() {
            return operands().get(1);
        }

    }

    public static Mul Mul(TypeElement resultType, Value A, Value B) {
        return new Mul(resultType, A, B);
    }

    @OpFactoryHelper.OpDeclaration(Multinomial.NAME)
    public static final class Multinomial extends OnnxOp {
        public static final String NAME = "Multinomial";

        public enum Attribute implements OnnxAttribute {
            seed(Float.class, true, null),
            sample_size(Long.class, true, 1),
            dtype(Long.class, true, 6),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T1(new OnnxType.TypeVariable("T1", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),
            T2(new OnnxType.TypeVariable("T2", List.of(OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            input(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public Multinomial(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        Multinomial(Multinomial that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public Multinomial transform(CopyContext cc, OpTransformer ot) {
            return new Multinomial(this, cc);
        }

        Multinomial(TypeElement resultType, Value input, java.util.Optional<Float> seed, java.util.Optional<Long> sample_size, java.util.Optional<Long> dtype) {
            super(SCHEMA, resultType, Set.of(), List.of(input), List.of(seed, sample_size, dtype));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(input()));
        }

        public Value input() {
            return operands().get(0);
        }

        public java.util.Optional<Float> seed() {
            Float seed = Attribute.seed.access(Float.class, onnxAttributes);
            return java.util.Optional.ofNullable(seed);
        }

        public java.util.Optional<Long> sample_size() {
            Long sample_size = Attribute.sample_size.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(sample_size);
        }

        public java.util.Optional<Long> dtype() {
            Long dtype = Attribute.dtype.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(dtype);
        }

    }

    public static Multinomial Multinomial(TypeElement resultType, Value input, java.util.Optional<Float> seed, java.util.Optional<Long> sample_size, java.util.Optional<Long> dtype) {
        return new Multinomial(resultType, input, seed, sample_size, dtype);
    }

    @OpFactoryHelper.OpDeclaration(Neg.NAME)
    public static final class Neg extends OnnxOp {
        public static final String NAME = "Neg";

        public enum Attribute implements OnnxAttribute.None { }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public Neg(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        Neg(Neg that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public Neg transform(CopyContext cc, OpTransformer ot) {
            return new Neg(this, cc);
        }

        Neg(TypeElement resultType, Value X) {
            super(SCHEMA, resultType, Set.of(), List.of(X), List.of());
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X()));
        }

        public Value X() {
            return operands().get(0);
        }

    }

    public static Neg Neg(TypeElement resultType, Value X) {
        return new Neg(resultType, X);
    }

    @OpFactoryHelper.OpDeclaration(NegativeLogLikelihoodLoss.NAME)
    public static final class NegativeLogLikelihoodLoss extends OnnxOp {
        public static final String NAME = "NegativeLogLikelihoodLoss";

        public enum Attribute implements OnnxAttribute {
            ignore_index(Long.class, true, null),
            reduction(String.class, true, "mean"),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),
            Tind(new OnnxType.TypeVariable("Tind", List.of(OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            input(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            target(TypeConstraint.Tind.typeVariable(), Quantifier.REQUIRED),
            weight(TypeConstraint.T.typeVariable(), Quantifier.OPTIONAL),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            loss(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public NegativeLogLikelihoodLoss(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        NegativeLogLikelihoodLoss(NegativeLogLikelihoodLoss that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public NegativeLogLikelihoodLoss transform(CopyContext cc, OpTransformer ot) {
            return new NegativeLogLikelihoodLoss(this, cc);
        }

        NegativeLogLikelihoodLoss(TypeElement resultType, Value input, Value target, java.util.Optional<Value> weight, java.util.Optional<Long> ignore_index, java.util.Optional<String> reduction) {
            super(SCHEMA, resultType, Set.of(), List.of(input, target, weight), List.of(ignore_index, reduction));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(input(), target(), weight()));
        }

        public Value input() {
            return operands().get(0);
        }

        public Value target() {
            return operands().get(1);
        }

        public java.util.Optional<Value> weight() {
            int i = optionalInputArguments.indexOf(InputParameter.weight);
            return i != -1 ? java.util.Optional.of(operands().get(2 + i)) : java.util.Optional.empty();
        }

        public java.util.Optional<Long> ignore_index() {
            Long ignore_index = Attribute.ignore_index.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(ignore_index);
        }

        public java.util.Optional<String> reduction() {
            String reduction = Attribute.reduction.access(String.class, onnxAttributes);
            return java.util.Optional.ofNullable(reduction);
        }

    }

    public static NegativeLogLikelihoodLoss NegativeLogLikelihoodLoss(TypeElement resultType, Value input, Value target, java.util.Optional<Value> weight, java.util.Optional<Long> ignore_index, java.util.Optional<String> reduction) {
        return new NegativeLogLikelihoodLoss(resultType, input, target, weight, ignore_index, reduction);
    }

    @OpFactoryHelper.OpDeclaration(NonMaxSuppression.NAME)
    public static final class NonMaxSuppression extends OnnxOp {
        public static final String NAME = "NonMaxSuppression";

        public enum Attribute implements OnnxAttribute {
            center_point_box(Long.class, true, 0),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint.None { }

        public enum InputParameter implements OnnxParameter {
            boxes(OnnxType.tensor(OnnxType.float32()), Quantifier.REQUIRED),
            scores(OnnxType.tensor(OnnxType.float32()), Quantifier.REQUIRED),
            max_output_boxes_per_class(OnnxType.tensor(OnnxType.int64()), Quantifier.OPTIONAL),
            iou_threshold(OnnxType.tensor(OnnxType.float32()), Quantifier.OPTIONAL),
            score_threshold(OnnxType.tensor(OnnxType.float32()), Quantifier.OPTIONAL),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            selected_indices(OnnxType.tensor(OnnxType.int64()), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public NonMaxSuppression(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        NonMaxSuppression(NonMaxSuppression that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public NonMaxSuppression transform(CopyContext cc, OpTransformer ot) {
            return new NonMaxSuppression(this, cc);
        }

        NonMaxSuppression(TypeElement resultType, Value boxes, Value scores, java.util.Optional<Value> max_output_boxes_per_class, java.util.Optional<Value> iou_threshold, java.util.Optional<Value> score_threshold, java.util.Optional<Long> center_point_box) {
            super(SCHEMA, resultType, Set.of(), List.of(boxes, scores, max_output_boxes_per_class, iou_threshold, score_threshold), List.of(center_point_box));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(boxes(), scores(), max_output_boxes_per_class(), iou_threshold(), score_threshold()));
        }

        public Value boxes() {
            return operands().get(0);
        }

        public Value scores() {
            return operands().get(1);
        }

        public java.util.Optional<Value> max_output_boxes_per_class() {
            int i = optionalInputArguments.indexOf(InputParameter.max_output_boxes_per_class);
            return i != -1 ? java.util.Optional.of(operands().get(2 + i)) : java.util.Optional.empty();
        }

        public java.util.Optional<Value> iou_threshold() {
            int i = optionalInputArguments.indexOf(InputParameter.iou_threshold);
            return i != -1 ? java.util.Optional.of(operands().get(2 + i)) : java.util.Optional.empty();
        }

        public java.util.Optional<Value> score_threshold() {
            int i = optionalInputArguments.indexOf(InputParameter.score_threshold);
            return i != -1 ? java.util.Optional.of(operands().get(2 + i)) : java.util.Optional.empty();
        }

        public java.util.Optional<Long> center_point_box() {
            Long center_point_box = Attribute.center_point_box.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(center_point_box);
        }

    }

    public static NonMaxSuppression NonMaxSuppression(TypeElement resultType, Value boxes, Value scores, java.util.Optional<Value> max_output_boxes_per_class, java.util.Optional<Value> iou_threshold, java.util.Optional<Value> score_threshold, java.util.Optional<Long> center_point_box) {
        return new NonMaxSuppression(resultType, boxes, scores, max_output_boxes_per_class, iou_threshold, score_threshold, center_point_box);
    }

    @OpFactoryHelper.OpDeclaration(NonZero.NAME)
    public static final class NonZero extends OnnxOp {
        public static final String NAME = "NonZero";

        public enum Attribute implements OnnxAttribute.None { }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            Y(OnnxType.tensor(OnnxType.int64()), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public NonZero(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        NonZero(NonZero that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public NonZero transform(CopyContext cc, OpTransformer ot) {
            return new NonZero(this, cc);
        }

        NonZero(TypeElement resultType, Value X) {
            super(SCHEMA, resultType, Set.of(), List.of(X), List.of());
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X()));
        }

        public Value X() {
            return operands().get(0);
        }

    }

    public static NonZero NonZero(TypeElement resultType, Value X) {
        return new NonZero(resultType, X);
    }

    @OpFactoryHelper.OpDeclaration(Normalizer.NAME)
    public static final class Normalizer extends OnnxOp {
        public static final String NAME = "Normalizer";

        public enum Attribute implements OnnxAttribute {
            norm(String.class, true, "MAX"),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.int32())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            Y(OnnxType.tensor(OnnxType.float32()), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public Normalizer(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        Normalizer(Normalizer that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public Normalizer transform(CopyContext cc, OpTransformer ot) {
            return new Normalizer(this, cc);
        }

        Normalizer(TypeElement resultType, Value X, java.util.Optional<String> norm) {
            super(SCHEMA, resultType, Set.of(), List.of(X), List.of(norm));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X()));
        }

        public Value X() {
            return operands().get(0);
        }

        public java.util.Optional<String> norm() {
            String norm = Attribute.norm.access(String.class, onnxAttributes);
            return java.util.Optional.ofNullable(norm);
        }

    }

    public static Normalizer Normalizer(TypeElement resultType, Value X, java.util.Optional<String> norm) {
        return new Normalizer(resultType, X, norm);
    }

    @OpFactoryHelper.OpDeclaration(Not.NAME)
    public static final class Not extends OnnxOp {
        public static final String NAME = "Not";

        public enum Attribute implements OnnxAttribute.None { }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.bool())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public Not(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        Not(Not that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public Not transform(CopyContext cc, OpTransformer ot) {
            return new Not(this, cc);
        }

        Not(TypeElement resultType, Value X) {
            super(SCHEMA, resultType, Set.of(), List.of(X), List.of());
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X()));
        }

        public Value X() {
            return operands().get(0);
        }

    }

    public static Not Not(TypeElement resultType, Value X) {
        return new Not(resultType, X);
    }

    @OpFactoryHelper.OpDeclaration(OneHot.NAME)
    public static final class OneHot extends OnnxOp {
        public static final String NAME = "OneHot";

        public enum Attribute implements OnnxAttribute {
            axis(Long.class, true, -1),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T1(new OnnxType.TypeVariable("T1", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),
            T2(new OnnxType.TypeVariable("T2", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),
            T3(new OnnxType.TypeVariable("T3", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            indices(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            depth(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),
            values(TypeConstraint.T3.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T3.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public OneHot(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        OneHot(OneHot that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public OneHot transform(CopyContext cc, OpTransformer ot) {
            return new OneHot(this, cc);
        }

        OneHot(TypeElement resultType, Value indices, Value depth, Value values, java.util.Optional<Long> axis) {
            super(SCHEMA, resultType, Set.of(), List.of(indices, depth, values), List.of(axis));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(indices(), depth(), values()));
        }

        public Value indices() {
            return operands().get(0);
        }

        public Value depth() {
            return operands().get(1);
        }

        public Value values() {
            return operands().get(2);
        }

        public java.util.Optional<Long> axis() {
            Long axis = Attribute.axis.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(axis);
        }

    }

    public static OneHot OneHot(TypeElement resultType, Value indices, Value depth, Value values, java.util.Optional<Long> axis) {
        return new OneHot(resultType, indices, depth, values, axis);
    }

    @OpFactoryHelper.OpDeclaration(OneHotEncoder.NAME)
    public static final class OneHotEncoder extends OnnxOp {
        public static final String NAME = "OneHotEncoder";

        public enum Attribute implements OnnxAttribute {
            cats_strings(String[].class, true, null),
            cats_int64s(long[].class, true, null),
            zeros(Long.class, true, 1),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            Y(OnnxType.tensor(OnnxType.float32()), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public OneHotEncoder(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        OneHotEncoder(OneHotEncoder that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public OneHotEncoder transform(CopyContext cc, OpTransformer ot) {
            return new OneHotEncoder(this, cc);
        }

        OneHotEncoder(TypeElement resultType, Value X, java.util.Optional<String[]> cats_strings, java.util.Optional<long[]> cats_int64s, java.util.Optional<Long> zeros) {
            super(SCHEMA, resultType, Set.of(), List.of(X), List.of(cats_strings, cats_int64s, zeros));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X()));
        }

        public Value X() {
            return operands().get(0);
        }

        public java.util.Optional<String[]> cats_strings() {
            String[] cats_strings = Attribute.cats_strings.access(String[].class, onnxAttributes);
            return java.util.Optional.ofNullable(cats_strings).map(String[]::clone);
        }

        public java.util.Optional<long[]> cats_int64s() {
            long[] cats_int64s = Attribute.cats_int64s.access(long[].class, onnxAttributes);
            return java.util.Optional.ofNullable(cats_int64s).map(long[]::clone);
        }

        public java.util.Optional<Long> zeros() {
            Long zeros = Attribute.zeros.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(zeros);
        }

    }

    public static OneHotEncoder OneHotEncoder(TypeElement resultType, Value X, java.util.Optional<String[]> cats_strings, java.util.Optional<long[]> cats_int64s, java.util.Optional<Long> zeros) {
        return new OneHotEncoder(resultType, X, cats_strings, cats_int64s, zeros);
    }

    @OpFactoryHelper.OpDeclaration(Optional.NAME)
    public static final class Optional extends OnnxOp {
        public static final String NAME = "Optional";

        public enum Attribute implements OnnxAttribute {
            type(Object.class, true, null),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            V(new OnnxType.TypeVariable("V", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128()), OnnxType.seq(OnnxType.tensor(OnnxType.uint8())), OnnxType.seq(OnnxType.tensor(OnnxType.uint16())), OnnxType.seq(OnnxType.tensor(OnnxType.uint32())), OnnxType.seq(OnnxType.tensor(OnnxType.uint64())), OnnxType.seq(OnnxType.tensor(OnnxType.int8())), OnnxType.seq(OnnxType.tensor(OnnxType.int16())), OnnxType.seq(OnnxType.tensor(OnnxType.int32())), OnnxType.seq(OnnxType.tensor(OnnxType.int64())), OnnxType.seq(OnnxType.tensor(OnnxType.float16())), OnnxType.seq(OnnxType.tensor(OnnxType.float32())), OnnxType.seq(OnnxType.tensor(OnnxType.float64())), OnnxType.seq(OnnxType.tensor(OnnxType.string())), OnnxType.seq(OnnxType.tensor(OnnxType.bool())), OnnxType.seq(OnnxType.tensor(OnnxType.complex64())), OnnxType.seq(OnnxType.tensor(OnnxType.complex128()))))),
            O(new OnnxType.TypeVariable("O", List.of(OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.uint8()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.uint16()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.uint32()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.uint64()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.int8()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.int16()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.int32()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.int64()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.float16()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.float32()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.float64()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.string()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.bool()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.complex64()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.complex128()))), OnnxType.optional(OnnxType.tensor(OnnxType.uint8())), OnnxType.optional(OnnxType.tensor(OnnxType.uint16())), OnnxType.optional(OnnxType.tensor(OnnxType.uint32())), OnnxType.optional(OnnxType.tensor(OnnxType.uint64())), OnnxType.optional(OnnxType.tensor(OnnxType.int8())), OnnxType.optional(OnnxType.tensor(OnnxType.int16())), OnnxType.optional(OnnxType.tensor(OnnxType.int32())), OnnxType.optional(OnnxType.tensor(OnnxType.int64())), OnnxType.optional(OnnxType.tensor(OnnxType.float16())), OnnxType.optional(OnnxType.tensor(OnnxType.float32())), OnnxType.optional(OnnxType.tensor(OnnxType.float64())), OnnxType.optional(OnnxType.tensor(OnnxType.string())), OnnxType.optional(OnnxType.tensor(OnnxType.bool())), OnnxType.optional(OnnxType.tensor(OnnxType.complex64())), OnnxType.optional(OnnxType.tensor(OnnxType.complex128()))))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            input(TypeConstraint.V.typeVariable(), Quantifier.OPTIONAL),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.O.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public Optional(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        Optional(Optional that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public Optional transform(CopyContext cc, OpTransformer ot) {
            return new Optional(this, cc);
        }

        Optional(TypeElement resultType, java.util.Optional<Value> input, java.util.Optional<Object> type) {
            super(SCHEMA, resultType, Set.of(), List.of(input), List.of(type));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(input()));
        }

        public java.util.Optional<Value> input() {
            int i = optionalInputArguments.indexOf(InputParameter.input);
            return i != -1 ? java.util.Optional.of(operands().get(0 + i)) : java.util.Optional.empty();
        }

        public java.util.Optional<Object> type() {
            Object type = Attribute.type.access(Object.class, onnxAttributes);
            return java.util.Optional.ofNullable(type);
        }

    }

    public static Optional Optional(TypeElement resultType, java.util.Optional<Value> input, java.util.Optional<Object> type) {
        return new Optional(resultType, input, type);
    }

    @OpFactoryHelper.OpDeclaration(OptionalGetElement.NAME)
    public static final class OptionalGetElement extends OnnxOp {
        public static final String NAME = "OptionalGetElement";

        public enum Attribute implements OnnxAttribute.None { }

        public enum TypeConstraint implements OnnxTypeConstraint {
            O(new OnnxType.TypeVariable("O", List.of(OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.uint8()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.uint16()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.uint32()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.uint64()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.int8()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.int16()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.int32()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.int64()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.float16()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.float32()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.float64()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.string()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.bool()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.complex64()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.complex128()))), OnnxType.optional(OnnxType.tensor(OnnxType.uint8())), OnnxType.optional(OnnxType.tensor(OnnxType.uint16())), OnnxType.optional(OnnxType.tensor(OnnxType.uint32())), OnnxType.optional(OnnxType.tensor(OnnxType.uint64())), OnnxType.optional(OnnxType.tensor(OnnxType.int8())), OnnxType.optional(OnnxType.tensor(OnnxType.int16())), OnnxType.optional(OnnxType.tensor(OnnxType.int32())), OnnxType.optional(OnnxType.tensor(OnnxType.int64())), OnnxType.optional(OnnxType.tensor(OnnxType.float16())), OnnxType.optional(OnnxType.tensor(OnnxType.float32())), OnnxType.optional(OnnxType.tensor(OnnxType.float64())), OnnxType.optional(OnnxType.tensor(OnnxType.string())), OnnxType.optional(OnnxType.tensor(OnnxType.bool())), OnnxType.optional(OnnxType.tensor(OnnxType.complex64())), OnnxType.optional(OnnxType.tensor(OnnxType.complex128())), OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128()), OnnxType.seq(OnnxType.tensor(OnnxType.uint8())), OnnxType.seq(OnnxType.tensor(OnnxType.uint16())), OnnxType.seq(OnnxType.tensor(OnnxType.uint32())), OnnxType.seq(OnnxType.tensor(OnnxType.uint64())), OnnxType.seq(OnnxType.tensor(OnnxType.int8())), OnnxType.seq(OnnxType.tensor(OnnxType.int16())), OnnxType.seq(OnnxType.tensor(OnnxType.int32())), OnnxType.seq(OnnxType.tensor(OnnxType.int64())), OnnxType.seq(OnnxType.tensor(OnnxType.float16())), OnnxType.seq(OnnxType.tensor(OnnxType.float32())), OnnxType.seq(OnnxType.tensor(OnnxType.float64())), OnnxType.seq(OnnxType.tensor(OnnxType.string())), OnnxType.seq(OnnxType.tensor(OnnxType.bool())), OnnxType.seq(OnnxType.tensor(OnnxType.complex64())), OnnxType.seq(OnnxType.tensor(OnnxType.complex128()))))),
            V(new OnnxType.TypeVariable("V", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128()), OnnxType.seq(OnnxType.tensor(OnnxType.uint8())), OnnxType.seq(OnnxType.tensor(OnnxType.uint16())), OnnxType.seq(OnnxType.tensor(OnnxType.uint32())), OnnxType.seq(OnnxType.tensor(OnnxType.uint64())), OnnxType.seq(OnnxType.tensor(OnnxType.int8())), OnnxType.seq(OnnxType.tensor(OnnxType.int16())), OnnxType.seq(OnnxType.tensor(OnnxType.int32())), OnnxType.seq(OnnxType.tensor(OnnxType.int64())), OnnxType.seq(OnnxType.tensor(OnnxType.float16())), OnnxType.seq(OnnxType.tensor(OnnxType.float32())), OnnxType.seq(OnnxType.tensor(OnnxType.float64())), OnnxType.seq(OnnxType.tensor(OnnxType.string())), OnnxType.seq(OnnxType.tensor(OnnxType.bool())), OnnxType.seq(OnnxType.tensor(OnnxType.complex64())), OnnxType.seq(OnnxType.tensor(OnnxType.complex128()))))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            input(TypeConstraint.O.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.V.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public OptionalGetElement(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        OptionalGetElement(OptionalGetElement that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public OptionalGetElement transform(CopyContext cc, OpTransformer ot) {
            return new OptionalGetElement(this, cc);
        }

        OptionalGetElement(TypeElement resultType, Value input) {
            super(SCHEMA, resultType, Set.of(), List.of(input), List.of());
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(input()));
        }

        public Value input() {
            return operands().get(0);
        }

    }

    public static OptionalGetElement OptionalGetElement(TypeElement resultType, Value input) {
        return new OptionalGetElement(resultType, input);
    }

    @OpFactoryHelper.OpDeclaration(OptionalHasElement.NAME)
    public static final class OptionalHasElement extends OnnxOp {
        public static final String NAME = "OptionalHasElement";

        public enum Attribute implements OnnxAttribute.None { }

        public enum TypeConstraint implements OnnxTypeConstraint {
            O(new OnnxType.TypeVariable("O", List.of(OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.uint8()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.uint16()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.uint32()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.uint64()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.int8()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.int16()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.int32()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.int64()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.float16()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.float32()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.float64()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.string()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.bool()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.complex64()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.complex128()))), OnnxType.optional(OnnxType.tensor(OnnxType.uint8())), OnnxType.optional(OnnxType.tensor(OnnxType.uint16())), OnnxType.optional(OnnxType.tensor(OnnxType.uint32())), OnnxType.optional(OnnxType.tensor(OnnxType.uint64())), OnnxType.optional(OnnxType.tensor(OnnxType.int8())), OnnxType.optional(OnnxType.tensor(OnnxType.int16())), OnnxType.optional(OnnxType.tensor(OnnxType.int32())), OnnxType.optional(OnnxType.tensor(OnnxType.int64())), OnnxType.optional(OnnxType.tensor(OnnxType.float16())), OnnxType.optional(OnnxType.tensor(OnnxType.float32())), OnnxType.optional(OnnxType.tensor(OnnxType.float64())), OnnxType.optional(OnnxType.tensor(OnnxType.string())), OnnxType.optional(OnnxType.tensor(OnnxType.bool())), OnnxType.optional(OnnxType.tensor(OnnxType.complex64())), OnnxType.optional(OnnxType.tensor(OnnxType.complex128())), OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128()), OnnxType.seq(OnnxType.tensor(OnnxType.uint8())), OnnxType.seq(OnnxType.tensor(OnnxType.uint16())), OnnxType.seq(OnnxType.tensor(OnnxType.uint32())), OnnxType.seq(OnnxType.tensor(OnnxType.uint64())), OnnxType.seq(OnnxType.tensor(OnnxType.int8())), OnnxType.seq(OnnxType.tensor(OnnxType.int16())), OnnxType.seq(OnnxType.tensor(OnnxType.int32())), OnnxType.seq(OnnxType.tensor(OnnxType.int64())), OnnxType.seq(OnnxType.tensor(OnnxType.float16())), OnnxType.seq(OnnxType.tensor(OnnxType.float32())), OnnxType.seq(OnnxType.tensor(OnnxType.float64())), OnnxType.seq(OnnxType.tensor(OnnxType.string())), OnnxType.seq(OnnxType.tensor(OnnxType.bool())), OnnxType.seq(OnnxType.tensor(OnnxType.complex64())), OnnxType.seq(OnnxType.tensor(OnnxType.complex128()))))),
            B(new OnnxType.TypeVariable("B", List.of(OnnxType.tensor(OnnxType.bool())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            input(TypeConstraint.O.typeVariable(), Quantifier.OPTIONAL),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.B.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public OptionalHasElement(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        OptionalHasElement(OptionalHasElement that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public OptionalHasElement transform(CopyContext cc, OpTransformer ot) {
            return new OptionalHasElement(this, cc);
        }

        OptionalHasElement(TypeElement resultType, java.util.Optional<Value> input) {
            super(SCHEMA, resultType, Set.of(), List.of(input), List.of());
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(input()));
        }

        public java.util.Optional<Value> input() {
            int i = optionalInputArguments.indexOf(InputParameter.input);
            return i != -1 ? java.util.Optional.of(operands().get(0 + i)) : java.util.Optional.empty();
        }

    }

    public static OptionalHasElement OptionalHasElement(TypeElement resultType, java.util.Optional<Value> input) {
        return new OptionalHasElement(resultType, input);
    }

    @OpFactoryHelper.OpDeclaration(Or.NAME)
    public static final class Or extends OnnxOp {
        public static final String NAME = "Or";

        public enum Attribute implements OnnxAttribute.None { }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.bool())))),
            T1(new OnnxType.TypeVariable("T1", List.of(OnnxType.tensor(OnnxType.bool())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            A(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            B(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            C(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public Or(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        Or(Or that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public Or transform(CopyContext cc, OpTransformer ot) {
            return new Or(this, cc);
        }

        Or(TypeElement resultType, Value A, Value B) {
            super(SCHEMA, resultType, Set.of(), List.of(A, B), List.of());
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(A(), B()));
        }

        public Value A() {
            return operands().get(0);
        }

        public Value B() {
            return operands().get(1);
        }

    }

    public static Or Or(TypeElement resultType, Value A, Value B) {
        return new Or(resultType, A, B);
    }

    @OpFactoryHelper.OpDeclaration(PRelu.NAME)
    public static final class PRelu extends OnnxOp {
        public static final String NAME = "PRelu";

        public enum Attribute implements OnnxAttribute.None { }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            slope(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public PRelu(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        PRelu(PRelu that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public PRelu transform(CopyContext cc, OpTransformer ot) {
            return new PRelu(this, cc);
        }

        PRelu(TypeElement resultType, Value X, Value slope) {
            super(SCHEMA, resultType, Set.of(), List.of(X, slope), List.of());
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X(), slope()));
        }

        public Value X() {
            return operands().get(0);
        }

        public Value slope() {
            return operands().get(1);
        }

    }

    public static PRelu PRelu(TypeElement resultType, Value X, Value slope) {
        return new PRelu(resultType, X, slope);
    }

    @OpFactoryHelper.OpDeclaration(Pad.NAME)
    public static final class Pad extends OnnxOp {
        public static final String NAME = "Pad";

        public enum Attribute implements OnnxAttribute {
            mode(String.class, true, "constant"),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128()), OnnxType.tensor(OnnxType.float8e4m3fn()), OnnxType.tensor(OnnxType.float8e4m3fnuz()), OnnxType.tensor(OnnxType.float8e5m2()), OnnxType.tensor(OnnxType.float8e5m2fnuz()), OnnxType.tensor(OnnxType.uint4()), OnnxType.tensor(OnnxType.int4()), OnnxType.tensor(OnnxType.float4e2m1())))),
            Tind(new OnnxType.TypeVariable("Tind", List.of(OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            data(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            pads(OnnxType.tensor(OnnxType.int64()), Quantifier.REQUIRED),
            constant_value(TypeConstraint.T.typeVariable(), Quantifier.OPTIONAL),
            axes(TypeConstraint.Tind.typeVariable(), Quantifier.OPTIONAL),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public Pad(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        Pad(Pad that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public Pad transform(CopyContext cc, OpTransformer ot) {
            return new Pad(this, cc);
        }

        Pad(TypeElement resultType, Value data, Value pads, java.util.Optional<Value> constant_value, java.util.Optional<Value> axes, java.util.Optional<String> mode) {
            super(SCHEMA, resultType, Set.of(), List.of(data, pads, constant_value, axes), List.of(mode));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(data(), pads(), constant_value(), axes()));
        }

        public Value data() {
            return operands().get(0);
        }

        public Value pads() {
            return operands().get(1);
        }

        public java.util.Optional<Value> constant_value() {
            int i = optionalInputArguments.indexOf(InputParameter.constant_value);
            return i != -1 ? java.util.Optional.of(operands().get(2 + i)) : java.util.Optional.empty();
        }

        public java.util.Optional<Value> axes() {
            int i = optionalInputArguments.indexOf(InputParameter.axes);
            return i != -1 ? java.util.Optional.of(operands().get(2 + i)) : java.util.Optional.empty();
        }

        public java.util.Optional<String> mode() {
            String mode = Attribute.mode.access(String.class, onnxAttributes);
            return java.util.Optional.ofNullable(mode);
        }

    }

    public static Pad Pad(TypeElement resultType, Value data, Value pads, java.util.Optional<Value> constant_value, java.util.Optional<Value> axes, java.util.Optional<String> mode) {
        return new Pad(resultType, data, pads, constant_value, axes, mode);
    }

    @OpFactoryHelper.OpDeclaration(Pow.NAME)
    public static final class Pow extends OnnxOp {
        public static final String NAME = "Pow";

        public enum Attribute implements OnnxAttribute.None { }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),
            T1(new OnnxType.TypeVariable("T1", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            Y(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            Z(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public Pow(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        Pow(Pow that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public Pow transform(CopyContext cc, OpTransformer ot) {
            return new Pow(this, cc);
        }

        Pow(TypeElement resultType, Value X, Value Y) {
            super(SCHEMA, resultType, Set.of(), List.of(X, Y), List.of());
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X(), Y()));
        }

        public Value X() {
            return operands().get(0);
        }

        public Value Y() {
            return operands().get(1);
        }

    }

    public static Pow Pow(TypeElement resultType, Value X, Value Y) {
        return new Pow(resultType, X, Y);
    }

    @OpFactoryHelper.OpDeclaration(QLinearConv.NAME)
    public static final class QLinearConv extends OnnxOp {
        public static final String NAME = "QLinearConv";

        public enum Attribute implements OnnxAttribute {
            pads(long[].class, true, null),
            dilations(long[].class, true, null),
            auto_pad(String.class, true, "NOTSET"),
            strides(long[].class, true, null),
            group(Long.class, true, 1),
            kernel_shape(long[].class, true, null),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T1(new OnnxType.TypeVariable("T1", List.of(OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.uint8())))),
            T2(new OnnxType.TypeVariable("T2", List.of(OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.uint8())))),
            T3(new OnnxType.TypeVariable("T3", List.of(OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.uint8())))),
            T4(new OnnxType.TypeVariable("T4", List.of(OnnxType.tensor(OnnxType.int32())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            x(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            x_scale(OnnxType.tensor(OnnxType.float32()), Quantifier.REQUIRED),
            x_zero_point(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            w(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),
            w_scale(OnnxType.tensor(OnnxType.float32()), Quantifier.REQUIRED),
            w_zero_point(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),
            y_scale(OnnxType.tensor(OnnxType.float32()), Quantifier.REQUIRED),
            y_zero_point(TypeConstraint.T3.typeVariable(), Quantifier.REQUIRED),
            B(TypeConstraint.T4.typeVariable(), Quantifier.OPTIONAL),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            y(TypeConstraint.T3.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public QLinearConv(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        QLinearConv(QLinearConv that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public QLinearConv transform(CopyContext cc, OpTransformer ot) {
            return new QLinearConv(this, cc);
        }

        QLinearConv(TypeElement resultType, Value x, Value x_scale, Value x_zero_point, Value w, Value w_scale, Value w_zero_point, Value y_scale, Value y_zero_point, java.util.Optional<Value> B, java.util.Optional<long[]> pads, java.util.Optional<long[]> dilations, java.util.Optional<String> auto_pad, java.util.Optional<long[]> strides, java.util.Optional<Long> group, java.util.Optional<long[]> kernel_shape) {
            super(SCHEMA, resultType, Set.of(), List.of(x, x_scale, x_zero_point, w, w_scale, w_zero_point, y_scale, y_zero_point, B), List.of(pads, dilations, auto_pad, strides, group, kernel_shape));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(x(), x_scale(), x_zero_point(), w(), w_scale(), w_zero_point(), y_scale(), y_zero_point(), B()));
        }

        public Value x() {
            return operands().get(0);
        }

        public Value x_scale() {
            return operands().get(1);
        }

        public Value x_zero_point() {
            return operands().get(2);
        }

        public Value w() {
            return operands().get(3);
        }

        public Value w_scale() {
            return operands().get(4);
        }

        public Value w_zero_point() {
            return operands().get(5);
        }

        public Value y_scale() {
            return operands().get(6);
        }

        public Value y_zero_point() {
            return operands().get(7);
        }

        public java.util.Optional<Value> B() {
            int i = optionalInputArguments.indexOf(InputParameter.B);
            return i != -1 ? java.util.Optional.of(operands().get(8 + i)) : java.util.Optional.empty();
        }

        public java.util.Optional<long[]> pads() {
            long[] pads = Attribute.pads.access(long[].class, onnxAttributes);
            return java.util.Optional.ofNullable(pads).map(long[]::clone);
        }

        public java.util.Optional<long[]> dilations() {
            long[] dilations = Attribute.dilations.access(long[].class, onnxAttributes);
            return java.util.Optional.ofNullable(dilations).map(long[]::clone);
        }

        public java.util.Optional<String> auto_pad() {
            String auto_pad = Attribute.auto_pad.access(String.class, onnxAttributes);
            return java.util.Optional.ofNullable(auto_pad);
        }

        public java.util.Optional<long[]> strides() {
            long[] strides = Attribute.strides.access(long[].class, onnxAttributes);
            return java.util.Optional.ofNullable(strides).map(long[]::clone);
        }

        public java.util.Optional<Long> group() {
            Long group = Attribute.group.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(group);
        }

        public java.util.Optional<long[]> kernel_shape() {
            long[] kernel_shape = Attribute.kernel_shape.access(long[].class, onnxAttributes);
            return java.util.Optional.ofNullable(kernel_shape).map(long[]::clone);
        }

    }

    public static QLinearConv QLinearConv(TypeElement resultType, Value x, Value x_scale, Value x_zero_point, Value w, Value w_scale, Value w_zero_point, Value y_scale, Value y_zero_point, java.util.Optional<Value> B, java.util.Optional<long[]> pads, java.util.Optional<long[]> dilations, java.util.Optional<String> auto_pad, java.util.Optional<long[]> strides, java.util.Optional<Long> group, java.util.Optional<long[]> kernel_shape) {
        return new QLinearConv(resultType, x, x_scale, x_zero_point, w, w_scale, w_zero_point, y_scale, y_zero_point, B, pads, dilations, auto_pad, strides, group, kernel_shape);
    }

    @OpFactoryHelper.OpDeclaration(QLinearMatMul.NAME)
    public static final class QLinearMatMul extends OnnxOp {
        public static final String NAME = "QLinearMatMul";

        public enum Attribute implements OnnxAttribute.None { }

        public enum TypeConstraint implements OnnxTypeConstraint {
            TS(new OnnxType.TypeVariable("TS", List.of(OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.bfloat16())))),
            T1(new OnnxType.TypeVariable("T1", List.of(OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.float8e4m3fn()), OnnxType.tensor(OnnxType.float8e4m3fnuz()), OnnxType.tensor(OnnxType.float8e5m2()), OnnxType.tensor(OnnxType.float8e5m2fnuz())))),
            T2(new OnnxType.TypeVariable("T2", List.of(OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.float8e4m3fn()), OnnxType.tensor(OnnxType.float8e4m3fnuz()), OnnxType.tensor(OnnxType.float8e5m2()), OnnxType.tensor(OnnxType.float8e5m2fnuz())))),
            T3(new OnnxType.TypeVariable("T3", List.of(OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.float8e4m3fn()), OnnxType.tensor(OnnxType.float8e4m3fnuz()), OnnxType.tensor(OnnxType.float8e5m2()), OnnxType.tensor(OnnxType.float8e5m2fnuz())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            a(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            a_scale(TypeConstraint.TS.typeVariable(), Quantifier.REQUIRED),
            a_zero_point(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            b(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),
            b_scale(TypeConstraint.TS.typeVariable(), Quantifier.REQUIRED),
            b_zero_point(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),
            y_scale(TypeConstraint.TS.typeVariable(), Quantifier.REQUIRED),
            y_zero_point(TypeConstraint.T3.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            y(TypeConstraint.T3.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public QLinearMatMul(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        QLinearMatMul(QLinearMatMul that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public QLinearMatMul transform(CopyContext cc, OpTransformer ot) {
            return new QLinearMatMul(this, cc);
        }

        QLinearMatMul(TypeElement resultType, Value a, Value a_scale, Value a_zero_point, Value b, Value b_scale, Value b_zero_point, Value y_scale, Value y_zero_point) {
            super(SCHEMA, resultType, Set.of(), List.of(a, a_scale, a_zero_point, b, b_scale, b_zero_point, y_scale, y_zero_point), List.of());
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(a(), a_scale(), a_zero_point(), b(), b_scale(), b_zero_point(), y_scale(), y_zero_point()));
        }

        public Value a() {
            return operands().get(0);
        }

        public Value a_scale() {
            return operands().get(1);
        }

        public Value a_zero_point() {
            return operands().get(2);
        }

        public Value b() {
            return operands().get(3);
        }

        public Value b_scale() {
            return operands().get(4);
        }

        public Value b_zero_point() {
            return operands().get(5);
        }

        public Value y_scale() {
            return operands().get(6);
        }

        public Value y_zero_point() {
            return operands().get(7);
        }

    }

    public static QLinearMatMul QLinearMatMul(TypeElement resultType, Value a, Value a_scale, Value a_zero_point, Value b, Value b_scale, Value b_zero_point, Value y_scale, Value y_zero_point) {
        return new QLinearMatMul(resultType, a, a_scale, a_zero_point, b, b_scale, b_zero_point, y_scale, y_zero_point);
    }

    @OpFactoryHelper.OpDeclaration(QuantizeLinear.NAME)
    public static final class QuantizeLinear extends OnnxOp {
        public static final String NAME = "QuantizeLinear";

        public enum Attribute implements OnnxAttribute {
            output_dtype(Long.class, true, 0),
            saturate(Long.class, true, 1),
            axis(Long.class, true, 1),
            block_size(Long.class, true, 0),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T1(new OnnxType.TypeVariable("T1", List.of(OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.int32())))),
            T2(new OnnxType.TypeVariable("T2", List.of(OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.float8e4m3fn()), OnnxType.tensor(OnnxType.float8e4m3fnuz()), OnnxType.tensor(OnnxType.float8e5m2()), OnnxType.tensor(OnnxType.float8e5m2fnuz()), OnnxType.tensor(OnnxType.uint4()), OnnxType.tensor(OnnxType.int4()), OnnxType.tensor(OnnxType.float4e2m1())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            x(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            y_scale(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            y_zero_point(TypeConstraint.T2.typeVariable(), Quantifier.OPTIONAL),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            y(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public QuantizeLinear(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        QuantizeLinear(QuantizeLinear that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public QuantizeLinear transform(CopyContext cc, OpTransformer ot) {
            return new QuantizeLinear(this, cc);
        }

        QuantizeLinear(TypeElement resultType, Value x, Value y_scale, java.util.Optional<Value> y_zero_point, java.util.Optional<Long> output_dtype, java.util.Optional<Long> saturate, java.util.Optional<Long> axis, java.util.Optional<Long> block_size) {
            super(SCHEMA, resultType, Set.of(), List.of(x, y_scale, y_zero_point), List.of(output_dtype, saturate, axis, block_size));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(x(), y_scale(), y_zero_point()));
        }

        public Value x() {
            return operands().get(0);
        }

        public Value y_scale() {
            return operands().get(1);
        }

        public java.util.Optional<Value> y_zero_point() {
            int i = optionalInputArguments.indexOf(InputParameter.y_zero_point);
            return i != -1 ? java.util.Optional.of(operands().get(2 + i)) : java.util.Optional.empty();
        }

        public java.util.Optional<Long> output_dtype() {
            Long output_dtype = Attribute.output_dtype.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(output_dtype);
        }

        public java.util.Optional<Long> saturate() {
            Long saturate = Attribute.saturate.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(saturate);
        }

        public java.util.Optional<Long> axis() {
            Long axis = Attribute.axis.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(axis);
        }

        public java.util.Optional<Long> block_size() {
            Long block_size = Attribute.block_size.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(block_size);
        }

    }

    public static QuantizeLinear QuantizeLinear(TypeElement resultType, Value x, Value y_scale, java.util.Optional<Value> y_zero_point, java.util.Optional<Long> output_dtype, java.util.Optional<Long> saturate, java.util.Optional<Long> axis, java.util.Optional<Long> block_size) {
        return new QuantizeLinear(resultType, x, y_scale, y_zero_point, output_dtype, saturate, axis, block_size);
    }

    @OpFactoryHelper.OpDeclaration(RNN.NAME)
    public static final class RNN extends OnnxOp {
        public static final String NAME = "RNN";

        public enum Attribute implements OnnxAttribute {
            layout(Long.class, true, 0),
            activation_alpha(float[].class, true, null),
            hidden_size(Long.class, true, null),
            activation_beta(float[].class, true, null),
            activations(String[].class, true, null),
            clip(Float.class, true, null),
            direction(String.class, true, "forward"),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),
            T1(new OnnxType.TypeVariable("T1", List.of(OnnxType.tensor(OnnxType.int32())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            W(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            R(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            B(TypeConstraint.T.typeVariable(), Quantifier.OPTIONAL),
            sequence_lens(TypeConstraint.T1.typeVariable(), Quantifier.OPTIONAL),
            initial_h(TypeConstraint.T.typeVariable(), Quantifier.OPTIONAL),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T.typeVariable(), Quantifier.OPTIONAL),
            Y_h(TypeConstraint.T.typeVariable(), Quantifier.OPTIONAL),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public RNN(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        RNN(RNN that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public RNN transform(CopyContext cc, OpTransformer ot) {
            return new RNN(this, cc);
        }

        RNN(TypeElement resultType, Set<OutputParameter> optionalOutputs, Value X, Value W, Value R, java.util.Optional<Value> B, java.util.Optional<Value> sequence_lens, java.util.Optional<Value> initial_h, java.util.Optional<Long> layout, java.util.Optional<float[]> activation_alpha, java.util.Optional<Long> hidden_size, java.util.Optional<float[]> activation_beta, java.util.Optional<String[]> activations, java.util.Optional<Float> clip, java.util.Optional<String> direction) {
            super(SCHEMA, resultType, optionalOutputs, List.of(X, W, R, B, sequence_lens, initial_h), List.of(layout, activation_alpha, hidden_size, activation_beta, activations, clip, direction));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X(), W(), R(), B(), sequence_lens(), initial_h()));
        }

        public Value X() {
            return operands().get(0);
        }

        public Value W() {
            return operands().get(1);
        }

        public Value R() {
            return operands().get(2);
        }

        public java.util.Optional<Value> B() {
            int i = optionalInputArguments.indexOf(InputParameter.B);
            return i != -1 ? java.util.Optional.of(operands().get(3 + i)) : java.util.Optional.empty();
        }

        public java.util.Optional<Value> sequence_lens() {
            int i = optionalInputArguments.indexOf(InputParameter.sequence_lens);
            return i != -1 ? java.util.Optional.of(operands().get(3 + i)) : java.util.Optional.empty();
        }

        public java.util.Optional<Value> initial_h() {
            int i = optionalInputArguments.indexOf(InputParameter.initial_h);
            return i != -1 ? java.util.Optional.of(operands().get(3 + i)) : java.util.Optional.empty();
        }

        public java.util.Optional<Long> layout() {
            Long layout = Attribute.layout.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(layout);
        }

        public java.util.Optional<float[]> activation_alpha() {
            float[] activation_alpha = Attribute.activation_alpha.access(float[].class, onnxAttributes);
            return java.util.Optional.ofNullable(activation_alpha).map(float[]::clone);
        }

        public java.util.Optional<Long> hidden_size() {
            Long hidden_size = Attribute.hidden_size.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(hidden_size);
        }

        public java.util.Optional<float[]> activation_beta() {
            float[] activation_beta = Attribute.activation_beta.access(float[].class, onnxAttributes);
            return java.util.Optional.ofNullable(activation_beta).map(float[]::clone);
        }

        public java.util.Optional<String[]> activations() {
            String[] activations = Attribute.activations.access(String[].class, onnxAttributes);
            return java.util.Optional.ofNullable(activations).map(String[]::clone);
        }

        public java.util.Optional<Float> clip() {
            Float clip = Attribute.clip.access(Float.class, onnxAttributes);
            return java.util.Optional.ofNullable(clip);
        }

        public java.util.Optional<String> direction() {
            String direction = Attribute.direction.access(String.class, onnxAttributes);
            return java.util.Optional.ofNullable(direction);
        }

    }

    public static RNN RNN(TypeElement resultType, Set<RNN.OutputParameter> optionalOutputs, Value X, Value W, Value R, java.util.Optional<Value> B, java.util.Optional<Value> sequence_lens, java.util.Optional<Value> initial_h, java.util.Optional<Long> layout, java.util.Optional<float[]> activation_alpha, java.util.Optional<Long> hidden_size, java.util.Optional<float[]> activation_beta, java.util.Optional<String[]> activations, java.util.Optional<Float> clip, java.util.Optional<String> direction) {
        return new RNN(resultType, optionalOutputs, X, W, R, B, sequence_lens, initial_h, layout, activation_alpha, hidden_size, activation_beta, activations, clip, direction);
    }

    @OpFactoryHelper.OpDeclaration(RandomNormal.NAME)
    public static final class RandomNormal extends OnnxOp {
        public static final String NAME = "RandomNormal";

        public enum Attribute implements OnnxAttribute {
            shape(long[].class, false, null),
            seed(Float.class, true, null),
            mean(Float.class, true, 0.0f),
            scale(Float.class, true, 1.0f),
            dtype(Long.class, true, 1),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter.None { }

        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public RandomNormal(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        RandomNormal(RandomNormal that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public RandomNormal transform(CopyContext cc, OpTransformer ot) {
            return new RandomNormal(this, cc);
        }

        RandomNormal(TypeElement resultType, long[] shape, java.util.Optional<Float> seed, java.util.Optional<Float> mean, java.util.Optional<Float> scale, java.util.Optional<Long> dtype) {
            super(SCHEMA, resultType, Set.of(), List.of(), List.of(shape, seed, mean, scale, dtype));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of());
        }

        public long[] shape() {
            long[] shape = Attribute.shape.access(long[].class, onnxAttributes);
            return shape.clone();
        }

        public java.util.Optional<Float> seed() {
            Float seed = Attribute.seed.access(Float.class, onnxAttributes);
            return java.util.Optional.ofNullable(seed);
        }

        public java.util.Optional<Float> mean() {
            Float mean = Attribute.mean.access(Float.class, onnxAttributes);
            return java.util.Optional.ofNullable(mean);
        }

        public java.util.Optional<Float> scale() {
            Float scale = Attribute.scale.access(Float.class, onnxAttributes);
            return java.util.Optional.ofNullable(scale);
        }

        public java.util.Optional<Long> dtype() {
            Long dtype = Attribute.dtype.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(dtype);
        }

    }

    public static RandomNormal RandomNormal(TypeElement resultType, long[] shape, java.util.Optional<Float> seed, java.util.Optional<Float> mean, java.util.Optional<Float> scale, java.util.Optional<Long> dtype) {
        return new RandomNormal(resultType, shape, seed, mean, scale, dtype);
    }

    @OpFactoryHelper.OpDeclaration(RandomNormalLike.NAME)
    public static final class RandomNormalLike extends OnnxOp {
        public static final String NAME = "RandomNormalLike";

        public enum Attribute implements OnnxAttribute {
            seed(Float.class, true, null),
            mean(Float.class, true, 0.0f),
            scale(Float.class, true, 1.0f),
            dtype(Long.class, true, null),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T1(new OnnxType.TypeVariable("T1", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128())))),
            T2(new OnnxType.TypeVariable("T2", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            input(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public RandomNormalLike(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        RandomNormalLike(RandomNormalLike that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public RandomNormalLike transform(CopyContext cc, OpTransformer ot) {
            return new RandomNormalLike(this, cc);
        }

        RandomNormalLike(TypeElement resultType, Value input, java.util.Optional<Float> seed, java.util.Optional<Float> mean, java.util.Optional<Float> scale, java.util.Optional<Long> dtype) {
            super(SCHEMA, resultType, Set.of(), List.of(input), List.of(seed, mean, scale, dtype));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(input()));
        }

        public Value input() {
            return operands().get(0);
        }

        public java.util.Optional<Float> seed() {
            Float seed = Attribute.seed.access(Float.class, onnxAttributes);
            return java.util.Optional.ofNullable(seed);
        }

        public java.util.Optional<Float> mean() {
            Float mean = Attribute.mean.access(Float.class, onnxAttributes);
            return java.util.Optional.ofNullable(mean);
        }

        public java.util.Optional<Float> scale() {
            Float scale = Attribute.scale.access(Float.class, onnxAttributes);
            return java.util.Optional.ofNullable(scale);
        }

        public java.util.Optional<Long> dtype() {
            Long dtype = Attribute.dtype.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(dtype);
        }

    }

    public static RandomNormalLike RandomNormalLike(TypeElement resultType, Value input, java.util.Optional<Float> seed, java.util.Optional<Float> mean, java.util.Optional<Float> scale, java.util.Optional<Long> dtype) {
        return new RandomNormalLike(resultType, input, seed, mean, scale, dtype);
    }

    @OpFactoryHelper.OpDeclaration(RandomUniform.NAME)
    public static final class RandomUniform extends OnnxOp {
        public static final String NAME = "RandomUniform";

        public enum Attribute implements OnnxAttribute {
            high(Float.class, true, 1.0f),
            shape(long[].class, false, null),
            seed(Float.class, true, null),
            low(Float.class, true, 0.0f),
            dtype(Long.class, true, 1),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter.None { }

        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public RandomUniform(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        RandomUniform(RandomUniform that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public RandomUniform transform(CopyContext cc, OpTransformer ot) {
            return new RandomUniform(this, cc);
        }

        RandomUniform(TypeElement resultType, java.util.Optional<Float> high, long[] shape, java.util.Optional<Float> seed, java.util.Optional<Float> low, java.util.Optional<Long> dtype) {
            super(SCHEMA, resultType, Set.of(), List.of(), List.of(high, shape, seed, low, dtype));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of());
        }

        public java.util.Optional<Float> high() {
            Float high = Attribute.high.access(Float.class, onnxAttributes);
            return java.util.Optional.ofNullable(high);
        }

        public long[] shape() {
            long[] shape = Attribute.shape.access(long[].class, onnxAttributes);
            return shape.clone();
        }

        public java.util.Optional<Float> seed() {
            Float seed = Attribute.seed.access(Float.class, onnxAttributes);
            return java.util.Optional.ofNullable(seed);
        }

        public java.util.Optional<Float> low() {
            Float low = Attribute.low.access(Float.class, onnxAttributes);
            return java.util.Optional.ofNullable(low);
        }

        public java.util.Optional<Long> dtype() {
            Long dtype = Attribute.dtype.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(dtype);
        }

    }

    public static RandomUniform RandomUniform(TypeElement resultType, java.util.Optional<Float> high, long[] shape, java.util.Optional<Float> seed, java.util.Optional<Float> low, java.util.Optional<Long> dtype) {
        return new RandomUniform(resultType, high, shape, seed, low, dtype);
    }

    @OpFactoryHelper.OpDeclaration(RandomUniformLike.NAME)
    public static final class RandomUniformLike extends OnnxOp {
        public static final String NAME = "RandomUniformLike";

        public enum Attribute implements OnnxAttribute {
            high(Float.class, true, 1.0f),
            seed(Float.class, true, null),
            low(Float.class, true, 0.0f),
            dtype(Long.class, true, null),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T1(new OnnxType.TypeVariable("T1", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128())))),
            T2(new OnnxType.TypeVariable("T2", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            input(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public RandomUniformLike(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        RandomUniformLike(RandomUniformLike that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public RandomUniformLike transform(CopyContext cc, OpTransformer ot) {
            return new RandomUniformLike(this, cc);
        }

        RandomUniformLike(TypeElement resultType, Value input, java.util.Optional<Float> high, java.util.Optional<Float> seed, java.util.Optional<Float> low, java.util.Optional<Long> dtype) {
            super(SCHEMA, resultType, Set.of(), List.of(input), List.of(high, seed, low, dtype));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(input()));
        }

        public Value input() {
            return operands().get(0);
        }

        public java.util.Optional<Float> high() {
            Float high = Attribute.high.access(Float.class, onnxAttributes);
            return java.util.Optional.ofNullable(high);
        }

        public java.util.Optional<Float> seed() {
            Float seed = Attribute.seed.access(Float.class, onnxAttributes);
            return java.util.Optional.ofNullable(seed);
        }

        public java.util.Optional<Float> low() {
            Float low = Attribute.low.access(Float.class, onnxAttributes);
            return java.util.Optional.ofNullable(low);
        }

        public java.util.Optional<Long> dtype() {
            Long dtype = Attribute.dtype.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(dtype);
        }

    }

    public static RandomUniformLike RandomUniformLike(TypeElement resultType, Value input, java.util.Optional<Float> high, java.util.Optional<Float> seed, java.util.Optional<Float> low, java.util.Optional<Long> dtype) {
        return new RandomUniformLike(resultType, input, high, seed, low, dtype);
    }

    @OpFactoryHelper.OpDeclaration(Range.NAME)
    public static final class Range extends OnnxOp {
        public static final String NAME = "Range";

        public enum Attribute implements OnnxAttribute.None { }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            start(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            limit(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            delta(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public Range(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        Range(Range that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public Range transform(CopyContext cc, OpTransformer ot) {
            return new Range(this, cc);
        }

        Range(TypeElement resultType, Value start, Value limit, Value delta) {
            super(SCHEMA, resultType, Set.of(), List.of(start, limit, delta), List.of());
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(start(), limit(), delta()));
        }

        public Value start() {
            return operands().get(0);
        }

        public Value limit() {
            return operands().get(1);
        }

        public Value delta() {
            return operands().get(2);
        }

    }

    public static Range Range(TypeElement resultType, Value start, Value limit, Value delta) {
        return new Range(resultType, start, limit, delta);
    }

    @OpFactoryHelper.OpDeclaration(Reciprocal.NAME)
    public static final class Reciprocal extends OnnxOp {
        public static final String NAME = "Reciprocal";

        public enum Attribute implements OnnxAttribute.None { }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public Reciprocal(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        Reciprocal(Reciprocal that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public Reciprocal transform(CopyContext cc, OpTransformer ot) {
            return new Reciprocal(this, cc);
        }

        Reciprocal(TypeElement resultType, Value X) {
            super(SCHEMA, resultType, Set.of(), List.of(X), List.of());
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X()));
        }

        public Value X() {
            return operands().get(0);
        }

    }

    public static Reciprocal Reciprocal(TypeElement resultType, Value X) {
        return new Reciprocal(resultType, X);
    }

    @OpFactoryHelper.OpDeclaration(ReduceL1.NAME)
    public static final class ReduceL1 extends OnnxOp {
        public static final String NAME = "ReduceL1";

        public enum Attribute implements OnnxAttribute {
            noop_with_empty_axes(Long.class, true, 0),
            keepdims(Long.class, true, 1),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            data(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            axes(OnnxType.tensor(OnnxType.int64()), Quantifier.OPTIONAL),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            reduced(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public ReduceL1(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        ReduceL1(ReduceL1 that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public ReduceL1 transform(CopyContext cc, OpTransformer ot) {
            return new ReduceL1(this, cc);
        }

        ReduceL1(TypeElement resultType, Value data, java.util.Optional<Value> axes, java.util.Optional<Long> noop_with_empty_axes, java.util.Optional<Long> keepdims) {
            super(SCHEMA, resultType, Set.of(), List.of(data, axes), List.of(noop_with_empty_axes, keepdims));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(data(), axes()));
        }

        public Value data() {
            return operands().get(0);
        }

        public java.util.Optional<Value> axes() {
            int i = optionalInputArguments.indexOf(InputParameter.axes);
            return i != -1 ? java.util.Optional.of(operands().get(1 + i)) : java.util.Optional.empty();
        }

        public java.util.Optional<Long> noop_with_empty_axes() {
            Long noop_with_empty_axes = Attribute.noop_with_empty_axes.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(noop_with_empty_axes);
        }

        public java.util.Optional<Long> keepdims() {
            Long keepdims = Attribute.keepdims.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(keepdims);
        }

    }

    public static ReduceL1 ReduceL1(TypeElement resultType, Value data, java.util.Optional<Value> axes, java.util.Optional<Long> noop_with_empty_axes, java.util.Optional<Long> keepdims) {
        return new ReduceL1(resultType, data, axes, noop_with_empty_axes, keepdims);
    }

    @OpFactoryHelper.OpDeclaration(ReduceL2.NAME)
    public static final class ReduceL2 extends OnnxOp {
        public static final String NAME = "ReduceL2";

        public enum Attribute implements OnnxAttribute {
            noop_with_empty_axes(Long.class, true, 0),
            keepdims(Long.class, true, 1),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            data(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            axes(OnnxType.tensor(OnnxType.int64()), Quantifier.OPTIONAL),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            reduced(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public ReduceL2(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        ReduceL2(ReduceL2 that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public ReduceL2 transform(CopyContext cc, OpTransformer ot) {
            return new ReduceL2(this, cc);
        }

        ReduceL2(TypeElement resultType, Value data, java.util.Optional<Value> axes, java.util.Optional<Long> noop_with_empty_axes, java.util.Optional<Long> keepdims) {
            super(SCHEMA, resultType, Set.of(), List.of(data, axes), List.of(noop_with_empty_axes, keepdims));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(data(), axes()));
        }

        public Value data() {
            return operands().get(0);
        }

        public java.util.Optional<Value> axes() {
            int i = optionalInputArguments.indexOf(InputParameter.axes);
            return i != -1 ? java.util.Optional.of(operands().get(1 + i)) : java.util.Optional.empty();
        }

        public java.util.Optional<Long> noop_with_empty_axes() {
            Long noop_with_empty_axes = Attribute.noop_with_empty_axes.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(noop_with_empty_axes);
        }

        public java.util.Optional<Long> keepdims() {
            Long keepdims = Attribute.keepdims.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(keepdims);
        }

    }

    public static ReduceL2 ReduceL2(TypeElement resultType, Value data, java.util.Optional<Value> axes, java.util.Optional<Long> noop_with_empty_axes, java.util.Optional<Long> keepdims) {
        return new ReduceL2(resultType, data, axes, noop_with_empty_axes, keepdims);
    }

    @OpFactoryHelper.OpDeclaration(ReduceLogSum.NAME)
    public static final class ReduceLogSum extends OnnxOp {
        public static final String NAME = "ReduceLogSum";

        public enum Attribute implements OnnxAttribute {
            noop_with_empty_axes(Long.class, true, 0),
            keepdims(Long.class, true, 1),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            data(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            axes(OnnxType.tensor(OnnxType.int64()), Quantifier.OPTIONAL),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            reduced(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public ReduceLogSum(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        ReduceLogSum(ReduceLogSum that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public ReduceLogSum transform(CopyContext cc, OpTransformer ot) {
            return new ReduceLogSum(this, cc);
        }

        ReduceLogSum(TypeElement resultType, Value data, java.util.Optional<Value> axes, java.util.Optional<Long> noop_with_empty_axes, java.util.Optional<Long> keepdims) {
            super(SCHEMA, resultType, Set.of(), List.of(data, axes), List.of(noop_with_empty_axes, keepdims));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(data(), axes()));
        }

        public Value data() {
            return operands().get(0);
        }

        public java.util.Optional<Value> axes() {
            int i = optionalInputArguments.indexOf(InputParameter.axes);
            return i != -1 ? java.util.Optional.of(operands().get(1 + i)) : java.util.Optional.empty();
        }

        public java.util.Optional<Long> noop_with_empty_axes() {
            Long noop_with_empty_axes = Attribute.noop_with_empty_axes.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(noop_with_empty_axes);
        }

        public java.util.Optional<Long> keepdims() {
            Long keepdims = Attribute.keepdims.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(keepdims);
        }

    }

    public static ReduceLogSum ReduceLogSum(TypeElement resultType, Value data, java.util.Optional<Value> axes, java.util.Optional<Long> noop_with_empty_axes, java.util.Optional<Long> keepdims) {
        return new ReduceLogSum(resultType, data, axes, noop_with_empty_axes, keepdims);
    }

    @OpFactoryHelper.OpDeclaration(ReduceLogSumExp.NAME)
    public static final class ReduceLogSumExp extends OnnxOp {
        public static final String NAME = "ReduceLogSumExp";

        public enum Attribute implements OnnxAttribute {
            noop_with_empty_axes(Long.class, true, 0),
            keepdims(Long.class, true, 1),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            data(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            axes(OnnxType.tensor(OnnxType.int64()), Quantifier.OPTIONAL),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            reduced(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public ReduceLogSumExp(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        ReduceLogSumExp(ReduceLogSumExp that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public ReduceLogSumExp transform(CopyContext cc, OpTransformer ot) {
            return new ReduceLogSumExp(this, cc);
        }

        ReduceLogSumExp(TypeElement resultType, Value data, java.util.Optional<Value> axes, java.util.Optional<Long> noop_with_empty_axes, java.util.Optional<Long> keepdims) {
            super(SCHEMA, resultType, Set.of(), List.of(data, axes), List.of(noop_with_empty_axes, keepdims));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(data(), axes()));
        }

        public Value data() {
            return operands().get(0);
        }

        public java.util.Optional<Value> axes() {
            int i = optionalInputArguments.indexOf(InputParameter.axes);
            return i != -1 ? java.util.Optional.of(operands().get(1 + i)) : java.util.Optional.empty();
        }

        public java.util.Optional<Long> noop_with_empty_axes() {
            Long noop_with_empty_axes = Attribute.noop_with_empty_axes.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(noop_with_empty_axes);
        }

        public java.util.Optional<Long> keepdims() {
            Long keepdims = Attribute.keepdims.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(keepdims);
        }

    }

    public static ReduceLogSumExp ReduceLogSumExp(TypeElement resultType, Value data, java.util.Optional<Value> axes, java.util.Optional<Long> noop_with_empty_axes, java.util.Optional<Long> keepdims) {
        return new ReduceLogSumExp(resultType, data, axes, noop_with_empty_axes, keepdims);
    }

    @OpFactoryHelper.OpDeclaration(ReduceMax.NAME)
    public static final class ReduceMax extends OnnxOp {
        public static final String NAME = "ReduceMax";

        public enum Attribute implements OnnxAttribute {
            noop_with_empty_axes(Long.class, true, 0),
            keepdims(Long.class, true, 1),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.bool())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            data(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            axes(OnnxType.tensor(OnnxType.int64()), Quantifier.OPTIONAL),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            reduced(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public ReduceMax(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        ReduceMax(ReduceMax that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public ReduceMax transform(CopyContext cc, OpTransformer ot) {
            return new ReduceMax(this, cc);
        }

        ReduceMax(TypeElement resultType, Value data, java.util.Optional<Value> axes, java.util.Optional<Long> noop_with_empty_axes, java.util.Optional<Long> keepdims) {
            super(SCHEMA, resultType, Set.of(), List.of(data, axes), List.of(noop_with_empty_axes, keepdims));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(data(), axes()));
        }

        public Value data() {
            return operands().get(0);
        }

        public java.util.Optional<Value> axes() {
            int i = optionalInputArguments.indexOf(InputParameter.axes);
            return i != -1 ? java.util.Optional.of(operands().get(1 + i)) : java.util.Optional.empty();
        }

        public java.util.Optional<Long> noop_with_empty_axes() {
            Long noop_with_empty_axes = Attribute.noop_with_empty_axes.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(noop_with_empty_axes);
        }

        public java.util.Optional<Long> keepdims() {
            Long keepdims = Attribute.keepdims.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(keepdims);
        }

    }

    public static ReduceMax ReduceMax(TypeElement resultType, Value data, java.util.Optional<Value> axes, java.util.Optional<Long> noop_with_empty_axes, java.util.Optional<Long> keepdims) {
        return new ReduceMax(resultType, data, axes, noop_with_empty_axes, keepdims);
    }

    @OpFactoryHelper.OpDeclaration(ReduceMean.NAME)
    public static final class ReduceMean extends OnnxOp {
        public static final String NAME = "ReduceMean";

        public enum Attribute implements OnnxAttribute {
            noop_with_empty_axes(Long.class, true, 0),
            keepdims(Long.class, true, 1),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            data(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            axes(OnnxType.tensor(OnnxType.int64()), Quantifier.OPTIONAL),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            reduced(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public ReduceMean(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        ReduceMean(ReduceMean that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public ReduceMean transform(CopyContext cc, OpTransformer ot) {
            return new ReduceMean(this, cc);
        }

        ReduceMean(TypeElement resultType, Value data, java.util.Optional<Value> axes, java.util.Optional<Long> noop_with_empty_axes, java.util.Optional<Long> keepdims) {
            super(SCHEMA, resultType, Set.of(), List.of(data, axes), List.of(noop_with_empty_axes, keepdims));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(data(), axes()));
        }

        public Value data() {
            return operands().get(0);
        }

        public java.util.Optional<Value> axes() {
            int i = optionalInputArguments.indexOf(InputParameter.axes);
            return i != -1 ? java.util.Optional.of(operands().get(1 + i)) : java.util.Optional.empty();
        }

        public java.util.Optional<Long> noop_with_empty_axes() {
            Long noop_with_empty_axes = Attribute.noop_with_empty_axes.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(noop_with_empty_axes);
        }

        public java.util.Optional<Long> keepdims() {
            Long keepdims = Attribute.keepdims.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(keepdims);
        }

    }

    public static ReduceMean ReduceMean(TypeElement resultType, Value data, java.util.Optional<Value> axes, java.util.Optional<Long> noop_with_empty_axes, java.util.Optional<Long> keepdims) {
        return new ReduceMean(resultType, data, axes, noop_with_empty_axes, keepdims);
    }

    @OpFactoryHelper.OpDeclaration(ReduceMin.NAME)
    public static final class ReduceMin extends OnnxOp {
        public static final String NAME = "ReduceMin";

        public enum Attribute implements OnnxAttribute {
            noop_with_empty_axes(Long.class, true, 0),
            keepdims(Long.class, true, 1),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.bool())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            data(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            axes(OnnxType.tensor(OnnxType.int64()), Quantifier.OPTIONAL),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            reduced(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public ReduceMin(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        ReduceMin(ReduceMin that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public ReduceMin transform(CopyContext cc, OpTransformer ot) {
            return new ReduceMin(this, cc);
        }

        ReduceMin(TypeElement resultType, Value data, java.util.Optional<Value> axes, java.util.Optional<Long> noop_with_empty_axes, java.util.Optional<Long> keepdims) {
            super(SCHEMA, resultType, Set.of(), List.of(data, axes), List.of(noop_with_empty_axes, keepdims));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(data(), axes()));
        }

        public Value data() {
            return operands().get(0);
        }

        public java.util.Optional<Value> axes() {
            int i = optionalInputArguments.indexOf(InputParameter.axes);
            return i != -1 ? java.util.Optional.of(operands().get(1 + i)) : java.util.Optional.empty();
        }

        public java.util.Optional<Long> noop_with_empty_axes() {
            Long noop_with_empty_axes = Attribute.noop_with_empty_axes.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(noop_with_empty_axes);
        }

        public java.util.Optional<Long> keepdims() {
            Long keepdims = Attribute.keepdims.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(keepdims);
        }

    }

    public static ReduceMin ReduceMin(TypeElement resultType, Value data, java.util.Optional<Value> axes, java.util.Optional<Long> noop_with_empty_axes, java.util.Optional<Long> keepdims) {
        return new ReduceMin(resultType, data, axes, noop_with_empty_axes, keepdims);
    }

    @OpFactoryHelper.OpDeclaration(ReduceProd.NAME)
    public static final class ReduceProd extends OnnxOp {
        public static final String NAME = "ReduceProd";

        public enum Attribute implements OnnxAttribute {
            noop_with_empty_axes(Long.class, true, 0),
            keepdims(Long.class, true, 1),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            data(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            axes(OnnxType.tensor(OnnxType.int64()), Quantifier.OPTIONAL),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            reduced(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public ReduceProd(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        ReduceProd(ReduceProd that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public ReduceProd transform(CopyContext cc, OpTransformer ot) {
            return new ReduceProd(this, cc);
        }

        ReduceProd(TypeElement resultType, Value data, java.util.Optional<Value> axes, java.util.Optional<Long> noop_with_empty_axes, java.util.Optional<Long> keepdims) {
            super(SCHEMA, resultType, Set.of(), List.of(data, axes), List.of(noop_with_empty_axes, keepdims));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(data(), axes()));
        }

        public Value data() {
            return operands().get(0);
        }

        public java.util.Optional<Value> axes() {
            int i = optionalInputArguments.indexOf(InputParameter.axes);
            return i != -1 ? java.util.Optional.of(operands().get(1 + i)) : java.util.Optional.empty();
        }

        public java.util.Optional<Long> noop_with_empty_axes() {
            Long noop_with_empty_axes = Attribute.noop_with_empty_axes.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(noop_with_empty_axes);
        }

        public java.util.Optional<Long> keepdims() {
            Long keepdims = Attribute.keepdims.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(keepdims);
        }

    }

    public static ReduceProd ReduceProd(TypeElement resultType, Value data, java.util.Optional<Value> axes, java.util.Optional<Long> noop_with_empty_axes, java.util.Optional<Long> keepdims) {
        return new ReduceProd(resultType, data, axes, noop_with_empty_axes, keepdims);
    }

    @OpFactoryHelper.OpDeclaration(ReduceSum.NAME)
    public static final class ReduceSum extends OnnxOp {
        public static final String NAME = "ReduceSum";

        public enum Attribute implements OnnxAttribute {
            noop_with_empty_axes(Long.class, true, 0),
            keepdims(Long.class, true, 1),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            data(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            axes(OnnxType.tensor(OnnxType.int64()), Quantifier.OPTIONAL),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            reduced(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public ReduceSum(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        ReduceSum(ReduceSum that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public ReduceSum transform(CopyContext cc, OpTransformer ot) {
            return new ReduceSum(this, cc);
        }

        ReduceSum(TypeElement resultType, Value data, java.util.Optional<Value> axes, java.util.Optional<Long> noop_with_empty_axes, java.util.Optional<Long> keepdims) {
            super(SCHEMA, resultType, Set.of(), List.of(data, axes), List.of(noop_with_empty_axes, keepdims));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(data(), axes()));
        }

        public Value data() {
            return operands().get(0);
        }

        public java.util.Optional<Value> axes() {
            int i = optionalInputArguments.indexOf(InputParameter.axes);
            return i != -1 ? java.util.Optional.of(operands().get(1 + i)) : java.util.Optional.empty();
        }

        public java.util.Optional<Long> noop_with_empty_axes() {
            Long noop_with_empty_axes = Attribute.noop_with_empty_axes.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(noop_with_empty_axes);
        }

        public java.util.Optional<Long> keepdims() {
            Long keepdims = Attribute.keepdims.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(keepdims);
        }

    }

    public static ReduceSum ReduceSum(TypeElement resultType, Value data, java.util.Optional<Value> axes, java.util.Optional<Long> noop_with_empty_axes, java.util.Optional<Long> keepdims) {
        return new ReduceSum(resultType, data, axes, noop_with_empty_axes, keepdims);
    }

    @OpFactoryHelper.OpDeclaration(ReduceSumSquare.NAME)
    public static final class ReduceSumSquare extends OnnxOp {
        public static final String NAME = "ReduceSumSquare";

        public enum Attribute implements OnnxAttribute {
            noop_with_empty_axes(Long.class, true, 0),
            keepdims(Long.class, true, 1),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            data(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            axes(OnnxType.tensor(OnnxType.int64()), Quantifier.OPTIONAL),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            reduced(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public ReduceSumSquare(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        ReduceSumSquare(ReduceSumSquare that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public ReduceSumSquare transform(CopyContext cc, OpTransformer ot) {
            return new ReduceSumSquare(this, cc);
        }

        ReduceSumSquare(TypeElement resultType, Value data, java.util.Optional<Value> axes, java.util.Optional<Long> noop_with_empty_axes, java.util.Optional<Long> keepdims) {
            super(SCHEMA, resultType, Set.of(), List.of(data, axes), List.of(noop_with_empty_axes, keepdims));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(data(), axes()));
        }

        public Value data() {
            return operands().get(0);
        }

        public java.util.Optional<Value> axes() {
            int i = optionalInputArguments.indexOf(InputParameter.axes);
            return i != -1 ? java.util.Optional.of(operands().get(1 + i)) : java.util.Optional.empty();
        }

        public java.util.Optional<Long> noop_with_empty_axes() {
            Long noop_with_empty_axes = Attribute.noop_with_empty_axes.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(noop_with_empty_axes);
        }

        public java.util.Optional<Long> keepdims() {
            Long keepdims = Attribute.keepdims.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(keepdims);
        }

    }

    public static ReduceSumSquare ReduceSumSquare(TypeElement resultType, Value data, java.util.Optional<Value> axes, java.util.Optional<Long> noop_with_empty_axes, java.util.Optional<Long> keepdims) {
        return new ReduceSumSquare(resultType, data, axes, noop_with_empty_axes, keepdims);
    }

    @OpFactoryHelper.OpDeclaration(RegexFullMatch.NAME)
    public static final class RegexFullMatch extends OnnxOp {
        public static final String NAME = "RegexFullMatch";

        public enum Attribute implements OnnxAttribute {
            pattern(String.class, true, null),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T1(new OnnxType.TypeVariable("T1", List.of(OnnxType.tensor(OnnxType.string())))),
            T2(new OnnxType.TypeVariable("T2", List.of(OnnxType.tensor(OnnxType.bool())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public RegexFullMatch(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        RegexFullMatch(RegexFullMatch that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public RegexFullMatch transform(CopyContext cc, OpTransformer ot) {
            return new RegexFullMatch(this, cc);
        }

        RegexFullMatch(TypeElement resultType, Value X, java.util.Optional<String> pattern) {
            super(SCHEMA, resultType, Set.of(), List.of(X), List.of(pattern));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X()));
        }

        public Value X() {
            return operands().get(0);
        }

        public java.util.Optional<String> pattern() {
            String pattern = Attribute.pattern.access(String.class, onnxAttributes);
            return java.util.Optional.ofNullable(pattern);
        }

    }

    public static RegexFullMatch RegexFullMatch(TypeElement resultType, Value X, java.util.Optional<String> pattern) {
        return new RegexFullMatch(resultType, X, pattern);
    }

    @OpFactoryHelper.OpDeclaration(Relu.NAME)
    public static final class Relu extends OnnxOp {
        public static final String NAME = "Relu";

        public enum Attribute implements OnnxAttribute.None { }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public Relu(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        Relu(Relu that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public Relu transform(CopyContext cc, OpTransformer ot) {
            return new Relu(this, cc);
        }

        Relu(TypeElement resultType, Value X) {
            super(SCHEMA, resultType, Set.of(), List.of(X), List.of());
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X()));
        }

        public Value X() {
            return operands().get(0);
        }

    }

    public static Relu Relu(TypeElement resultType, Value X) {
        return new Relu(resultType, X);
    }

    @OpFactoryHelper.OpDeclaration(Reshape.NAME)
    public static final class Reshape extends OnnxOp {
        public static final String NAME = "Reshape";

        public enum Attribute implements OnnxAttribute {
            allowzero(Long.class, true, 0),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128()), OnnxType.tensor(OnnxType.float8e4m3fn()), OnnxType.tensor(OnnxType.float8e4m3fnuz()), OnnxType.tensor(OnnxType.float8e5m2()), OnnxType.tensor(OnnxType.float8e5m2fnuz()), OnnxType.tensor(OnnxType.uint4()), OnnxType.tensor(OnnxType.int4()), OnnxType.tensor(OnnxType.float4e2m1())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            data(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            shape(OnnxType.tensor(OnnxType.int64()), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            reshaped(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public Reshape(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        Reshape(Reshape that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public Reshape transform(CopyContext cc, OpTransformer ot) {
            return new Reshape(this, cc);
        }

        Reshape(TypeElement resultType, Value data, Value shape, java.util.Optional<Long> allowzero) {
            super(SCHEMA, resultType, Set.of(), List.of(data, shape), List.of(allowzero));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(data(), shape()));
        }

        public Value data() {
            return operands().get(0);
        }

        public Value shape() {
            return operands().get(1);
        }

        public java.util.Optional<Long> allowzero() {
            Long allowzero = Attribute.allowzero.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(allowzero);
        }

    }

    public static Reshape Reshape(TypeElement resultType, Value data, Value shape, java.util.Optional<Long> allowzero) {
        return new Reshape(resultType, data, shape, allowzero);
    }

    @OpFactoryHelper.OpDeclaration(Resize.NAME)
    public static final class Resize extends OnnxOp {
        public static final String NAME = "Resize";

        public enum Attribute implements OnnxAttribute {
            mode(String.class, true, "nearest"),
            extrapolation_value(Float.class, true, 0.0f),
            nearest_mode(String.class, true, "round_prefer_floor"),
            antialias(Long.class, true, 0),
            cubic_coeff_a(Float.class, true, -0.75f),
            axes(long[].class, true, null),
            coordinate_transformation_mode(String.class, true, "half_pixel"),
            keep_aspect_ratio_policy(String.class, true, "stretch"),
            exclude_outside(Long.class, true, 0),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T1(new OnnxType.TypeVariable("T1", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128())))),
            T2(new OnnxType.TypeVariable("T2", List.of(OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            roi(TypeConstraint.T2.typeVariable(), Quantifier.OPTIONAL),
            scales(OnnxType.tensor(OnnxType.float32()), Quantifier.OPTIONAL),
            sizes(OnnxType.tensor(OnnxType.int64()), Quantifier.OPTIONAL),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public Resize(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        Resize(Resize that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public Resize transform(CopyContext cc, OpTransformer ot) {
            return new Resize(this, cc);
        }

        Resize(TypeElement resultType, Value X, java.util.Optional<Value> roi, java.util.Optional<Value> scales, java.util.Optional<Value> sizes, java.util.Optional<String> mode, java.util.Optional<Float> extrapolation_value, java.util.Optional<String> nearest_mode, java.util.Optional<Long> antialias, java.util.Optional<Float> cubic_coeff_a, java.util.Optional<long[]> axes, java.util.Optional<String> coordinate_transformation_mode, java.util.Optional<String> keep_aspect_ratio_policy, java.util.Optional<Long> exclude_outside) {
            super(SCHEMA, resultType, Set.of(), List.of(X, roi, scales, sizes), List.of(mode, extrapolation_value, nearest_mode, antialias, cubic_coeff_a, axes, coordinate_transformation_mode, keep_aspect_ratio_policy, exclude_outside));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X(), roi(), scales(), sizes()));
        }

        public Value X() {
            return operands().get(0);
        }

        public java.util.Optional<Value> roi() {
            int i = optionalInputArguments.indexOf(InputParameter.roi);
            return i != -1 ? java.util.Optional.of(operands().get(1 + i)) : java.util.Optional.empty();
        }

        public java.util.Optional<Value> scales() {
            int i = optionalInputArguments.indexOf(InputParameter.scales);
            return i != -1 ? java.util.Optional.of(operands().get(1 + i)) : java.util.Optional.empty();
        }

        public java.util.Optional<Value> sizes() {
            int i = optionalInputArguments.indexOf(InputParameter.sizes);
            return i != -1 ? java.util.Optional.of(operands().get(1 + i)) : java.util.Optional.empty();
        }

        public java.util.Optional<String> mode() {
            String mode = Attribute.mode.access(String.class, onnxAttributes);
            return java.util.Optional.ofNullable(mode);
        }

        public java.util.Optional<Float> extrapolation_value() {
            Float extrapolation_value = Attribute.extrapolation_value.access(Float.class, onnxAttributes);
            return java.util.Optional.ofNullable(extrapolation_value);
        }

        public java.util.Optional<String> nearest_mode() {
            String nearest_mode = Attribute.nearest_mode.access(String.class, onnxAttributes);
            return java.util.Optional.ofNullable(nearest_mode);
        }

        public java.util.Optional<Long> antialias() {
            Long antialias = Attribute.antialias.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(antialias);
        }

        public java.util.Optional<Float> cubic_coeff_a() {
            Float cubic_coeff_a = Attribute.cubic_coeff_a.access(Float.class, onnxAttributes);
            return java.util.Optional.ofNullable(cubic_coeff_a);
        }

        public java.util.Optional<long[]> axes() {
            long[] axes = Attribute.axes.access(long[].class, onnxAttributes);
            return java.util.Optional.ofNullable(axes).map(long[]::clone);
        }

        public java.util.Optional<String> coordinate_transformation_mode() {
            String coordinate_transformation_mode = Attribute.coordinate_transformation_mode.access(String.class, onnxAttributes);
            return java.util.Optional.ofNullable(coordinate_transformation_mode);
        }

        public java.util.Optional<String> keep_aspect_ratio_policy() {
            String keep_aspect_ratio_policy = Attribute.keep_aspect_ratio_policy.access(String.class, onnxAttributes);
            return java.util.Optional.ofNullable(keep_aspect_ratio_policy);
        }

        public java.util.Optional<Long> exclude_outside() {
            Long exclude_outside = Attribute.exclude_outside.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(exclude_outside);
        }

    }

    public static Resize Resize(TypeElement resultType, Value X, java.util.Optional<Value> roi, java.util.Optional<Value> scales, java.util.Optional<Value> sizes, java.util.Optional<String> mode, java.util.Optional<Float> extrapolation_value, java.util.Optional<String> nearest_mode, java.util.Optional<Long> antialias, java.util.Optional<Float> cubic_coeff_a, java.util.Optional<long[]> axes, java.util.Optional<String> coordinate_transformation_mode, java.util.Optional<String> keep_aspect_ratio_policy, java.util.Optional<Long> exclude_outside) {
        return new Resize(resultType, X, roi, scales, sizes, mode, extrapolation_value, nearest_mode, antialias, cubic_coeff_a, axes, coordinate_transformation_mode, keep_aspect_ratio_policy, exclude_outside);
    }

    @OpFactoryHelper.OpDeclaration(ReverseSequence.NAME)
    public static final class ReverseSequence extends OnnxOp {
        public static final String NAME = "ReverseSequence";

        public enum Attribute implements OnnxAttribute {
            time_axis(Long.class, true, 0),
            batch_axis(Long.class, true, 1),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            input(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            sequence_lens(OnnxType.tensor(OnnxType.int64()), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public ReverseSequence(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        ReverseSequence(ReverseSequence that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public ReverseSequence transform(CopyContext cc, OpTransformer ot) {
            return new ReverseSequence(this, cc);
        }

        ReverseSequence(TypeElement resultType, Value input, Value sequence_lens, java.util.Optional<Long> time_axis, java.util.Optional<Long> batch_axis) {
            super(SCHEMA, resultType, Set.of(), List.of(input, sequence_lens), List.of(time_axis, batch_axis));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(input(), sequence_lens()));
        }

        public Value input() {
            return operands().get(0);
        }

        public Value sequence_lens() {
            return operands().get(1);
        }

        public java.util.Optional<Long> time_axis() {
            Long time_axis = Attribute.time_axis.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(time_axis);
        }

        public java.util.Optional<Long> batch_axis() {
            Long batch_axis = Attribute.batch_axis.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(batch_axis);
        }

    }

    public static ReverseSequence ReverseSequence(TypeElement resultType, Value input, Value sequence_lens, java.util.Optional<Long> time_axis, java.util.Optional<Long> batch_axis) {
        return new ReverseSequence(resultType, input, sequence_lens, time_axis, batch_axis);
    }

    @OpFactoryHelper.OpDeclaration(RoiAlign.NAME)
    public static final class RoiAlign extends OnnxOp {
        public static final String NAME = "RoiAlign";

        public enum Attribute implements OnnxAttribute {
            mode(String.class, true, "avg"),
            output_width(Long.class, true, 1),
            spatial_scale(Float.class, true, 1.0f),
            coordinate_transformation_mode(String.class, true, "half_pixel"),
            sampling_ratio(Long.class, true, 0),
            output_height(Long.class, true, 1),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T1(new OnnxType.TypeVariable("T1", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),
            T2(new OnnxType.TypeVariable("T2", List.of(OnnxType.tensor(OnnxType.int64())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            rois(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            batch_indices(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public RoiAlign(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        RoiAlign(RoiAlign that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public RoiAlign transform(CopyContext cc, OpTransformer ot) {
            return new RoiAlign(this, cc);
        }

        RoiAlign(TypeElement resultType, Value X, Value rois, Value batch_indices, java.util.Optional<String> mode, java.util.Optional<Long> output_width, java.util.Optional<Float> spatial_scale, java.util.Optional<String> coordinate_transformation_mode, java.util.Optional<Long> sampling_ratio, java.util.Optional<Long> output_height) {
            super(SCHEMA, resultType, Set.of(), List.of(X, rois, batch_indices), List.of(mode, output_width, spatial_scale, coordinate_transformation_mode, sampling_ratio, output_height));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X(), rois(), batch_indices()));
        }

        public Value X() {
            return operands().get(0);
        }

        public Value rois() {
            return operands().get(1);
        }

        public Value batch_indices() {
            return operands().get(2);
        }

        public java.util.Optional<String> mode() {
            String mode = Attribute.mode.access(String.class, onnxAttributes);
            return java.util.Optional.ofNullable(mode);
        }

        public java.util.Optional<Long> output_width() {
            Long output_width = Attribute.output_width.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(output_width);
        }

        public java.util.Optional<Float> spatial_scale() {
            Float spatial_scale = Attribute.spatial_scale.access(Float.class, onnxAttributes);
            return java.util.Optional.ofNullable(spatial_scale);
        }

        public java.util.Optional<String> coordinate_transformation_mode() {
            String coordinate_transformation_mode = Attribute.coordinate_transformation_mode.access(String.class, onnxAttributes);
            return java.util.Optional.ofNullable(coordinate_transformation_mode);
        }

        public java.util.Optional<Long> sampling_ratio() {
            Long sampling_ratio = Attribute.sampling_ratio.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(sampling_ratio);
        }

        public java.util.Optional<Long> output_height() {
            Long output_height = Attribute.output_height.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(output_height);
        }

    }

    public static RoiAlign RoiAlign(TypeElement resultType, Value X, Value rois, Value batch_indices, java.util.Optional<String> mode, java.util.Optional<Long> output_width, java.util.Optional<Float> spatial_scale, java.util.Optional<String> coordinate_transformation_mode, java.util.Optional<Long> sampling_ratio, java.util.Optional<Long> output_height) {
        return new RoiAlign(resultType, X, rois, batch_indices, mode, output_width, spatial_scale, coordinate_transformation_mode, sampling_ratio, output_height);
    }

    @OpFactoryHelper.OpDeclaration(Round.NAME)
    public static final class Round extends OnnxOp {
        public static final String NAME = "Round";

        public enum Attribute implements OnnxAttribute.None { }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public Round(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        Round(Round that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public Round transform(CopyContext cc, OpTransformer ot) {
            return new Round(this, cc);
        }

        Round(TypeElement resultType, Value X) {
            super(SCHEMA, resultType, Set.of(), List.of(X), List.of());
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X()));
        }

        public Value X() {
            return operands().get(0);
        }

    }

    public static Round Round(TypeElement resultType, Value X) {
        return new Round(resultType, X);
    }

    @OpFactoryHelper.OpDeclaration(STFT.NAME)
    public static final class STFT extends OnnxOp {
        public static final String NAME = "STFT";

        public enum Attribute implements OnnxAttribute {
            onesided(Long.class, true, 1),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T1(new OnnxType.TypeVariable("T1", List.of(OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),
            T2(new OnnxType.TypeVariable("T2", List.of(OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            signal(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            frame_step(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),
            window(TypeConstraint.T1.typeVariable(), Quantifier.OPTIONAL),
            frame_length(TypeConstraint.T2.typeVariable(), Quantifier.OPTIONAL),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public STFT(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        STFT(STFT that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public STFT transform(CopyContext cc, OpTransformer ot) {
            return new STFT(this, cc);
        }

        STFT(TypeElement resultType, Value signal, Value frame_step, java.util.Optional<Value> window, java.util.Optional<Value> frame_length, java.util.Optional<Long> onesided) {
            super(SCHEMA, resultType, Set.of(), List.of(signal, frame_step, window, frame_length), List.of(onesided));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(signal(), frame_step(), window(), frame_length()));
        }

        public Value signal() {
            return operands().get(0);
        }

        public Value frame_step() {
            return operands().get(1);
        }

        public java.util.Optional<Value> window() {
            int i = optionalInputArguments.indexOf(InputParameter.window);
            return i != -1 ? java.util.Optional.of(operands().get(2 + i)) : java.util.Optional.empty();
        }

        public java.util.Optional<Value> frame_length() {
            int i = optionalInputArguments.indexOf(InputParameter.frame_length);
            return i != -1 ? java.util.Optional.of(operands().get(2 + i)) : java.util.Optional.empty();
        }

        public java.util.Optional<Long> onesided() {
            Long onesided = Attribute.onesided.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(onesided);
        }

    }

    public static STFT STFT(TypeElement resultType, Value signal, Value frame_step, java.util.Optional<Value> window, java.util.Optional<Value> frame_length, java.util.Optional<Long> onesided) {
        return new STFT(resultType, signal, frame_step, window, frame_length, onesided);
    }

    @OpFactoryHelper.OpDeclaration(SVMClassifier.NAME)
    public static final class SVMClassifier extends OnnxOp {
        public static final String NAME = "SVMClassifier";

        public enum Attribute implements OnnxAttribute {
            prob_b(float[].class, true, null),
            kernel_params(float[].class, true, null),
            kernel_type(String.class, true, "LINEAR"),
            classlabels_ints(long[].class, true, null),
            post_transform(String.class, true, "NONE"),
            rho(float[].class, true, null),
            coefficients(float[].class, true, null),
            support_vectors(float[].class, true, null),
            vectors_per_class(long[].class, true, null),
            prob_a(float[].class, true, null),
            classlabels_strings(String[].class, true, null),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T1(new OnnxType.TypeVariable("T1", List.of(OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.int32())))),
            T2(new OnnxType.TypeVariable("T2", List.of(OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.int64())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),
            Z(OnnxType.tensor(OnnxType.float32()), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public SVMClassifier(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        SVMClassifier(SVMClassifier that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public SVMClassifier transform(CopyContext cc, OpTransformer ot) {
            return new SVMClassifier(this, cc);
        }

        SVMClassifier(TypeElement resultType, Value X, java.util.Optional<float[]> prob_b, java.util.Optional<float[]> kernel_params, java.util.Optional<String> kernel_type, java.util.Optional<long[]> classlabels_ints, java.util.Optional<String> post_transform, java.util.Optional<float[]> rho, java.util.Optional<float[]> coefficients, java.util.Optional<float[]> support_vectors, java.util.Optional<long[]> vectors_per_class, java.util.Optional<float[]> prob_a, java.util.Optional<String[]> classlabels_strings) {
            super(SCHEMA, resultType, Set.of(), List.of(X), List.of(prob_b, kernel_params, kernel_type, classlabels_ints, post_transform, rho, coefficients, support_vectors, vectors_per_class, prob_a, classlabels_strings));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X()));
        }

        public Value X() {
            return operands().get(0);
        }

        public java.util.Optional<float[]> prob_b() {
            float[] prob_b = Attribute.prob_b.access(float[].class, onnxAttributes);
            return java.util.Optional.ofNullable(prob_b).map(float[]::clone);
        }

        public java.util.Optional<float[]> kernel_params() {
            float[] kernel_params = Attribute.kernel_params.access(float[].class, onnxAttributes);
            return java.util.Optional.ofNullable(kernel_params).map(float[]::clone);
        }

        public java.util.Optional<String> kernel_type() {
            String kernel_type = Attribute.kernel_type.access(String.class, onnxAttributes);
            return java.util.Optional.ofNullable(kernel_type);
        }

        public java.util.Optional<long[]> classlabels_ints() {
            long[] classlabels_ints = Attribute.classlabels_ints.access(long[].class, onnxAttributes);
            return java.util.Optional.ofNullable(classlabels_ints).map(long[]::clone);
        }

        public java.util.Optional<String> post_transform() {
            String post_transform = Attribute.post_transform.access(String.class, onnxAttributes);
            return java.util.Optional.ofNullable(post_transform);
        }

        public java.util.Optional<float[]> rho() {
            float[] rho = Attribute.rho.access(float[].class, onnxAttributes);
            return java.util.Optional.ofNullable(rho).map(float[]::clone);
        }

        public java.util.Optional<float[]> coefficients() {
            float[] coefficients = Attribute.coefficients.access(float[].class, onnxAttributes);
            return java.util.Optional.ofNullable(coefficients).map(float[]::clone);
        }

        public java.util.Optional<float[]> support_vectors() {
            float[] support_vectors = Attribute.support_vectors.access(float[].class, onnxAttributes);
            return java.util.Optional.ofNullable(support_vectors).map(float[]::clone);
        }

        public java.util.Optional<long[]> vectors_per_class() {
            long[] vectors_per_class = Attribute.vectors_per_class.access(long[].class, onnxAttributes);
            return java.util.Optional.ofNullable(vectors_per_class).map(long[]::clone);
        }

        public java.util.Optional<float[]> prob_a() {
            float[] prob_a = Attribute.prob_a.access(float[].class, onnxAttributes);
            return java.util.Optional.ofNullable(prob_a).map(float[]::clone);
        }

        public java.util.Optional<String[]> classlabels_strings() {
            String[] classlabels_strings = Attribute.classlabels_strings.access(String[].class, onnxAttributes);
            return java.util.Optional.ofNullable(classlabels_strings).map(String[]::clone);
        }

    }

    public static SVMClassifier SVMClassifier(TypeElement resultType, Value X, java.util.Optional<float[]> prob_b, java.util.Optional<float[]> kernel_params, java.util.Optional<String> kernel_type, java.util.Optional<long[]> classlabels_ints, java.util.Optional<String> post_transform, java.util.Optional<float[]> rho, java.util.Optional<float[]> coefficients, java.util.Optional<float[]> support_vectors, java.util.Optional<long[]> vectors_per_class, java.util.Optional<float[]> prob_a, java.util.Optional<String[]> classlabels_strings) {
        return new SVMClassifier(resultType, X, prob_b, kernel_params, kernel_type, classlabels_ints, post_transform, rho, coefficients, support_vectors, vectors_per_class, prob_a, classlabels_strings);
    }

    @OpFactoryHelper.OpDeclaration(SVMRegressor.NAME)
    public static final class SVMRegressor extends OnnxOp {
        public static final String NAME = "SVMRegressor";

        public enum Attribute implements OnnxAttribute {
            kernel_type(String.class, true, "LINEAR"),
            kernel_params(float[].class, true, null),
            n_supports(Long.class, true, 0),
            rho(float[].class, true, null),
            post_transform(String.class, true, "NONE"),
            coefficients(float[].class, true, null),
            support_vectors(float[].class, true, null),
            one_class(Long.class, true, 0),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.int32())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            Y(OnnxType.tensor(OnnxType.float32()), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public SVMRegressor(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        SVMRegressor(SVMRegressor that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public SVMRegressor transform(CopyContext cc, OpTransformer ot) {
            return new SVMRegressor(this, cc);
        }

        SVMRegressor(TypeElement resultType, Value X, java.util.Optional<String> kernel_type, java.util.Optional<float[]> kernel_params, java.util.Optional<Long> n_supports, java.util.Optional<float[]> rho, java.util.Optional<String> post_transform, java.util.Optional<float[]> coefficients, java.util.Optional<float[]> support_vectors, java.util.Optional<Long> one_class) {
            super(SCHEMA, resultType, Set.of(), List.of(X), List.of(kernel_type, kernel_params, n_supports, rho, post_transform, coefficients, support_vectors, one_class));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X()));
        }

        public Value X() {
            return operands().get(0);
        }

        public java.util.Optional<String> kernel_type() {
            String kernel_type = Attribute.kernel_type.access(String.class, onnxAttributes);
            return java.util.Optional.ofNullable(kernel_type);
        }

        public java.util.Optional<float[]> kernel_params() {
            float[] kernel_params = Attribute.kernel_params.access(float[].class, onnxAttributes);
            return java.util.Optional.ofNullable(kernel_params).map(float[]::clone);
        }

        public java.util.Optional<Long> n_supports() {
            Long n_supports = Attribute.n_supports.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(n_supports);
        }

        public java.util.Optional<float[]> rho() {
            float[] rho = Attribute.rho.access(float[].class, onnxAttributes);
            return java.util.Optional.ofNullable(rho).map(float[]::clone);
        }

        public java.util.Optional<String> post_transform() {
            String post_transform = Attribute.post_transform.access(String.class, onnxAttributes);
            return java.util.Optional.ofNullable(post_transform);
        }

        public java.util.Optional<float[]> coefficients() {
            float[] coefficients = Attribute.coefficients.access(float[].class, onnxAttributes);
            return java.util.Optional.ofNullable(coefficients).map(float[]::clone);
        }

        public java.util.Optional<float[]> support_vectors() {
            float[] support_vectors = Attribute.support_vectors.access(float[].class, onnxAttributes);
            return java.util.Optional.ofNullable(support_vectors).map(float[]::clone);
        }

        public java.util.Optional<Long> one_class() {
            Long one_class = Attribute.one_class.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(one_class);
        }

    }

    public static SVMRegressor SVMRegressor(TypeElement resultType, Value X, java.util.Optional<String> kernel_type, java.util.Optional<float[]> kernel_params, java.util.Optional<Long> n_supports, java.util.Optional<float[]> rho, java.util.Optional<String> post_transform, java.util.Optional<float[]> coefficients, java.util.Optional<float[]> support_vectors, java.util.Optional<Long> one_class) {
        return new SVMRegressor(resultType, X, kernel_type, kernel_params, n_supports, rho, post_transform, coefficients, support_vectors, one_class);
    }

    @OpFactoryHelper.OpDeclaration(Scaler.NAME)
    public static final class Scaler extends OnnxOp {
        public static final String NAME = "Scaler";

        public enum Attribute implements OnnxAttribute {
            offset(float[].class, true, null),
            scale(float[].class, true, null),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.int32())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            Y(OnnxType.tensor(OnnxType.float32()), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public Scaler(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        Scaler(Scaler that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public Scaler transform(CopyContext cc, OpTransformer ot) {
            return new Scaler(this, cc);
        }

        Scaler(TypeElement resultType, Value X, java.util.Optional<float[]> offset, java.util.Optional<float[]> scale) {
            super(SCHEMA, resultType, Set.of(), List.of(X), List.of(offset, scale));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X()));
        }

        public Value X() {
            return operands().get(0);
        }

        public java.util.Optional<float[]> offset() {
            float[] offset = Attribute.offset.access(float[].class, onnxAttributes);
            return java.util.Optional.ofNullable(offset).map(float[]::clone);
        }

        public java.util.Optional<float[]> scale() {
            float[] scale = Attribute.scale.access(float[].class, onnxAttributes);
            return java.util.Optional.ofNullable(scale).map(float[]::clone);
        }

    }

    public static Scaler Scaler(TypeElement resultType, Value X, java.util.Optional<float[]> offset, java.util.Optional<float[]> scale) {
        return new Scaler(resultType, X, offset, scale);
    }

    @OpFactoryHelper.OpDeclaration(Scatter.NAME)
    public static final class Scatter extends OnnxOp {
        public static final String NAME = "Scatter";

        public enum Attribute implements OnnxAttribute {
            axis(Long.class, true, 0),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128())))),
            Tind(new OnnxType.TypeVariable("Tind", List.of(OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            data(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            indices(TypeConstraint.Tind.typeVariable(), Quantifier.REQUIRED),
            updates(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public Scatter(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        Scatter(Scatter that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public Scatter transform(CopyContext cc, OpTransformer ot) {
            return new Scatter(this, cc);
        }

        Scatter(TypeElement resultType, Value data, Value indices, Value updates, java.util.Optional<Long> axis) {
            super(SCHEMA, resultType, Set.of(), List.of(data, indices, updates), List.of(axis));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(data(), indices(), updates()));
        }

        public Value data() {
            return operands().get(0);
        }

        public Value indices() {
            return operands().get(1);
        }

        public Value updates() {
            return operands().get(2);
        }

        public java.util.Optional<Long> axis() {
            Long axis = Attribute.axis.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(axis);
        }

    }

    public static Scatter Scatter(TypeElement resultType, Value data, Value indices, Value updates, java.util.Optional<Long> axis) {
        return new Scatter(resultType, data, indices, updates, axis);
    }

    @OpFactoryHelper.OpDeclaration(ScatterElements.NAME)
    public static final class ScatterElements extends OnnxOp {
        public static final String NAME = "ScatterElements";

        public enum Attribute implements OnnxAttribute {
            reduction(String.class, true, "none"),
            axis(Long.class, true, 0),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128())))),
            Tind(new OnnxType.TypeVariable("Tind", List.of(OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            data(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            indices(TypeConstraint.Tind.typeVariable(), Quantifier.REQUIRED),
            updates(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public ScatterElements(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        ScatterElements(ScatterElements that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public ScatterElements transform(CopyContext cc, OpTransformer ot) {
            return new ScatterElements(this, cc);
        }

        ScatterElements(TypeElement resultType, Value data, Value indices, Value updates, java.util.Optional<String> reduction, java.util.Optional<Long> axis) {
            super(SCHEMA, resultType, Set.of(), List.of(data, indices, updates), List.of(reduction, axis));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(data(), indices(), updates()));
        }

        public Value data() {
            return operands().get(0);
        }

        public Value indices() {
            return operands().get(1);
        }

        public Value updates() {
            return operands().get(2);
        }

        public java.util.Optional<String> reduction() {
            String reduction = Attribute.reduction.access(String.class, onnxAttributes);
            return java.util.Optional.ofNullable(reduction);
        }

        public java.util.Optional<Long> axis() {
            Long axis = Attribute.axis.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(axis);
        }

    }

    public static ScatterElements ScatterElements(TypeElement resultType, Value data, Value indices, Value updates, java.util.Optional<String> reduction, java.util.Optional<Long> axis) {
        return new ScatterElements(resultType, data, indices, updates, reduction, axis);
    }

    @OpFactoryHelper.OpDeclaration(ScatterND.NAME)
    public static final class ScatterND extends OnnxOp {
        public static final String NAME = "ScatterND";

        public enum Attribute implements OnnxAttribute {
            reduction(String.class, true, "none"),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            data(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            indices(OnnxType.tensor(OnnxType.int64()), Quantifier.REQUIRED),
            updates(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public ScatterND(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        ScatterND(ScatterND that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public ScatterND transform(CopyContext cc, OpTransformer ot) {
            return new ScatterND(this, cc);
        }

        ScatterND(TypeElement resultType, Value data, Value indices, Value updates, java.util.Optional<String> reduction) {
            super(SCHEMA, resultType, Set.of(), List.of(data, indices, updates), List.of(reduction));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(data(), indices(), updates()));
        }

        public Value data() {
            return operands().get(0);
        }

        public Value indices() {
            return operands().get(1);
        }

        public Value updates() {
            return operands().get(2);
        }

        public java.util.Optional<String> reduction() {
            String reduction = Attribute.reduction.access(String.class, onnxAttributes);
            return java.util.Optional.ofNullable(reduction);
        }

    }

    public static ScatterND ScatterND(TypeElement resultType, Value data, Value indices, Value updates, java.util.Optional<String> reduction) {
        return new ScatterND(resultType, data, indices, updates, reduction);
    }

    @OpFactoryHelper.OpDeclaration(Selu.NAME)
    public static final class Selu extends OnnxOp {
        public static final String NAME = "Selu";

        public enum Attribute implements OnnxAttribute {
            alpha(Float.class, true, 1.6732632f),
            gamma(Float.class, true, 1.050701f),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public Selu(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        Selu(Selu that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public Selu transform(CopyContext cc, OpTransformer ot) {
            return new Selu(this, cc);
        }

        Selu(TypeElement resultType, Value X, java.util.Optional<Float> alpha, java.util.Optional<Float> gamma) {
            super(SCHEMA, resultType, Set.of(), List.of(X), List.of(alpha, gamma));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X()));
        }

        public Value X() {
            return operands().get(0);
        }

        public java.util.Optional<Float> alpha() {
            Float alpha = Attribute.alpha.access(Float.class, onnxAttributes);
            return java.util.Optional.ofNullable(alpha);
        }

        public java.util.Optional<Float> gamma() {
            Float gamma = Attribute.gamma.access(Float.class, onnxAttributes);
            return java.util.Optional.ofNullable(gamma);
        }

    }

    public static Selu Selu(TypeElement resultType, Value X, java.util.Optional<Float> alpha, java.util.Optional<Float> gamma) {
        return new Selu(resultType, X, alpha, gamma);
    }

    @OpFactoryHelper.OpDeclaration(SequenceAt.NAME)
    public static final class SequenceAt extends OnnxOp {
        public static final String NAME = "SequenceAt";

        public enum Attribute implements OnnxAttribute.None { }

        public enum TypeConstraint implements OnnxTypeConstraint {
            S(new OnnxType.TypeVariable("S", List.of(OnnxType.seq(OnnxType.tensor(OnnxType.uint8())), OnnxType.seq(OnnxType.tensor(OnnxType.uint16())), OnnxType.seq(OnnxType.tensor(OnnxType.uint32())), OnnxType.seq(OnnxType.tensor(OnnxType.uint64())), OnnxType.seq(OnnxType.tensor(OnnxType.int8())), OnnxType.seq(OnnxType.tensor(OnnxType.int16())), OnnxType.seq(OnnxType.tensor(OnnxType.int32())), OnnxType.seq(OnnxType.tensor(OnnxType.int64())), OnnxType.seq(OnnxType.tensor(OnnxType.float16())), OnnxType.seq(OnnxType.tensor(OnnxType.float32())), OnnxType.seq(OnnxType.tensor(OnnxType.float64())), OnnxType.seq(OnnxType.tensor(OnnxType.string())), OnnxType.seq(OnnxType.tensor(OnnxType.bool())), OnnxType.seq(OnnxType.tensor(OnnxType.complex64())), OnnxType.seq(OnnxType.tensor(OnnxType.complex128()))))),
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128())))),
            I(new OnnxType.TypeVariable("I", List.of(OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            input_sequence(TypeConstraint.S.typeVariable(), Quantifier.REQUIRED),
            position(TypeConstraint.I.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            tensor(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public SequenceAt(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        SequenceAt(SequenceAt that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public SequenceAt transform(CopyContext cc, OpTransformer ot) {
            return new SequenceAt(this, cc);
        }

        SequenceAt(TypeElement resultType, Value input_sequence, Value position) {
            super(SCHEMA, resultType, Set.of(), List.of(input_sequence, position), List.of());
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(input_sequence(), position()));
        }

        public Value input_sequence() {
            return operands().get(0);
        }

        public Value position() {
            return operands().get(1);
        }

    }

    public static SequenceAt SequenceAt(TypeElement resultType, Value input_sequence, Value position) {
        return new SequenceAt(resultType, input_sequence, position);
    }

    @OpFactoryHelper.OpDeclaration(SequenceConstruct.NAME)
    public static final class SequenceConstruct extends OnnxOp {
        public static final String NAME = "SequenceConstruct";

        public enum Attribute implements OnnxAttribute.None { }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128())))),
            S(new OnnxType.TypeVariable("S", List.of(OnnxType.seq(OnnxType.tensor(OnnxType.uint8())), OnnxType.seq(OnnxType.tensor(OnnxType.uint16())), OnnxType.seq(OnnxType.tensor(OnnxType.uint32())), OnnxType.seq(OnnxType.tensor(OnnxType.uint64())), OnnxType.seq(OnnxType.tensor(OnnxType.int8())), OnnxType.seq(OnnxType.tensor(OnnxType.int16())), OnnxType.seq(OnnxType.tensor(OnnxType.int32())), OnnxType.seq(OnnxType.tensor(OnnxType.int64())), OnnxType.seq(OnnxType.tensor(OnnxType.float16())), OnnxType.seq(OnnxType.tensor(OnnxType.float32())), OnnxType.seq(OnnxType.tensor(OnnxType.float64())), OnnxType.seq(OnnxType.tensor(OnnxType.string())), OnnxType.seq(OnnxType.tensor(OnnxType.bool())), OnnxType.seq(OnnxType.tensor(OnnxType.complex64())), OnnxType.seq(OnnxType.tensor(OnnxType.complex128()))))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            inputs(TypeConstraint.T.typeVariable(), Quantifier.VARIADIC),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            output_sequence(TypeConstraint.S.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public SequenceConstruct(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        SequenceConstruct(SequenceConstruct that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public SequenceConstruct transform(CopyContext cc, OpTransformer ot) {
            return new SequenceConstruct(this, cc);
        }

        SequenceConstruct(TypeElement resultType, List<Value> inputs) {
            super(SCHEMA, resultType, Set.of(), List.of(inputs), List.of());
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(inputs()));
        }

        public List<Value> inputs() {
            return operands();
        }

    }

    public static SequenceConstruct SequenceConstruct(TypeElement resultType, List<Value> inputs) {
        return new SequenceConstruct(resultType, inputs);
    }

    @OpFactoryHelper.OpDeclaration(SequenceEmpty.NAME)
    public static final class SequenceEmpty extends OnnxOp {
        public static final String NAME = "SequenceEmpty";

        public enum Attribute implements OnnxAttribute {
            dtype(Long.class, true, null),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            S(new OnnxType.TypeVariable("S", List.of(OnnxType.seq(OnnxType.tensor(OnnxType.uint8())), OnnxType.seq(OnnxType.tensor(OnnxType.uint16())), OnnxType.seq(OnnxType.tensor(OnnxType.uint32())), OnnxType.seq(OnnxType.tensor(OnnxType.uint64())), OnnxType.seq(OnnxType.tensor(OnnxType.int8())), OnnxType.seq(OnnxType.tensor(OnnxType.int16())), OnnxType.seq(OnnxType.tensor(OnnxType.int32())), OnnxType.seq(OnnxType.tensor(OnnxType.int64())), OnnxType.seq(OnnxType.tensor(OnnxType.float16())), OnnxType.seq(OnnxType.tensor(OnnxType.float32())), OnnxType.seq(OnnxType.tensor(OnnxType.float64())), OnnxType.seq(OnnxType.tensor(OnnxType.string())), OnnxType.seq(OnnxType.tensor(OnnxType.bool())), OnnxType.seq(OnnxType.tensor(OnnxType.complex64())), OnnxType.seq(OnnxType.tensor(OnnxType.complex128()))))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter.None { }

        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.S.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public SequenceEmpty(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        SequenceEmpty(SequenceEmpty that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public SequenceEmpty transform(CopyContext cc, OpTransformer ot) {
            return new SequenceEmpty(this, cc);
        }

        SequenceEmpty(TypeElement resultType, java.util.Optional<Long> dtype) {
            super(SCHEMA, resultType, Set.of(), List.of(), List.of(dtype));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of());
        }

        public java.util.Optional<Long> dtype() {
            Long dtype = Attribute.dtype.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(dtype);
        }

    }

    public static SequenceEmpty SequenceEmpty(TypeElement resultType, java.util.Optional<Long> dtype) {
        return new SequenceEmpty(resultType, dtype);
    }

    @OpFactoryHelper.OpDeclaration(SequenceErase.NAME)
    public static final class SequenceErase extends OnnxOp {
        public static final String NAME = "SequenceErase";

        public enum Attribute implements OnnxAttribute.None { }

        public enum TypeConstraint implements OnnxTypeConstraint {
            S(new OnnxType.TypeVariable("S", List.of(OnnxType.seq(OnnxType.tensor(OnnxType.uint8())), OnnxType.seq(OnnxType.tensor(OnnxType.uint16())), OnnxType.seq(OnnxType.tensor(OnnxType.uint32())), OnnxType.seq(OnnxType.tensor(OnnxType.uint64())), OnnxType.seq(OnnxType.tensor(OnnxType.int8())), OnnxType.seq(OnnxType.tensor(OnnxType.int16())), OnnxType.seq(OnnxType.tensor(OnnxType.int32())), OnnxType.seq(OnnxType.tensor(OnnxType.int64())), OnnxType.seq(OnnxType.tensor(OnnxType.float16())), OnnxType.seq(OnnxType.tensor(OnnxType.float32())), OnnxType.seq(OnnxType.tensor(OnnxType.float64())), OnnxType.seq(OnnxType.tensor(OnnxType.string())), OnnxType.seq(OnnxType.tensor(OnnxType.bool())), OnnxType.seq(OnnxType.tensor(OnnxType.complex64())), OnnxType.seq(OnnxType.tensor(OnnxType.complex128()))))),
            I(new OnnxType.TypeVariable("I", List.of(OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            input_sequence(TypeConstraint.S.typeVariable(), Quantifier.REQUIRED),
            position(TypeConstraint.I.typeVariable(), Quantifier.OPTIONAL),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            output_sequence(TypeConstraint.S.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public SequenceErase(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        SequenceErase(SequenceErase that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public SequenceErase transform(CopyContext cc, OpTransformer ot) {
            return new SequenceErase(this, cc);
        }

        SequenceErase(TypeElement resultType, Value input_sequence, java.util.Optional<Value> position) {
            super(SCHEMA, resultType, Set.of(), List.of(input_sequence, position), List.of());
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(input_sequence(), position()));
        }

        public Value input_sequence() {
            return operands().get(0);
        }

        public java.util.Optional<Value> position() {
            int i = optionalInputArguments.indexOf(InputParameter.position);
            return i != -1 ? java.util.Optional.of(operands().get(1 + i)) : java.util.Optional.empty();
        }

    }

    public static SequenceErase SequenceErase(TypeElement resultType, Value input_sequence, java.util.Optional<Value> position) {
        return new SequenceErase(resultType, input_sequence, position);
    }

    @OpFactoryHelper.OpDeclaration(SequenceInsert.NAME)
    public static final class SequenceInsert extends OnnxOp {
        public static final String NAME = "SequenceInsert";

        public enum Attribute implements OnnxAttribute.None { }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128())))),
            S(new OnnxType.TypeVariable("S", List.of(OnnxType.seq(OnnxType.tensor(OnnxType.uint8())), OnnxType.seq(OnnxType.tensor(OnnxType.uint16())), OnnxType.seq(OnnxType.tensor(OnnxType.uint32())), OnnxType.seq(OnnxType.tensor(OnnxType.uint64())), OnnxType.seq(OnnxType.tensor(OnnxType.int8())), OnnxType.seq(OnnxType.tensor(OnnxType.int16())), OnnxType.seq(OnnxType.tensor(OnnxType.int32())), OnnxType.seq(OnnxType.tensor(OnnxType.int64())), OnnxType.seq(OnnxType.tensor(OnnxType.float16())), OnnxType.seq(OnnxType.tensor(OnnxType.float32())), OnnxType.seq(OnnxType.tensor(OnnxType.float64())), OnnxType.seq(OnnxType.tensor(OnnxType.string())), OnnxType.seq(OnnxType.tensor(OnnxType.bool())), OnnxType.seq(OnnxType.tensor(OnnxType.complex64())), OnnxType.seq(OnnxType.tensor(OnnxType.complex128()))))),
            I(new OnnxType.TypeVariable("I", List.of(OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            input_sequence(TypeConstraint.S.typeVariable(), Quantifier.REQUIRED),
            tensor(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            position(TypeConstraint.I.typeVariable(), Quantifier.OPTIONAL),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            output_sequence(TypeConstraint.S.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public SequenceInsert(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        SequenceInsert(SequenceInsert that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public SequenceInsert transform(CopyContext cc, OpTransformer ot) {
            return new SequenceInsert(this, cc);
        }

        SequenceInsert(TypeElement resultType, Value input_sequence, Value tensor, java.util.Optional<Value> position) {
            super(SCHEMA, resultType, Set.of(), List.of(input_sequence, tensor, position), List.of());
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(input_sequence(), tensor(), position()));
        }

        public Value input_sequence() {
            return operands().get(0);
        }

        public Value tensor() {
            return operands().get(1);
        }

        public java.util.Optional<Value> position() {
            int i = optionalInputArguments.indexOf(InputParameter.position);
            return i != -1 ? java.util.Optional.of(operands().get(2 + i)) : java.util.Optional.empty();
        }

    }

    public static SequenceInsert SequenceInsert(TypeElement resultType, Value input_sequence, Value tensor, java.util.Optional<Value> position) {
        return new SequenceInsert(resultType, input_sequence, tensor, position);
    }

    @OpFactoryHelper.OpDeclaration(SequenceLength.NAME)
    public static final class SequenceLength extends OnnxOp {
        public static final String NAME = "SequenceLength";

        public enum Attribute implements OnnxAttribute.None { }

        public enum TypeConstraint implements OnnxTypeConstraint {
            S(new OnnxType.TypeVariable("S", List.of(OnnxType.seq(OnnxType.tensor(OnnxType.uint8())), OnnxType.seq(OnnxType.tensor(OnnxType.uint16())), OnnxType.seq(OnnxType.tensor(OnnxType.uint32())), OnnxType.seq(OnnxType.tensor(OnnxType.uint64())), OnnxType.seq(OnnxType.tensor(OnnxType.int8())), OnnxType.seq(OnnxType.tensor(OnnxType.int16())), OnnxType.seq(OnnxType.tensor(OnnxType.int32())), OnnxType.seq(OnnxType.tensor(OnnxType.int64())), OnnxType.seq(OnnxType.tensor(OnnxType.float16())), OnnxType.seq(OnnxType.tensor(OnnxType.float32())), OnnxType.seq(OnnxType.tensor(OnnxType.float64())), OnnxType.seq(OnnxType.tensor(OnnxType.string())), OnnxType.seq(OnnxType.tensor(OnnxType.bool())), OnnxType.seq(OnnxType.tensor(OnnxType.complex64())), OnnxType.seq(OnnxType.tensor(OnnxType.complex128()))))),
            I(new OnnxType.TypeVariable("I", List.of(OnnxType.tensor(OnnxType.int64())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            input_sequence(TypeConstraint.S.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            length(TypeConstraint.I.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public SequenceLength(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        SequenceLength(SequenceLength that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public SequenceLength transform(CopyContext cc, OpTransformer ot) {
            return new SequenceLength(this, cc);
        }

        SequenceLength(TypeElement resultType, Value input_sequence) {
            super(SCHEMA, resultType, Set.of(), List.of(input_sequence), List.of());
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(input_sequence()));
        }

        public Value input_sequence() {
            return operands().get(0);
        }

    }

    public static SequenceLength SequenceLength(TypeElement resultType, Value input_sequence) {
        return new SequenceLength(resultType, input_sequence);
    }

    @OpFactoryHelper.OpDeclaration(Shape.NAME)
    public static final class Shape extends OnnxOp {
        public static final String NAME = "Shape";

        public enum Attribute implements OnnxAttribute {
            start(Long.class, true, 0),
            end(Long.class, true, null),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128()), OnnxType.tensor(OnnxType.float8e4m3fn()), OnnxType.tensor(OnnxType.float8e4m3fnuz()), OnnxType.tensor(OnnxType.float8e5m2()), OnnxType.tensor(OnnxType.float8e5m2fnuz()), OnnxType.tensor(OnnxType.uint4()), OnnxType.tensor(OnnxType.int4()), OnnxType.tensor(OnnxType.float4e2m1())))),
            T1(new OnnxType.TypeVariable("T1", List.of(OnnxType.tensor(OnnxType.int64())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            data(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            shape(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public Shape(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        Shape(Shape that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public Shape transform(CopyContext cc, OpTransformer ot) {
            return new Shape(this, cc);
        }

        Shape(TypeElement resultType, Value data, java.util.Optional<Long> start, java.util.Optional<Long> end) {
            super(SCHEMA, resultType, Set.of(), List.of(data), List.of(start, end));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(data()));
        }

        public Value data() {
            return operands().get(0);
        }

        public java.util.Optional<Long> start() {
            Long start = Attribute.start.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(start);
        }

        public java.util.Optional<Long> end() {
            Long end = Attribute.end.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(end);
        }

    }

    public static Shape Shape(TypeElement resultType, Value data, java.util.Optional<Long> start, java.util.Optional<Long> end) {
        return new Shape(resultType, data, start, end);
    }

    @OpFactoryHelper.OpDeclaration(Shrink.NAME)
    public static final class Shrink extends OnnxOp {
        public static final String NAME = "Shrink";

        public enum Attribute implements OnnxAttribute {
            lambd(Float.class, true, 0.5f),
            bias(Float.class, true, 0.0f),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            input(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public Shrink(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        Shrink(Shrink that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public Shrink transform(CopyContext cc, OpTransformer ot) {
            return new Shrink(this, cc);
        }

        Shrink(TypeElement resultType, Value input, java.util.Optional<Float> lambd, java.util.Optional<Float> bias) {
            super(SCHEMA, resultType, Set.of(), List.of(input), List.of(lambd, bias));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(input()));
        }

        public Value input() {
            return operands().get(0);
        }

        public java.util.Optional<Float> lambd() {
            Float lambd = Attribute.lambd.access(Float.class, onnxAttributes);
            return java.util.Optional.ofNullable(lambd);
        }

        public java.util.Optional<Float> bias() {
            Float bias = Attribute.bias.access(Float.class, onnxAttributes);
            return java.util.Optional.ofNullable(bias);
        }

    }

    public static Shrink Shrink(TypeElement resultType, Value input, java.util.Optional<Float> lambd, java.util.Optional<Float> bias) {
        return new Shrink(resultType, input, lambd, bias);
    }

    @OpFactoryHelper.OpDeclaration(Sigmoid.NAME)
    public static final class Sigmoid extends OnnxOp {
        public static final String NAME = "Sigmoid";

        public enum Attribute implements OnnxAttribute.None { }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public Sigmoid(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        Sigmoid(Sigmoid that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public Sigmoid transform(CopyContext cc, OpTransformer ot) {
            return new Sigmoid(this, cc);
        }

        Sigmoid(TypeElement resultType, Value X) {
            super(SCHEMA, resultType, Set.of(), List.of(X), List.of());
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X()));
        }

        public Value X() {
            return operands().get(0);
        }

    }

    public static Sigmoid Sigmoid(TypeElement resultType, Value X) {
        return new Sigmoid(resultType, X);
    }

    @OpFactoryHelper.OpDeclaration(Sign.NAME)
    public static final class Sign extends OnnxOp {
        public static final String NAME = "Sign";

        public enum Attribute implements OnnxAttribute.None { }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            input(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public Sign(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        Sign(Sign that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public Sign transform(CopyContext cc, OpTransformer ot) {
            return new Sign(this, cc);
        }

        Sign(TypeElement resultType, Value input) {
            super(SCHEMA, resultType, Set.of(), List.of(input), List.of());
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(input()));
        }

        public Value input() {
            return operands().get(0);
        }

    }

    public static Sign Sign(TypeElement resultType, Value input) {
        return new Sign(resultType, input);
    }

    @OpFactoryHelper.OpDeclaration(Sin.NAME)
    public static final class Sin extends OnnxOp {
        public static final String NAME = "Sin";

        public enum Attribute implements OnnxAttribute.None { }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            input(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public Sin(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        Sin(Sin that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public Sin transform(CopyContext cc, OpTransformer ot) {
            return new Sin(this, cc);
        }

        Sin(TypeElement resultType, Value input) {
            super(SCHEMA, resultType, Set.of(), List.of(input), List.of());
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(input()));
        }

        public Value input() {
            return operands().get(0);
        }

    }

    public static Sin Sin(TypeElement resultType, Value input) {
        return new Sin(resultType, input);
    }

    @OpFactoryHelper.OpDeclaration(Sinh.NAME)
    public static final class Sinh extends OnnxOp {
        public static final String NAME = "Sinh";

        public enum Attribute implements OnnxAttribute.None { }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            input(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public Sinh(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        Sinh(Sinh that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public Sinh transform(CopyContext cc, OpTransformer ot) {
            return new Sinh(this, cc);
        }

        Sinh(TypeElement resultType, Value input) {
            super(SCHEMA, resultType, Set.of(), List.of(input), List.of());
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(input()));
        }

        public Value input() {
            return operands().get(0);
        }

    }

    public static Sinh Sinh(TypeElement resultType, Value input) {
        return new Sinh(resultType, input);
    }

    @OpFactoryHelper.OpDeclaration(Size.NAME)
    public static final class Size extends OnnxOp {
        public static final String NAME = "Size";

        public enum Attribute implements OnnxAttribute.None { }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128()), OnnxType.tensor(OnnxType.float8e4m3fn()), OnnxType.tensor(OnnxType.float8e4m3fnuz()), OnnxType.tensor(OnnxType.float8e5m2()), OnnxType.tensor(OnnxType.float8e5m2fnuz()), OnnxType.tensor(OnnxType.uint4()), OnnxType.tensor(OnnxType.int4()), OnnxType.tensor(OnnxType.float4e2m1())))),
            T1(new OnnxType.TypeVariable("T1", List.of(OnnxType.tensor(OnnxType.int64())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            data(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            size(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public Size(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        Size(Size that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public Size transform(CopyContext cc, OpTransformer ot) {
            return new Size(this, cc);
        }

        Size(TypeElement resultType, Value data) {
            super(SCHEMA, resultType, Set.of(), List.of(data), List.of());
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(data()));
        }

        public Value data() {
            return operands().get(0);
        }

    }

    public static Size Size(TypeElement resultType, Value data) {
        return new Size(resultType, data);
    }

    @OpFactoryHelper.OpDeclaration(Slice.NAME)
    public static final class Slice extends OnnxOp {
        public static final String NAME = "Slice";

        public enum Attribute implements OnnxAttribute.None { }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128())))),
            Tind(new OnnxType.TypeVariable("Tind", List.of(OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            data(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            starts(TypeConstraint.Tind.typeVariable(), Quantifier.REQUIRED),
            ends(TypeConstraint.Tind.typeVariable(), Quantifier.REQUIRED),
            axes(TypeConstraint.Tind.typeVariable(), Quantifier.OPTIONAL),
            steps(TypeConstraint.Tind.typeVariable(), Quantifier.OPTIONAL),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public Slice(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        Slice(Slice that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public Slice transform(CopyContext cc, OpTransformer ot) {
            return new Slice(this, cc);
        }

        Slice(TypeElement resultType, Value data, Value starts, Value ends, java.util.Optional<Value> axes, java.util.Optional<Value> steps) {
            super(SCHEMA, resultType, Set.of(), List.of(data, starts, ends, axes, steps), List.of());
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(data(), starts(), ends(), axes(), steps()));
        }

        public Value data() {
            return operands().get(0);
        }

        public Value starts() {
            return operands().get(1);
        }

        public Value ends() {
            return operands().get(2);
        }

        public java.util.Optional<Value> axes() {
            int i = optionalInputArguments.indexOf(InputParameter.axes);
            return i != -1 ? java.util.Optional.of(operands().get(3 + i)) : java.util.Optional.empty();
        }

        public java.util.Optional<Value> steps() {
            int i = optionalInputArguments.indexOf(InputParameter.steps);
            return i != -1 ? java.util.Optional.of(operands().get(3 + i)) : java.util.Optional.empty();
        }

    }

    public static Slice Slice(TypeElement resultType, Value data, Value starts, Value ends, java.util.Optional<Value> axes, java.util.Optional<Value> steps) {
        return new Slice(resultType, data, starts, ends, axes, steps);
    }

    @OpFactoryHelper.OpDeclaration(Softmax.NAME)
    public static final class Softmax extends OnnxOp {
        public static final String NAME = "Softmax";

        public enum Attribute implements OnnxAttribute {
            axis(Long.class, true, -1),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            input(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public Softmax(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        Softmax(Softmax that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public Softmax transform(CopyContext cc, OpTransformer ot) {
            return new Softmax(this, cc);
        }

        Softmax(TypeElement resultType, Value input, java.util.Optional<Long> axis) {
            super(SCHEMA, resultType, Set.of(), List.of(input), List.of(axis));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(input()));
        }

        public Value input() {
            return operands().get(0);
        }

        public java.util.Optional<Long> axis() {
            Long axis = Attribute.axis.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(axis);
        }

    }

    public static Softmax Softmax(TypeElement resultType, Value input, java.util.Optional<Long> axis) {
        return new Softmax(resultType, input, axis);
    }

    @OpFactoryHelper.OpDeclaration(SoftmaxCrossEntropyLoss.NAME)
    public static final class SoftmaxCrossEntropyLoss extends OnnxOp {
        public static final String NAME = "SoftmaxCrossEntropyLoss";

        public enum Attribute implements OnnxAttribute {
            ignore_index(Long.class, true, null),
            reduction(String.class, true, "mean"),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),
            Tind(new OnnxType.TypeVariable("Tind", List.of(OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            scores(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            labels(TypeConstraint.Tind.typeVariable(), Quantifier.REQUIRED),
            weights(TypeConstraint.T.typeVariable(), Quantifier.OPTIONAL),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            log_prob(TypeConstraint.T.typeVariable(), Quantifier.OPTIONAL),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public SoftmaxCrossEntropyLoss(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        SoftmaxCrossEntropyLoss(SoftmaxCrossEntropyLoss that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public SoftmaxCrossEntropyLoss transform(CopyContext cc, OpTransformer ot) {
            return new SoftmaxCrossEntropyLoss(this, cc);
        }

        SoftmaxCrossEntropyLoss(TypeElement resultType, Set<OutputParameter> optionalOutputs, Value scores, Value labels, java.util.Optional<Value> weights, java.util.Optional<Long> ignore_index, java.util.Optional<String> reduction) {
            super(SCHEMA, resultType, optionalOutputs, List.of(scores, labels, weights), List.of(ignore_index, reduction));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(scores(), labels(), weights()));
        }

        public Value scores() {
            return operands().get(0);
        }

        public Value labels() {
            return operands().get(1);
        }

        public java.util.Optional<Value> weights() {
            int i = optionalInputArguments.indexOf(InputParameter.weights);
            return i != -1 ? java.util.Optional.of(operands().get(2 + i)) : java.util.Optional.empty();
        }

        public java.util.Optional<Long> ignore_index() {
            Long ignore_index = Attribute.ignore_index.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(ignore_index);
        }

        public java.util.Optional<String> reduction() {
            String reduction = Attribute.reduction.access(String.class, onnxAttributes);
            return java.util.Optional.ofNullable(reduction);
        }

    }

    public static SoftmaxCrossEntropyLoss SoftmaxCrossEntropyLoss(TypeElement resultType, Set<SoftmaxCrossEntropyLoss.OutputParameter> optionalOutputs, Value scores, Value labels, java.util.Optional<Value> weights, java.util.Optional<Long> ignore_index, java.util.Optional<String> reduction) {
        return new SoftmaxCrossEntropyLoss(resultType, optionalOutputs, scores, labels, weights, ignore_index, reduction);
    }

    @OpFactoryHelper.OpDeclaration(Softplus.NAME)
    public static final class Softplus extends OnnxOp {
        public static final String NAME = "Softplus";

        public enum Attribute implements OnnxAttribute.None { }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public Softplus(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        Softplus(Softplus that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public Softplus transform(CopyContext cc, OpTransformer ot) {
            return new Softplus(this, cc);
        }

        Softplus(TypeElement resultType, Value X) {
            super(SCHEMA, resultType, Set.of(), List.of(X), List.of());
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X()));
        }

        public Value X() {
            return operands().get(0);
        }

    }

    public static Softplus Softplus(TypeElement resultType, Value X) {
        return new Softplus(resultType, X);
    }

    @OpFactoryHelper.OpDeclaration(Softsign.NAME)
    public static final class Softsign extends OnnxOp {
        public static final String NAME = "Softsign";

        public enum Attribute implements OnnxAttribute.None { }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            input(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public Softsign(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        Softsign(Softsign that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public Softsign transform(CopyContext cc, OpTransformer ot) {
            return new Softsign(this, cc);
        }

        Softsign(TypeElement resultType, Value input) {
            super(SCHEMA, resultType, Set.of(), List.of(input), List.of());
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(input()));
        }

        public Value input() {
            return operands().get(0);
        }

    }

    public static Softsign Softsign(TypeElement resultType, Value input) {
        return new Softsign(resultType, input);
    }

    @OpFactoryHelper.OpDeclaration(SpaceToDepth.NAME)
    public static final class SpaceToDepth extends OnnxOp {
        public static final String NAME = "SpaceToDepth";

        public enum Attribute implements OnnxAttribute {
            blocksize(Long.class, false, null),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            input(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public SpaceToDepth(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        SpaceToDepth(SpaceToDepth that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public SpaceToDepth transform(CopyContext cc, OpTransformer ot) {
            return new SpaceToDepth(this, cc);
        }

        SpaceToDepth(TypeElement resultType, Value input, long blocksize) {
            super(SCHEMA, resultType, Set.of(), List.of(input), List.of(blocksize));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(input()));
        }

        public Value input() {
            return operands().get(0);
        }

        public long blocksize() {
            long blocksize = Attribute.blocksize.access(Long.class, onnxAttributes);
            return blocksize;
        }

    }

    public static SpaceToDepth SpaceToDepth(TypeElement resultType, Value input, long blocksize) {
        return new SpaceToDepth(resultType, input, blocksize);
    }

    @OpFactoryHelper.OpDeclaration(Split.NAME)
    public static final class Split extends OnnxOp {
        public static final String NAME = "Split";

        public enum Attribute implements OnnxAttribute {
            num_outputs(Long.class, true, null),
            axis(Long.class, true, 0),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            input(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            split(OnnxType.tensor(OnnxType.int64()), Quantifier.OPTIONAL),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            outputs(TypeConstraint.T.typeVariable(), Quantifier.VARIADIC),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public Split(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        Split(Split that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public Split transform(CopyContext cc, OpTransformer ot) {
            return new Split(this, cc);
        }

        Split(TypeElement resultType, Value input, java.util.Optional<Value> split, java.util.Optional<Long> num_outputs, java.util.Optional<Long> axis) {
            super(SCHEMA, resultType, Set.of(), List.of(input, split), List.of(num_outputs, axis));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(input(), split()));
        }

        public Value input() {
            return operands().get(0);
        }

        public java.util.Optional<Value> split() {
            int i = optionalInputArguments.indexOf(InputParameter.split);
            return i != -1 ? java.util.Optional.of(operands().get(1 + i)) : java.util.Optional.empty();
        }

        public java.util.Optional<Long> num_outputs() {
            Long num_outputs = Attribute.num_outputs.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(num_outputs);
        }

        public java.util.Optional<Long> axis() {
            Long axis = Attribute.axis.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(axis);
        }

    }

    public static Split Split(TypeElement resultType, Value input, java.util.Optional<Value> split, java.util.Optional<Long> num_outputs, java.util.Optional<Long> axis) {
        return new Split(resultType, input, split, num_outputs, axis);
    }

    @OpFactoryHelper.OpDeclaration(SplitToSequence.NAME)
    public static final class SplitToSequence extends OnnxOp {
        public static final String NAME = "SplitToSequence";

        public enum Attribute implements OnnxAttribute {
            keepdims(Long.class, true, 1),
            axis(Long.class, true, 0),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128())))),
            I(new OnnxType.TypeVariable("I", List.of(OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64())))),
            S(new OnnxType.TypeVariable("S", List.of(OnnxType.seq(OnnxType.tensor(OnnxType.uint8())), OnnxType.seq(OnnxType.tensor(OnnxType.uint16())), OnnxType.seq(OnnxType.tensor(OnnxType.uint32())), OnnxType.seq(OnnxType.tensor(OnnxType.uint64())), OnnxType.seq(OnnxType.tensor(OnnxType.int8())), OnnxType.seq(OnnxType.tensor(OnnxType.int16())), OnnxType.seq(OnnxType.tensor(OnnxType.int32())), OnnxType.seq(OnnxType.tensor(OnnxType.int64())), OnnxType.seq(OnnxType.tensor(OnnxType.float16())), OnnxType.seq(OnnxType.tensor(OnnxType.float32())), OnnxType.seq(OnnxType.tensor(OnnxType.float64())), OnnxType.seq(OnnxType.tensor(OnnxType.string())), OnnxType.seq(OnnxType.tensor(OnnxType.bool())), OnnxType.seq(OnnxType.tensor(OnnxType.complex64())), OnnxType.seq(OnnxType.tensor(OnnxType.complex128()))))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            input(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            split(TypeConstraint.I.typeVariable(), Quantifier.OPTIONAL),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            output_sequence(TypeConstraint.S.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public SplitToSequence(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        SplitToSequence(SplitToSequence that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public SplitToSequence transform(CopyContext cc, OpTransformer ot) {
            return new SplitToSequence(this, cc);
        }

        SplitToSequence(TypeElement resultType, Value input, java.util.Optional<Value> split, java.util.Optional<Long> keepdims, java.util.Optional<Long> axis) {
            super(SCHEMA, resultType, Set.of(), List.of(input, split), List.of(keepdims, axis));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(input(), split()));
        }

        public Value input() {
            return operands().get(0);
        }

        public java.util.Optional<Value> split() {
            int i = optionalInputArguments.indexOf(InputParameter.split);
            return i != -1 ? java.util.Optional.of(operands().get(1 + i)) : java.util.Optional.empty();
        }

        public java.util.Optional<Long> keepdims() {
            Long keepdims = Attribute.keepdims.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(keepdims);
        }

        public java.util.Optional<Long> axis() {
            Long axis = Attribute.axis.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(axis);
        }

    }

    public static SplitToSequence SplitToSequence(TypeElement resultType, Value input, java.util.Optional<Value> split, java.util.Optional<Long> keepdims, java.util.Optional<Long> axis) {
        return new SplitToSequence(resultType, input, split, keepdims, axis);
    }

    @OpFactoryHelper.OpDeclaration(Sqrt.NAME)
    public static final class Sqrt extends OnnxOp {
        public static final String NAME = "Sqrt";

        public enum Attribute implements OnnxAttribute.None { }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public Sqrt(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        Sqrt(Sqrt that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public Sqrt transform(CopyContext cc, OpTransformer ot) {
            return new Sqrt(this, cc);
        }

        Sqrt(TypeElement resultType, Value X) {
            super(SCHEMA, resultType, Set.of(), List.of(X), List.of());
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X()));
        }

        public Value X() {
            return operands().get(0);
        }

    }

    public static Sqrt Sqrt(TypeElement resultType, Value X) {
        return new Sqrt(resultType, X);
    }

    @OpFactoryHelper.OpDeclaration(Squeeze.NAME)
    public static final class Squeeze extends OnnxOp {
        public static final String NAME = "Squeeze";

        public enum Attribute implements OnnxAttribute.None { }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128()), OnnxType.tensor(OnnxType.float8e4m3fn()), OnnxType.tensor(OnnxType.float8e4m3fnuz()), OnnxType.tensor(OnnxType.float8e5m2()), OnnxType.tensor(OnnxType.float8e5m2fnuz()), OnnxType.tensor(OnnxType.uint4()), OnnxType.tensor(OnnxType.int4()), OnnxType.tensor(OnnxType.float4e2m1())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            data(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            axes(OnnxType.tensor(OnnxType.int64()), Quantifier.OPTIONAL),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            squeezed(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public Squeeze(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        Squeeze(Squeeze that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public Squeeze transform(CopyContext cc, OpTransformer ot) {
            return new Squeeze(this, cc);
        }

        Squeeze(TypeElement resultType, Value data, java.util.Optional<Value> axes) {
            super(SCHEMA, resultType, Set.of(), List.of(data, axes), List.of());
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(data(), axes()));
        }

        public Value data() {
            return operands().get(0);
        }

        public java.util.Optional<Value> axes() {
            int i = optionalInputArguments.indexOf(InputParameter.axes);
            return i != -1 ? java.util.Optional.of(operands().get(1 + i)) : java.util.Optional.empty();
        }

    }

    public static Squeeze Squeeze(TypeElement resultType, Value data, java.util.Optional<Value> axes) {
        return new Squeeze(resultType, data, axes);
    }

    @OpFactoryHelper.OpDeclaration(StringConcat.NAME)
    public static final class StringConcat extends OnnxOp {
        public static final String NAME = "StringConcat";

        public enum Attribute implements OnnxAttribute.None { }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.string())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            Z(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public StringConcat(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        StringConcat(StringConcat that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public StringConcat transform(CopyContext cc, OpTransformer ot) {
            return new StringConcat(this, cc);
        }

        StringConcat(TypeElement resultType, Value X, Value Y) {
            super(SCHEMA, resultType, Set.of(), List.of(X, Y), List.of());
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X(), Y()));
        }

        public Value X() {
            return operands().get(0);
        }

        public Value Y() {
            return operands().get(1);
        }

    }

    public static StringConcat StringConcat(TypeElement resultType, Value X, Value Y) {
        return new StringConcat(resultType, X, Y);
    }

    @OpFactoryHelper.OpDeclaration(StringNormalizer.NAME)
    public static final class StringNormalizer extends OnnxOp {
        public static final String NAME = "StringNormalizer";

        public enum Attribute implements OnnxAttribute {
            is_case_sensitive(Long.class, true, 0),
            locale(String.class, true, null),
            stopwords(String[].class, true, null),
            case_change_action(String.class, true, "NONE"),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint.None { }

        public enum InputParameter implements OnnxParameter {
            X(OnnxType.tensor(OnnxType.string()), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            Y(OnnxType.tensor(OnnxType.string()), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public StringNormalizer(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        StringNormalizer(StringNormalizer that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public StringNormalizer transform(CopyContext cc, OpTransformer ot) {
            return new StringNormalizer(this, cc);
        }

        StringNormalizer(TypeElement resultType, Value X, java.util.Optional<Long> is_case_sensitive, java.util.Optional<String> locale, java.util.Optional<String[]> stopwords, java.util.Optional<String> case_change_action) {
            super(SCHEMA, resultType, Set.of(), List.of(X), List.of(is_case_sensitive, locale, stopwords, case_change_action));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X()));
        }

        public Value X() {
            return operands().get(0);
        }

        public java.util.Optional<Long> is_case_sensitive() {
            Long is_case_sensitive = Attribute.is_case_sensitive.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(is_case_sensitive);
        }

        public java.util.Optional<String> locale() {
            String locale = Attribute.locale.access(String.class, onnxAttributes);
            return java.util.Optional.ofNullable(locale);
        }

        public java.util.Optional<String[]> stopwords() {
            String[] stopwords = Attribute.stopwords.access(String[].class, onnxAttributes);
            return java.util.Optional.ofNullable(stopwords).map(String[]::clone);
        }

        public java.util.Optional<String> case_change_action() {
            String case_change_action = Attribute.case_change_action.access(String.class, onnxAttributes);
            return java.util.Optional.ofNullable(case_change_action);
        }

    }

    public static StringNormalizer StringNormalizer(TypeElement resultType, Value X, java.util.Optional<Long> is_case_sensitive, java.util.Optional<String> locale, java.util.Optional<String[]> stopwords, java.util.Optional<String> case_change_action) {
        return new StringNormalizer(resultType, X, is_case_sensitive, locale, stopwords, case_change_action);
    }

    @OpFactoryHelper.OpDeclaration(StringSplit.NAME)
    public static final class StringSplit extends OnnxOp {
        public static final String NAME = "StringSplit";

        public enum Attribute implements OnnxAttribute {
            delimiter(String.class, true, null),
            maxsplit(Long.class, true, null),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T1(new OnnxType.TypeVariable("T1", List.of(OnnxType.tensor(OnnxType.string())))),
            T2(new OnnxType.TypeVariable("T2", List.of(OnnxType.tensor(OnnxType.string())))),
            T3(new OnnxType.TypeVariable("T3", List.of(OnnxType.tensor(OnnxType.int64())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),
            Z(TypeConstraint.T3.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public StringSplit(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        StringSplit(StringSplit that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public StringSplit transform(CopyContext cc, OpTransformer ot) {
            return new StringSplit(this, cc);
        }

        StringSplit(TypeElement resultType, Value X, java.util.Optional<String> delimiter, java.util.Optional<Long> maxsplit) {
            super(SCHEMA, resultType, Set.of(), List.of(X), List.of(delimiter, maxsplit));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X()));
        }

        public Value X() {
            return operands().get(0);
        }

        public java.util.Optional<String> delimiter() {
            String delimiter = Attribute.delimiter.access(String.class, onnxAttributes);
            return java.util.Optional.ofNullable(delimiter);
        }

        public java.util.Optional<Long> maxsplit() {
            Long maxsplit = Attribute.maxsplit.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(maxsplit);
        }

    }

    public static StringSplit StringSplit(TypeElement resultType, Value X, java.util.Optional<String> delimiter, java.util.Optional<Long> maxsplit) {
        return new StringSplit(resultType, X, delimiter, maxsplit);
    }

    @OpFactoryHelper.OpDeclaration(Sub.NAME)
    public static final class Sub extends OnnxOp {
        public static final String NAME = "Sub";

        public enum Attribute implements OnnxAttribute.None { }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            A(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            B(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            C(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public Sub(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        Sub(Sub that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public Sub transform(CopyContext cc, OpTransformer ot) {
            return new Sub(this, cc);
        }

        Sub(TypeElement resultType, Value A, Value B) {
            super(SCHEMA, resultType, Set.of(), List.of(A, B), List.of());
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(A(), B()));
        }

        public Value A() {
            return operands().get(0);
        }

        public Value B() {
            return operands().get(1);
        }

    }

    public static Sub Sub(TypeElement resultType, Value A, Value B) {
        return new Sub(resultType, A, B);
    }

    @OpFactoryHelper.OpDeclaration(Sum.NAME)
    public static final class Sum extends OnnxOp {
        public static final String NAME = "Sum";

        public enum Attribute implements OnnxAttribute.None { }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            data_0(TypeConstraint.T.typeVariable(), Quantifier.VARIADIC),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            sum(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public Sum(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        Sum(Sum that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public Sum transform(CopyContext cc, OpTransformer ot) {
            return new Sum(this, cc);
        }

        Sum(TypeElement resultType, List<Value> data_0) {
            super(SCHEMA, resultType, Set.of(), List.of(data_0), List.of());
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(data_0()));
        }

        public List<Value> data_0() {
            return operands();
        }

    }

    public static Sum Sum(TypeElement resultType, List<Value> data_0) {
        return new Sum(resultType, data_0);
    }

    @OpFactoryHelper.OpDeclaration(Tan.NAME)
    public static final class Tan extends OnnxOp {
        public static final String NAME = "Tan";

        public enum Attribute implements OnnxAttribute.None { }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            input(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public Tan(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        Tan(Tan that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public Tan transform(CopyContext cc, OpTransformer ot) {
            return new Tan(this, cc);
        }

        Tan(TypeElement resultType, Value input) {
            super(SCHEMA, resultType, Set.of(), List.of(input), List.of());
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(input()));
        }

        public Value input() {
            return operands().get(0);
        }

    }

    public static Tan Tan(TypeElement resultType, Value input) {
        return new Tan(resultType, input);
    }

    @OpFactoryHelper.OpDeclaration(Tanh.NAME)
    public static final class Tanh extends OnnxOp {
        public static final String NAME = "Tanh";

        public enum Attribute implements OnnxAttribute.None { }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            input(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public Tanh(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        Tanh(Tanh that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public Tanh transform(CopyContext cc, OpTransformer ot) {
            return new Tanh(this, cc);
        }

        Tanh(TypeElement resultType, Value input) {
            super(SCHEMA, resultType, Set.of(), List.of(input), List.of());
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(input()));
        }

        public Value input() {
            return operands().get(0);
        }

    }

    public static Tanh Tanh(TypeElement resultType, Value input) {
        return new Tanh(resultType, input);
    }

    @OpFactoryHelper.OpDeclaration(TfIdfVectorizer.NAME)
    public static final class TfIdfVectorizer extends OnnxOp {
        public static final String NAME = "TfIdfVectorizer";

        public enum Attribute implements OnnxAttribute {
            ngram_counts(long[].class, false, null),
            min_gram_length(Long.class, false, null),
            pool_strings(String[].class, true, null),
            mode(String.class, false, null),
            max_gram_length(Long.class, false, null),
            max_skip_count(Long.class, false, null),
            pool_int64s(long[].class, true, null),
            weights(float[].class, true, null),
            ngram_indexes(long[].class, false, null),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64())))),
            T1(new OnnxType.TypeVariable("T1", List.of(OnnxType.tensor(OnnxType.float32())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public TfIdfVectorizer(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        TfIdfVectorizer(TfIdfVectorizer that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public TfIdfVectorizer transform(CopyContext cc, OpTransformer ot) {
            return new TfIdfVectorizer(this, cc);
        }

        TfIdfVectorizer(TypeElement resultType, Value X, long[] ngram_counts, long min_gram_length, java.util.Optional<String[]> pool_strings, String mode, long max_gram_length, long max_skip_count, java.util.Optional<long[]> pool_int64s, java.util.Optional<float[]> weights, long[] ngram_indexes) {
            super(SCHEMA, resultType, Set.of(), List.of(X), List.of(ngram_counts, min_gram_length, pool_strings, mode, max_gram_length, max_skip_count, pool_int64s, weights, ngram_indexes));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X()));
        }

        public Value X() {
            return operands().get(0);
        }

        public long[] ngram_counts() {
            long[] ngram_counts = Attribute.ngram_counts.access(long[].class, onnxAttributes);
            return ngram_counts.clone();
        }

        public long min_gram_length() {
            long min_gram_length = Attribute.min_gram_length.access(Long.class, onnxAttributes);
            return min_gram_length;
        }

        public java.util.Optional<String[]> pool_strings() {
            String[] pool_strings = Attribute.pool_strings.access(String[].class, onnxAttributes);
            return java.util.Optional.ofNullable(pool_strings).map(String[]::clone);
        }

        public String mode() {
            String mode = Attribute.mode.access(String.class, onnxAttributes);
            return mode;
        }

        public long max_gram_length() {
            long max_gram_length = Attribute.max_gram_length.access(Long.class, onnxAttributes);
            return max_gram_length;
        }

        public long max_skip_count() {
            long max_skip_count = Attribute.max_skip_count.access(Long.class, onnxAttributes);
            return max_skip_count;
        }

        public java.util.Optional<long[]> pool_int64s() {
            long[] pool_int64s = Attribute.pool_int64s.access(long[].class, onnxAttributes);
            return java.util.Optional.ofNullable(pool_int64s).map(long[]::clone);
        }

        public java.util.Optional<float[]> weights() {
            float[] weights = Attribute.weights.access(float[].class, onnxAttributes);
            return java.util.Optional.ofNullable(weights).map(float[]::clone);
        }

        public long[] ngram_indexes() {
            long[] ngram_indexes = Attribute.ngram_indexes.access(long[].class, onnxAttributes);
            return ngram_indexes.clone();
        }

    }

    public static TfIdfVectorizer TfIdfVectorizer(TypeElement resultType, Value X, long[] ngram_counts, long min_gram_length, java.util.Optional<String[]> pool_strings, String mode, long max_gram_length, long max_skip_count, java.util.Optional<long[]> pool_int64s, java.util.Optional<float[]> weights, long[] ngram_indexes) {
        return new TfIdfVectorizer(resultType, X, ngram_counts, min_gram_length, pool_strings, mode, max_gram_length, max_skip_count, pool_int64s, weights, ngram_indexes);
    }

    @OpFactoryHelper.OpDeclaration(ThresholdedRelu.NAME)
    public static final class ThresholdedRelu extends OnnxOp {
        public static final String NAME = "ThresholdedRelu";

        public enum Attribute implements OnnxAttribute {
            alpha(Float.class, true, 1.0f),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public ThresholdedRelu(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        ThresholdedRelu(ThresholdedRelu that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public ThresholdedRelu transform(CopyContext cc, OpTransformer ot) {
            return new ThresholdedRelu(this, cc);
        }

        ThresholdedRelu(TypeElement resultType, Value X, java.util.Optional<Float> alpha) {
            super(SCHEMA, resultType, Set.of(), List.of(X), List.of(alpha));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X()));
        }

        public Value X() {
            return operands().get(0);
        }

        public java.util.Optional<Float> alpha() {
            Float alpha = Attribute.alpha.access(Float.class, onnxAttributes);
            return java.util.Optional.ofNullable(alpha);
        }

    }

    public static ThresholdedRelu ThresholdedRelu(TypeElement resultType, Value X, java.util.Optional<Float> alpha) {
        return new ThresholdedRelu(resultType, X, alpha);
    }

    @OpFactoryHelper.OpDeclaration(Tile.NAME)
    public static final class Tile extends OnnxOp {
        public static final String NAME = "Tile";

        public enum Attribute implements OnnxAttribute.None { }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128())))),
            T1(new OnnxType.TypeVariable("T1", List.of(OnnxType.tensor(OnnxType.int64())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            input(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            repeats(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public Tile(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        Tile(Tile that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public Tile transform(CopyContext cc, OpTransformer ot) {
            return new Tile(this, cc);
        }

        Tile(TypeElement resultType, Value input, Value repeats) {
            super(SCHEMA, resultType, Set.of(), List.of(input, repeats), List.of());
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(input(), repeats()));
        }

        public Value input() {
            return operands().get(0);
        }

        public Value repeats() {
            return operands().get(1);
        }

    }

    public static Tile Tile(TypeElement resultType, Value input, Value repeats) {
        return new Tile(resultType, input, repeats);
    }

    @OpFactoryHelper.OpDeclaration(TopK.NAME)
    public static final class TopK extends OnnxOp {
        public static final String NAME = "TopK";

        public enum Attribute implements OnnxAttribute {
            largest(Long.class, true, 1),
            sorted(Long.class, true, 1),
            axis(Long.class, true, -1),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),
            I(new OnnxType.TypeVariable("I", List.of(OnnxType.tensor(OnnxType.int64())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            K(OnnxType.tensor(OnnxType.int64()), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            Values(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            Indices(TypeConstraint.I.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public TopK(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        TopK(TopK that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public TopK transform(CopyContext cc, OpTransformer ot) {
            return new TopK(this, cc);
        }

        TopK(TypeElement resultType, Value X, Value K, java.util.Optional<Long> largest, java.util.Optional<Long> sorted, java.util.Optional<Long> axis) {
            super(SCHEMA, resultType, Set.of(), List.of(X, K), List.of(largest, sorted, axis));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X(), K()));
        }

        public Value X() {
            return operands().get(0);
        }

        public Value K() {
            return operands().get(1);
        }

        public java.util.Optional<Long> largest() {
            Long largest = Attribute.largest.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(largest);
        }

        public java.util.Optional<Long> sorted() {
            Long sorted = Attribute.sorted.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(sorted);
        }

        public java.util.Optional<Long> axis() {
            Long axis = Attribute.axis.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(axis);
        }

    }

    public static TopK TopK(TypeElement resultType, Value X, Value K, java.util.Optional<Long> largest, java.util.Optional<Long> sorted, java.util.Optional<Long> axis) {
        return new TopK(resultType, X, K, largest, sorted, axis);
    }

    @OpFactoryHelper.OpDeclaration(Transpose.NAME)
    public static final class Transpose extends OnnxOp {
        public static final String NAME = "Transpose";

        public enum Attribute implements OnnxAttribute {
            perm(long[].class, true, null),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128()), OnnxType.tensor(OnnxType.float8e4m3fn()), OnnxType.tensor(OnnxType.float8e4m3fnuz()), OnnxType.tensor(OnnxType.float8e5m2()), OnnxType.tensor(OnnxType.float8e5m2fnuz()), OnnxType.tensor(OnnxType.uint4()), OnnxType.tensor(OnnxType.int4()), OnnxType.tensor(OnnxType.float4e2m1())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            data(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            transposed(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public Transpose(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        Transpose(Transpose that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public Transpose transform(CopyContext cc, OpTransformer ot) {
            return new Transpose(this, cc);
        }

        Transpose(TypeElement resultType, Value data, java.util.Optional<long[]> perm) {
            super(SCHEMA, resultType, Set.of(), List.of(data), List.of(perm));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(data()));
        }

        public Value data() {
            return operands().get(0);
        }

        public java.util.Optional<long[]> perm() {
            long[] perm = Attribute.perm.access(long[].class, onnxAttributes);
            return java.util.Optional.ofNullable(perm).map(long[]::clone);
        }

    }

    public static Transpose Transpose(TypeElement resultType, Value data, java.util.Optional<long[]> perm) {
        return new Transpose(resultType, data, perm);
    }

    @OpFactoryHelper.OpDeclaration(TreeEnsemble.NAME)
    public static final class TreeEnsemble extends OnnxOp {
        public static final String NAME = "TreeEnsemble";

        public enum Attribute implements OnnxAttribute {
            aggregate_function(Long.class, true, 1),
            nodes_hitrates(Tensor.class, true, null),
            nodes_featureids(long[].class, false, null),
            nodes_falseleafs(long[].class, false, null),
            post_transform(Long.class, true, 0),
            nodes_trueleafs(long[].class, false, null),
            nodes_modes(Tensor.class, false, null),
            nodes_falsenodeids(long[].class, false, null),
            nodes_truenodeids(long[].class, false, null),
            leaf_weights(Tensor.class, false, null),
            leaf_targetids(long[].class, false, null),
            tree_roots(long[].class, false, null),
            n_targets(Long.class, true, null),
            nodes_missing_value_tracks_true(long[].class, true, null),
            membership_values(Tensor.class, true, null),
            nodes_splits(Tensor.class, false, null),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.float16())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public TreeEnsemble(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        TreeEnsemble(TreeEnsemble that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public TreeEnsemble transform(CopyContext cc, OpTransformer ot) {
            return new TreeEnsemble(this, cc);
        }

        TreeEnsemble(TypeElement resultType, Value X, java.util.Optional<Long> aggregate_function, java.util.Optional<Tensor> nodes_hitrates, long[] nodes_featureids, long[] nodes_falseleafs, java.util.Optional<Long> post_transform, long[] nodes_trueleafs, Tensor nodes_modes, long[] nodes_falsenodeids, long[] nodes_truenodeids, Tensor leaf_weights, long[] leaf_targetids, long[] tree_roots, java.util.Optional<Long> n_targets, java.util.Optional<long[]> nodes_missing_value_tracks_true, java.util.Optional<Tensor> membership_values, Tensor nodes_splits) {
            super(SCHEMA, resultType, Set.of(), List.of(X), List.of(aggregate_function, nodes_hitrates, nodes_featureids, nodes_falseleafs, post_transform, nodes_trueleafs, nodes_modes, nodes_falsenodeids, nodes_truenodeids, leaf_weights, leaf_targetids, tree_roots, n_targets, nodes_missing_value_tracks_true, membership_values, nodes_splits));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X()));
        }

        public Value X() {
            return operands().get(0);
        }

        public java.util.Optional<Long> aggregate_function() {
            Long aggregate_function = Attribute.aggregate_function.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(aggregate_function);
        }

        public java.util.Optional<Tensor> nodes_hitrates() {
            Tensor nodes_hitrates = Attribute.nodes_hitrates.access(Tensor.class, onnxAttributes);
            return java.util.Optional.ofNullable(nodes_hitrates);
        }

        public long[] nodes_featureids() {
            long[] nodes_featureids = Attribute.nodes_featureids.access(long[].class, onnxAttributes);
            return nodes_featureids.clone();
        }

        public long[] nodes_falseleafs() {
            long[] nodes_falseleafs = Attribute.nodes_falseleafs.access(long[].class, onnxAttributes);
            return nodes_falseleafs.clone();
        }

        public java.util.Optional<Long> post_transform() {
            Long post_transform = Attribute.post_transform.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(post_transform);
        }

        public long[] nodes_trueleafs() {
            long[] nodes_trueleafs = Attribute.nodes_trueleafs.access(long[].class, onnxAttributes);
            return nodes_trueleafs.clone();
        }

        public Tensor nodes_modes() {
            Tensor nodes_modes = Attribute.nodes_modes.access(Tensor.class, onnxAttributes);
            return nodes_modes;
        }

        public long[] nodes_falsenodeids() {
            long[] nodes_falsenodeids = Attribute.nodes_falsenodeids.access(long[].class, onnxAttributes);
            return nodes_falsenodeids.clone();
        }

        public long[] nodes_truenodeids() {
            long[] nodes_truenodeids = Attribute.nodes_truenodeids.access(long[].class, onnxAttributes);
            return nodes_truenodeids.clone();
        }

        public Tensor leaf_weights() {
            Tensor leaf_weights = Attribute.leaf_weights.access(Tensor.class, onnxAttributes);
            return leaf_weights;
        }

        public long[] leaf_targetids() {
            long[] leaf_targetids = Attribute.leaf_targetids.access(long[].class, onnxAttributes);
            return leaf_targetids.clone();
        }

        public long[] tree_roots() {
            long[] tree_roots = Attribute.tree_roots.access(long[].class, onnxAttributes);
            return tree_roots.clone();
        }

        public java.util.Optional<Long> n_targets() {
            Long n_targets = Attribute.n_targets.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(n_targets);
        }

        public java.util.Optional<long[]> nodes_missing_value_tracks_true() {
            long[] nodes_missing_value_tracks_true = Attribute.nodes_missing_value_tracks_true.access(long[].class, onnxAttributes);
            return java.util.Optional.ofNullable(nodes_missing_value_tracks_true).map(long[]::clone);
        }

        public java.util.Optional<Tensor> membership_values() {
            Tensor membership_values = Attribute.membership_values.access(Tensor.class, onnxAttributes);
            return java.util.Optional.ofNullable(membership_values);
        }

        public Tensor nodes_splits() {
            Tensor nodes_splits = Attribute.nodes_splits.access(Tensor.class, onnxAttributes);
            return nodes_splits;
        }

    }

    public static TreeEnsemble TreeEnsemble(TypeElement resultType, Value X, java.util.Optional<Long> aggregate_function, java.util.Optional<Tensor> nodes_hitrates, long[] nodes_featureids, long[] nodes_falseleafs, java.util.Optional<Long> post_transform, long[] nodes_trueleafs, Tensor nodes_modes, long[] nodes_falsenodeids, long[] nodes_truenodeids, Tensor leaf_weights, long[] leaf_targetids, long[] tree_roots, java.util.Optional<Long> n_targets, java.util.Optional<long[]> nodes_missing_value_tracks_true, java.util.Optional<Tensor> membership_values, Tensor nodes_splits) {
        return new TreeEnsemble(resultType, X, aggregate_function, nodes_hitrates, nodes_featureids, nodes_falseleafs, post_transform, nodes_trueleafs, nodes_modes, nodes_falsenodeids, nodes_truenodeids, leaf_weights, leaf_targetids, tree_roots, n_targets, nodes_missing_value_tracks_true, membership_values, nodes_splits);
    }

    @OpFactoryHelper.OpDeclaration(TreeEnsembleClassifier.NAME)
    public static final class TreeEnsembleClassifier extends OnnxOp {
        public static final String NAME = "TreeEnsembleClassifier";

        public enum Attribute implements OnnxAttribute {
            classlabels_int64s(long[].class, true, null),
            class_ids(long[].class, true, null),
            nodes_hitrates(float[].class, true, null),
            nodes_featureids(long[].class, true, null),
            nodes_treeids(long[].class, true, null),
            class_weights_as_tensor(Tensor.class, true, null),
            post_transform(String.class, true, "NONE"),
            nodes_modes(String[].class, true, null),
            nodes_falsenodeids(long[].class, true, null),
            classlabels_strings(String[].class, true, null),
            nodes_truenodeids(long[].class, true, null),
            nodes_nodeids(long[].class, true, null),
            nodes_hitrates_as_tensor(Tensor.class, true, null),
            class_weights(float[].class, true, null),
            base_values_as_tensor(Tensor.class, true, null),
            nodes_missing_value_tracks_true(long[].class, true, null),
            class_nodeids(long[].class, true, null),
            class_treeids(long[].class, true, null),
            base_values(float[].class, true, null),
            nodes_values(float[].class, true, null),
            nodes_values_as_tensor(Tensor.class, true, null),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T1(new OnnxType.TypeVariable("T1", List.of(OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.int32())))),
            T2(new OnnxType.TypeVariable("T2", List.of(OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.int64())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),
            Z(OnnxType.tensor(OnnxType.float32()), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public TreeEnsembleClassifier(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        TreeEnsembleClassifier(TreeEnsembleClassifier that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public TreeEnsembleClassifier transform(CopyContext cc, OpTransformer ot) {
            return new TreeEnsembleClassifier(this, cc);
        }

        TreeEnsembleClassifier(TypeElement resultType, Value X, java.util.Optional<long[]> classlabels_int64s, java.util.Optional<long[]> class_ids, java.util.Optional<float[]> nodes_hitrates, java.util.Optional<long[]> nodes_featureids, java.util.Optional<long[]> nodes_treeids, java.util.Optional<Tensor> class_weights_as_tensor, java.util.Optional<String> post_transform, java.util.Optional<String[]> nodes_modes, java.util.Optional<long[]> nodes_falsenodeids, java.util.Optional<String[]> classlabels_strings, java.util.Optional<long[]> nodes_truenodeids, java.util.Optional<long[]> nodes_nodeids, java.util.Optional<Tensor> nodes_hitrates_as_tensor, java.util.Optional<float[]> class_weights, java.util.Optional<Tensor> base_values_as_tensor, java.util.Optional<long[]> nodes_missing_value_tracks_true, java.util.Optional<long[]> class_nodeids, java.util.Optional<long[]> class_treeids, java.util.Optional<float[]> base_values, java.util.Optional<float[]> nodes_values, java.util.Optional<Tensor> nodes_values_as_tensor) {
            super(SCHEMA, resultType, Set.of(), List.of(X), List.of(classlabels_int64s, class_ids, nodes_hitrates, nodes_featureids, nodes_treeids, class_weights_as_tensor, post_transform, nodes_modes, nodes_falsenodeids, classlabels_strings, nodes_truenodeids, nodes_nodeids, nodes_hitrates_as_tensor, class_weights, base_values_as_tensor, nodes_missing_value_tracks_true, class_nodeids, class_treeids, base_values, nodes_values, nodes_values_as_tensor));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X()));
        }

        public Value X() {
            return operands().get(0);
        }

        public java.util.Optional<long[]> classlabels_int64s() {
            long[] classlabels_int64s = Attribute.classlabels_int64s.access(long[].class, onnxAttributes);
            return java.util.Optional.ofNullable(classlabels_int64s).map(long[]::clone);
        }

        public java.util.Optional<long[]> class_ids() {
            long[] class_ids = Attribute.class_ids.access(long[].class, onnxAttributes);
            return java.util.Optional.ofNullable(class_ids).map(long[]::clone);
        }

        public java.util.Optional<float[]> nodes_hitrates() {
            float[] nodes_hitrates = Attribute.nodes_hitrates.access(float[].class, onnxAttributes);
            return java.util.Optional.ofNullable(nodes_hitrates).map(float[]::clone);
        }

        public java.util.Optional<long[]> nodes_featureids() {
            long[] nodes_featureids = Attribute.nodes_featureids.access(long[].class, onnxAttributes);
            return java.util.Optional.ofNullable(nodes_featureids).map(long[]::clone);
        }

        public java.util.Optional<long[]> nodes_treeids() {
            long[] nodes_treeids = Attribute.nodes_treeids.access(long[].class, onnxAttributes);
            return java.util.Optional.ofNullable(nodes_treeids).map(long[]::clone);
        }

        public java.util.Optional<Tensor> class_weights_as_tensor() {
            Tensor class_weights_as_tensor = Attribute.class_weights_as_tensor.access(Tensor.class, onnxAttributes);
            return java.util.Optional.ofNullable(class_weights_as_tensor);
        }

        public java.util.Optional<String> post_transform() {
            String post_transform = Attribute.post_transform.access(String.class, onnxAttributes);
            return java.util.Optional.ofNullable(post_transform);
        }

        public java.util.Optional<String[]> nodes_modes() {
            String[] nodes_modes = Attribute.nodes_modes.access(String[].class, onnxAttributes);
            return java.util.Optional.ofNullable(nodes_modes).map(String[]::clone);
        }

        public java.util.Optional<long[]> nodes_falsenodeids() {
            long[] nodes_falsenodeids = Attribute.nodes_falsenodeids.access(long[].class, onnxAttributes);
            return java.util.Optional.ofNullable(nodes_falsenodeids).map(long[]::clone);
        }

        public java.util.Optional<String[]> classlabels_strings() {
            String[] classlabels_strings = Attribute.classlabels_strings.access(String[].class, onnxAttributes);
            return java.util.Optional.ofNullable(classlabels_strings).map(String[]::clone);
        }

        public java.util.Optional<long[]> nodes_truenodeids() {
            long[] nodes_truenodeids = Attribute.nodes_truenodeids.access(long[].class, onnxAttributes);
            return java.util.Optional.ofNullable(nodes_truenodeids).map(long[]::clone);
        }

        public java.util.Optional<long[]> nodes_nodeids() {
            long[] nodes_nodeids = Attribute.nodes_nodeids.access(long[].class, onnxAttributes);
            return java.util.Optional.ofNullable(nodes_nodeids).map(long[]::clone);
        }

        public java.util.Optional<Tensor> nodes_hitrates_as_tensor() {
            Tensor nodes_hitrates_as_tensor = Attribute.nodes_hitrates_as_tensor.access(Tensor.class, onnxAttributes);
            return java.util.Optional.ofNullable(nodes_hitrates_as_tensor);
        }

        public java.util.Optional<float[]> class_weights() {
            float[] class_weights = Attribute.class_weights.access(float[].class, onnxAttributes);
            return java.util.Optional.ofNullable(class_weights).map(float[]::clone);
        }

        public java.util.Optional<Tensor> base_values_as_tensor() {
            Tensor base_values_as_tensor = Attribute.base_values_as_tensor.access(Tensor.class, onnxAttributes);
            return java.util.Optional.ofNullable(base_values_as_tensor);
        }

        public java.util.Optional<long[]> nodes_missing_value_tracks_true() {
            long[] nodes_missing_value_tracks_true = Attribute.nodes_missing_value_tracks_true.access(long[].class, onnxAttributes);
            return java.util.Optional.ofNullable(nodes_missing_value_tracks_true).map(long[]::clone);
        }

        public java.util.Optional<long[]> class_nodeids() {
            long[] class_nodeids = Attribute.class_nodeids.access(long[].class, onnxAttributes);
            return java.util.Optional.ofNullable(class_nodeids).map(long[]::clone);
        }

        public java.util.Optional<long[]> class_treeids() {
            long[] class_treeids = Attribute.class_treeids.access(long[].class, onnxAttributes);
            return java.util.Optional.ofNullable(class_treeids).map(long[]::clone);
        }

        public java.util.Optional<float[]> base_values() {
            float[] base_values = Attribute.base_values.access(float[].class, onnxAttributes);
            return java.util.Optional.ofNullable(base_values).map(float[]::clone);
        }

        public java.util.Optional<float[]> nodes_values() {
            float[] nodes_values = Attribute.nodes_values.access(float[].class, onnxAttributes);
            return java.util.Optional.ofNullable(nodes_values).map(float[]::clone);
        }

        public java.util.Optional<Tensor> nodes_values_as_tensor() {
            Tensor nodes_values_as_tensor = Attribute.nodes_values_as_tensor.access(Tensor.class, onnxAttributes);
            return java.util.Optional.ofNullable(nodes_values_as_tensor);
        }

    }

    public static TreeEnsembleClassifier TreeEnsembleClassifier(TypeElement resultType, Value X, java.util.Optional<long[]> classlabels_int64s, java.util.Optional<long[]> class_ids, java.util.Optional<float[]> nodes_hitrates, java.util.Optional<long[]> nodes_featureids, java.util.Optional<long[]> nodes_treeids, java.util.Optional<Tensor> class_weights_as_tensor, java.util.Optional<String> post_transform, java.util.Optional<String[]> nodes_modes, java.util.Optional<long[]> nodes_falsenodeids, java.util.Optional<String[]> classlabels_strings, java.util.Optional<long[]> nodes_truenodeids, java.util.Optional<long[]> nodes_nodeids, java.util.Optional<Tensor> nodes_hitrates_as_tensor, java.util.Optional<float[]> class_weights, java.util.Optional<Tensor> base_values_as_tensor, java.util.Optional<long[]> nodes_missing_value_tracks_true, java.util.Optional<long[]> class_nodeids, java.util.Optional<long[]> class_treeids, java.util.Optional<float[]> base_values, java.util.Optional<float[]> nodes_values, java.util.Optional<Tensor> nodes_values_as_tensor) {
        return new TreeEnsembleClassifier(resultType, X, classlabels_int64s, class_ids, nodes_hitrates, nodes_featureids, nodes_treeids, class_weights_as_tensor, post_transform, nodes_modes, nodes_falsenodeids, classlabels_strings, nodes_truenodeids, nodes_nodeids, nodes_hitrates_as_tensor, class_weights, base_values_as_tensor, nodes_missing_value_tracks_true, class_nodeids, class_treeids, base_values, nodes_values, nodes_values_as_tensor);
    }

    @OpFactoryHelper.OpDeclaration(TreeEnsembleRegressor.NAME)
    public static final class TreeEnsembleRegressor extends OnnxOp {
        public static final String NAME = "TreeEnsembleRegressor";

        public enum Attribute implements OnnxAttribute {
            aggregate_function(String.class, true, "SUM"),
            nodes_hitrates(float[].class, true, null),
            target_weights_as_tensor(Tensor.class, true, null),
            nodes_featureids(long[].class, true, null),
            target_treeids(long[].class, true, null),
            nodes_treeids(long[].class, true, null),
            post_transform(String.class, true, "NONE"),
            nodes_modes(String[].class, true, null),
            target_weights(float[].class, true, null),
            nodes_falsenodeids(long[].class, true, null),
            target_ids(long[].class, true, null),
            nodes_truenodeids(long[].class, true, null),
            target_nodeids(long[].class, true, null),
            nodes_nodeids(long[].class, true, null),
            nodes_hitrates_as_tensor(Tensor.class, true, null),
            base_values_as_tensor(Tensor.class, true, null),
            n_targets(Long.class, true, null),
            nodes_missing_value_tracks_true(long[].class, true, null),
            base_values(float[].class, true, null),
            nodes_values(float[].class, true, null),
            nodes_values_as_tensor(Tensor.class, true, null),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.int32())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            Y(OnnxType.tensor(OnnxType.float32()), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public TreeEnsembleRegressor(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        TreeEnsembleRegressor(TreeEnsembleRegressor that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public TreeEnsembleRegressor transform(CopyContext cc, OpTransformer ot) {
            return new TreeEnsembleRegressor(this, cc);
        }

        TreeEnsembleRegressor(TypeElement resultType, Value X, java.util.Optional<String> aggregate_function, java.util.Optional<float[]> nodes_hitrates, java.util.Optional<Tensor> target_weights_as_tensor, java.util.Optional<long[]> nodes_featureids, java.util.Optional<long[]> target_treeids, java.util.Optional<long[]> nodes_treeids, java.util.Optional<String> post_transform, java.util.Optional<String[]> nodes_modes, java.util.Optional<float[]> target_weights, java.util.Optional<long[]> nodes_falsenodeids, java.util.Optional<long[]> target_ids, java.util.Optional<long[]> nodes_truenodeids, java.util.Optional<long[]> target_nodeids, java.util.Optional<long[]> nodes_nodeids, java.util.Optional<Tensor> nodes_hitrates_as_tensor, java.util.Optional<Tensor> base_values_as_tensor, java.util.Optional<Long> n_targets, java.util.Optional<long[]> nodes_missing_value_tracks_true, java.util.Optional<float[]> base_values, java.util.Optional<float[]> nodes_values, java.util.Optional<Tensor> nodes_values_as_tensor) {
            super(SCHEMA, resultType, Set.of(), List.of(X), List.of(aggregate_function, nodes_hitrates, target_weights_as_tensor, nodes_featureids, target_treeids, nodes_treeids, post_transform, nodes_modes, target_weights, nodes_falsenodeids, target_ids, nodes_truenodeids, target_nodeids, nodes_nodeids, nodes_hitrates_as_tensor, base_values_as_tensor, n_targets, nodes_missing_value_tracks_true, base_values, nodes_values, nodes_values_as_tensor));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X()));
        }

        public Value X() {
            return operands().get(0);
        }

        public java.util.Optional<String> aggregate_function() {
            String aggregate_function = Attribute.aggregate_function.access(String.class, onnxAttributes);
            return java.util.Optional.ofNullable(aggregate_function);
        }

        public java.util.Optional<float[]> nodes_hitrates() {
            float[] nodes_hitrates = Attribute.nodes_hitrates.access(float[].class, onnxAttributes);
            return java.util.Optional.ofNullable(nodes_hitrates).map(float[]::clone);
        }

        public java.util.Optional<Tensor> target_weights_as_tensor() {
            Tensor target_weights_as_tensor = Attribute.target_weights_as_tensor.access(Tensor.class, onnxAttributes);
            return java.util.Optional.ofNullable(target_weights_as_tensor);
        }

        public java.util.Optional<long[]> nodes_featureids() {
            long[] nodes_featureids = Attribute.nodes_featureids.access(long[].class, onnxAttributes);
            return java.util.Optional.ofNullable(nodes_featureids).map(long[]::clone);
        }

        public java.util.Optional<long[]> target_treeids() {
            long[] target_treeids = Attribute.target_treeids.access(long[].class, onnxAttributes);
            return java.util.Optional.ofNullable(target_treeids).map(long[]::clone);
        }

        public java.util.Optional<long[]> nodes_treeids() {
            long[] nodes_treeids = Attribute.nodes_treeids.access(long[].class, onnxAttributes);
            return java.util.Optional.ofNullable(nodes_treeids).map(long[]::clone);
        }

        public java.util.Optional<String> post_transform() {
            String post_transform = Attribute.post_transform.access(String.class, onnxAttributes);
            return java.util.Optional.ofNullable(post_transform);
        }

        public java.util.Optional<String[]> nodes_modes() {
            String[] nodes_modes = Attribute.nodes_modes.access(String[].class, onnxAttributes);
            return java.util.Optional.ofNullable(nodes_modes).map(String[]::clone);
        }

        public java.util.Optional<float[]> target_weights() {
            float[] target_weights = Attribute.target_weights.access(float[].class, onnxAttributes);
            return java.util.Optional.ofNullable(target_weights).map(float[]::clone);
        }

        public java.util.Optional<long[]> nodes_falsenodeids() {
            long[] nodes_falsenodeids = Attribute.nodes_falsenodeids.access(long[].class, onnxAttributes);
            return java.util.Optional.ofNullable(nodes_falsenodeids).map(long[]::clone);
        }

        public java.util.Optional<long[]> target_ids() {
            long[] target_ids = Attribute.target_ids.access(long[].class, onnxAttributes);
            return java.util.Optional.ofNullable(target_ids).map(long[]::clone);
        }

        public java.util.Optional<long[]> nodes_truenodeids() {
            long[] nodes_truenodeids = Attribute.nodes_truenodeids.access(long[].class, onnxAttributes);
            return java.util.Optional.ofNullable(nodes_truenodeids).map(long[]::clone);
        }

        public java.util.Optional<long[]> target_nodeids() {
            long[] target_nodeids = Attribute.target_nodeids.access(long[].class, onnxAttributes);
            return java.util.Optional.ofNullable(target_nodeids).map(long[]::clone);
        }

        public java.util.Optional<long[]> nodes_nodeids() {
            long[] nodes_nodeids = Attribute.nodes_nodeids.access(long[].class, onnxAttributes);
            return java.util.Optional.ofNullable(nodes_nodeids).map(long[]::clone);
        }

        public java.util.Optional<Tensor> nodes_hitrates_as_tensor() {
            Tensor nodes_hitrates_as_tensor = Attribute.nodes_hitrates_as_tensor.access(Tensor.class, onnxAttributes);
            return java.util.Optional.ofNullable(nodes_hitrates_as_tensor);
        }

        public java.util.Optional<Tensor> base_values_as_tensor() {
            Tensor base_values_as_tensor = Attribute.base_values_as_tensor.access(Tensor.class, onnxAttributes);
            return java.util.Optional.ofNullable(base_values_as_tensor);
        }

        public java.util.Optional<Long> n_targets() {
            Long n_targets = Attribute.n_targets.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(n_targets);
        }

        public java.util.Optional<long[]> nodes_missing_value_tracks_true() {
            long[] nodes_missing_value_tracks_true = Attribute.nodes_missing_value_tracks_true.access(long[].class, onnxAttributes);
            return java.util.Optional.ofNullable(nodes_missing_value_tracks_true).map(long[]::clone);
        }

        public java.util.Optional<float[]> base_values() {
            float[] base_values = Attribute.base_values.access(float[].class, onnxAttributes);
            return java.util.Optional.ofNullable(base_values).map(float[]::clone);
        }

        public java.util.Optional<float[]> nodes_values() {
            float[] nodes_values = Attribute.nodes_values.access(float[].class, onnxAttributes);
            return java.util.Optional.ofNullable(nodes_values).map(float[]::clone);
        }

        public java.util.Optional<Tensor> nodes_values_as_tensor() {
            Tensor nodes_values_as_tensor = Attribute.nodes_values_as_tensor.access(Tensor.class, onnxAttributes);
            return java.util.Optional.ofNullable(nodes_values_as_tensor);
        }

    }

    public static TreeEnsembleRegressor TreeEnsembleRegressor(TypeElement resultType, Value X, java.util.Optional<String> aggregate_function, java.util.Optional<float[]> nodes_hitrates, java.util.Optional<Tensor> target_weights_as_tensor, java.util.Optional<long[]> nodes_featureids, java.util.Optional<long[]> target_treeids, java.util.Optional<long[]> nodes_treeids, java.util.Optional<String> post_transform, java.util.Optional<String[]> nodes_modes, java.util.Optional<float[]> target_weights, java.util.Optional<long[]> nodes_falsenodeids, java.util.Optional<long[]> target_ids, java.util.Optional<long[]> nodes_truenodeids, java.util.Optional<long[]> target_nodeids, java.util.Optional<long[]> nodes_nodeids, java.util.Optional<Tensor> nodes_hitrates_as_tensor, java.util.Optional<Tensor> base_values_as_tensor, java.util.Optional<Long> n_targets, java.util.Optional<long[]> nodes_missing_value_tracks_true, java.util.Optional<float[]> base_values, java.util.Optional<float[]> nodes_values, java.util.Optional<Tensor> nodes_values_as_tensor) {
        return new TreeEnsembleRegressor(resultType, X, aggregate_function, nodes_hitrates, target_weights_as_tensor, nodes_featureids, target_treeids, nodes_treeids, post_transform, nodes_modes, target_weights, nodes_falsenodeids, target_ids, nodes_truenodeids, target_nodeids, nodes_nodeids, nodes_hitrates_as_tensor, base_values_as_tensor, n_targets, nodes_missing_value_tracks_true, base_values, nodes_values, nodes_values_as_tensor);
    }

    @OpFactoryHelper.OpDeclaration(Trilu.NAME)
    public static final class Trilu extends OnnxOp {
        public static final String NAME = "Trilu";

        public enum Attribute implements OnnxAttribute {
            upper(Long.class, true, 1),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            input(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            k(OnnxType.tensor(OnnxType.int64()), Quantifier.OPTIONAL),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public Trilu(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        Trilu(Trilu that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public Trilu transform(CopyContext cc, OpTransformer ot) {
            return new Trilu(this, cc);
        }

        Trilu(TypeElement resultType, Value input, java.util.Optional<Value> k, java.util.Optional<Long> upper) {
            super(SCHEMA, resultType, Set.of(), List.of(input, k), List.of(upper));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(input(), k()));
        }

        public Value input() {
            return operands().get(0);
        }

        public java.util.Optional<Value> k() {
            int i = optionalInputArguments.indexOf(InputParameter.k);
            return i != -1 ? java.util.Optional.of(operands().get(1 + i)) : java.util.Optional.empty();
        }

        public java.util.Optional<Long> upper() {
            Long upper = Attribute.upper.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(upper);
        }

    }

    public static Trilu Trilu(TypeElement resultType, Value input, java.util.Optional<Value> k, java.util.Optional<Long> upper) {
        return new Trilu(resultType, input, k, upper);
    }

    @OpFactoryHelper.OpDeclaration(Unique.NAME)
    public static final class Unique extends OnnxOp {
        public static final String NAME = "Unique";

        public enum Attribute implements OnnxAttribute {
            sorted(Long.class, true, 1),
            axis(Long.class, true, null),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            indices(OnnxType.tensor(OnnxType.int64()), Quantifier.OPTIONAL),
            inverse_indices(OnnxType.tensor(OnnxType.int64()), Quantifier.OPTIONAL),
            counts(OnnxType.tensor(OnnxType.int64()), Quantifier.OPTIONAL),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public Unique(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        Unique(Unique that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public Unique transform(CopyContext cc, OpTransformer ot) {
            return new Unique(this, cc);
        }

        Unique(TypeElement resultType, Set<OutputParameter> optionalOutputs, Value X, java.util.Optional<Long> sorted, java.util.Optional<Long> axis) {
            super(SCHEMA, resultType, optionalOutputs, List.of(X), List.of(sorted, axis));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X()));
        }

        public Value X() {
            return operands().get(0);
        }

        public java.util.Optional<Long> sorted() {
            Long sorted = Attribute.sorted.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(sorted);
        }

        public java.util.Optional<Long> axis() {
            Long axis = Attribute.axis.access(Long.class, onnxAttributes);
            return java.util.Optional.ofNullable(axis);
        }

    }

    public static Unique Unique(TypeElement resultType, Set<Unique.OutputParameter> optionalOutputs, Value X, java.util.Optional<Long> sorted, java.util.Optional<Long> axis) {
        return new Unique(resultType, optionalOutputs, X, sorted, axis);
    }

    @OpFactoryHelper.OpDeclaration(Unsqueeze.NAME)
    public static final class Unsqueeze extends OnnxOp {
        public static final String NAME = "Unsqueeze";

        public enum Attribute implements OnnxAttribute.None { }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128()), OnnxType.tensor(OnnxType.float8e4m3fn()), OnnxType.tensor(OnnxType.float8e4m3fnuz()), OnnxType.tensor(OnnxType.float8e5m2()), OnnxType.tensor(OnnxType.float8e5m2fnuz()), OnnxType.tensor(OnnxType.uint4()), OnnxType.tensor(OnnxType.int4()), OnnxType.tensor(OnnxType.float4e2m1())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            data(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            axes(OnnxType.tensor(OnnxType.int64()), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            expanded(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public Unsqueeze(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        Unsqueeze(Unsqueeze that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public Unsqueeze transform(CopyContext cc, OpTransformer ot) {
            return new Unsqueeze(this, cc);
        }

        Unsqueeze(TypeElement resultType, Value data, Value axes) {
            super(SCHEMA, resultType, Set.of(), List.of(data, axes), List.of());
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(data(), axes()));
        }

        public Value data() {
            return operands().get(0);
        }

        public Value axes() {
            return operands().get(1);
        }

    }

    public static Unsqueeze Unsqueeze(TypeElement resultType, Value data, Value axes) {
        return new Unsqueeze(resultType, data, axes);
    }

    @OpFactoryHelper.OpDeclaration(Upsample.NAME)
    public static final class Upsample extends OnnxOp {
        public static final String NAME = "Upsample";

        public enum Attribute implements OnnxAttribute {
            mode(String.class, true, "nearest"),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            scales(OnnxType.tensor(OnnxType.float32()), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public Upsample(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        Upsample(Upsample that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public Upsample transform(CopyContext cc, OpTransformer ot) {
            return new Upsample(this, cc);
        }

        Upsample(TypeElement resultType, Value X, Value scales, java.util.Optional<String> mode) {
            super(SCHEMA, resultType, Set.of(), List.of(X, scales), List.of(mode));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X(), scales()));
        }

        public Value X() {
            return operands().get(0);
        }

        public Value scales() {
            return operands().get(1);
        }

        public java.util.Optional<String> mode() {
            String mode = Attribute.mode.access(String.class, onnxAttributes);
            return java.util.Optional.ofNullable(mode);
        }

    }

    public static Upsample Upsample(TypeElement resultType, Value X, Value scales, java.util.Optional<String> mode) {
        return new Upsample(resultType, X, scales, mode);
    }

    @OpFactoryHelper.OpDeclaration(Where.NAME)
    public static final class Where extends OnnxOp {
        public static final String NAME = "Where";

        public enum Attribute implements OnnxAttribute.None { }

        public enum TypeConstraint implements OnnxTypeConstraint {
            B(new OnnxType.TypeVariable("B", List.of(OnnxType.tensor(OnnxType.bool())))),
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            condition(TypeConstraint.B.typeVariable(), Quantifier.REQUIRED),
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public Where(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        Where(Where that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public Where transform(CopyContext cc, OpTransformer ot) {
            return new Where(this, cc);
        }

        Where(TypeElement resultType, Value condition, Value X, Value Y) {
            super(SCHEMA, resultType, Set.of(), List.of(condition, X, Y), List.of());
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(condition(), X(), Y()));
        }

        public Value condition() {
            return operands().get(0);
        }

        public Value X() {
            return operands().get(1);
        }

        public Value Y() {
            return operands().get(2);
        }

    }

    public static Where Where(TypeElement resultType, Value condition, Value X, Value Y) {
        return new Where(resultType, condition, X, Y);
    }

    @OpFactoryHelper.OpDeclaration(Xor.NAME)
    public static final class Xor extends OnnxOp {
        public static final String NAME = "Xor";

        public enum Attribute implements OnnxAttribute.None { }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.tensor(OnnxType.bool())))),
            T1(new OnnxType.TypeVariable("T1", List.of(OnnxType.tensor(OnnxType.bool())))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            A(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            B(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            C(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public Xor(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        Xor(Xor that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public Xor transform(CopyContext cc, OpTransformer ot) {
            return new Xor(this, cc);
        }

        Xor(TypeElement resultType, Value A, Value B) {
            super(SCHEMA, resultType, Set.of(), List.of(A, B), List.of());
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(A(), B()));
        }

        public Value A() {
            return operands().get(0);
        }

        public Value B() {
            return operands().get(1);
        }

    }

    public static Xor Xor(TypeElement resultType, Value A, Value B) {
        return new Xor(resultType, A, B);
    }

    @OpFactoryHelper.OpDeclaration(ZipMap.NAME)
    public static final class ZipMap extends OnnxOp {
        public static final String NAME = "ZipMap";

        public enum Attribute implements OnnxAttribute {
            classlabels_int64s(long[].class, true, null),
            classlabels_strings(String[].class, true, null),
            ;

                final Class<?> t;
                final boolean optional;
                final Object defaultValue;

                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }

                public Class<?> type() {
                    return t;
                }

                public boolean isOptional() {
                    return optional;
                }

                public Object defaultValue() {
                    return defaultValue;
                }
        }

        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(OnnxType.seq(OnnxType.map(OnnxType.string(), OnnxType.float32())), OnnxType.seq(OnnxType.map(OnnxType.int64(), OnnxType.float32()))))),
            ;

            final OnnxType.TypeVariable typeVariable;

            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }

            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }

        public enum InputParameter implements OnnxParameter {
            X(OnnxType.tensor(OnnxType.float32()), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public enum OutputParameter implements OnnxParameter {
            Z(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;

            final OnnxType type;
            final Quantifier quantifier;

            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }

            @Override
            public OnnxType type() {
                return type;
            }

            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }

        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );

        public ZipMap(ExternalizedOp def) {
            super(SCHEMA, def);
        }

        ZipMap(ZipMap that, CopyContext cc) {
            super(that, cc);
        }

        @Override
        public ZipMap transform(CopyContext cc, OpTransformer ot) {
            return new ZipMap(this, cc);
        }

        ZipMap(TypeElement resultType, Value X, java.util.Optional<long[]> classlabels_int64s, java.util.Optional<String[]> classlabels_strings) {
            super(SCHEMA, resultType, Set.of(), List.of(X), List.of(classlabels_int64s, classlabels_strings));
        }

        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }

        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X()));
        }

        public Value X() {
            return operands().get(0);
        }

        public java.util.Optional<long[]> classlabels_int64s() {
            long[] classlabels_int64s = Attribute.classlabels_int64s.access(long[].class, onnxAttributes);
            return java.util.Optional.ofNullable(classlabels_int64s).map(long[]::clone);
        }

        public java.util.Optional<String[]> classlabels_strings() {
            String[] classlabels_strings = Attribute.classlabels_strings.access(String[].class, onnxAttributes);
            return java.util.Optional.ofNullable(classlabels_strings).map(String[]::clone);
        }

    }

    public static ZipMap ZipMap(TypeElement resultType, Value X, java.util.Optional<long[]> classlabels_int64s, java.util.Optional<String[]> classlabels_strings) {
        return new ZipMap(resultType, X, classlabels_int64s, classlabels_strings);
    }

}
