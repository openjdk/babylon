// Auto-generated from ONNX op schema

package oracle.code.onnx.ir;

import jdk.incubator.code.*;
import jdk.incubator.code.op.OpFactory;
import oracle.code.onnx.Tensor;

import java.util.*;

@SuppressWarnings({"OptionalUsedAsFieldOrParameterType", "unused", "SequencedCollectionMethodCanBeUsed"})
public final class OnnxOps {
    
    private OnnxOps() {}
    
    @OpFactory.OpDeclaration(Abs.NAME)
    public static final class Abs extends OnnxOp {
        public static final String NAME = "Abs";
        
        public enum Attribute implements OnnxAttribute.None { }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<uint8>, tensor<uint16>, tensor<uint32>, tensor<uint64>, tensor<int8>, tensor<int16>, tensor<int32>, tensor<int64>, tensor<float16>, tensor<float>, tensor<double>, tensor<bfloat16>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public Abs(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        Abs(Abs that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public Abs transform(CopyContext cc, OpTransformer ot) {
            return new Abs(this, cc);
        }
        
        Abs(TypeElement resultType, Value X) {
            super(SCHEMA, resultType, Set.of(), List.of(X), List.of());
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X()));
        }
        
        public Value X() {
            return operands().get(0);
        }
        
    }
    
    public static Abs Abs(TypeElement resultType, Value X) {
        return new Abs(resultType, X);
    }

    @OpFactory.OpDeclaration(Acos.NAME)
    public static final class Acos extends OnnxOp {
        public static final String NAME = "Acos";
        
        public enum Attribute implements OnnxAttribute.None { }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<bfloat16>, tensor<float16>, tensor<float>, tensor<double>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            input(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public Acos(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        Acos(Acos that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public Acos transform(CopyContext cc, OpTransformer ot) {
            return new Acos(this, cc);
        }
        
        Acos(TypeElement resultType, Value input) {
            super(SCHEMA, resultType, Set.of(), List.of(input), List.of());
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(input()));
        }
        
        public Value input() {
            return operands().get(0);
        }
        
    }
    
    public static Acos Acos(TypeElement resultType, Value input) {
        return new Acos(resultType, input);
    }

    @OpFactory.OpDeclaration(Acosh.NAME)
    public static final class Acosh extends OnnxOp {
        public static final String NAME = "Acosh";
        
        public enum Attribute implements OnnxAttribute.None { }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<bfloat16>, tensor<float16>, tensor<float>, tensor<double>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            input(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public Acosh(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        Acosh(Acosh that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public Acosh transform(CopyContext cc, OpTransformer ot) {
            return new Acosh(this, cc);
        }
        
        Acosh(TypeElement resultType, Value input) {
            super(SCHEMA, resultType, Set.of(), List.of(input), List.of());
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(input()));
        }
        
        public Value input() {
            return operands().get(0);
        }
        
    }
    
    public static Acosh Acosh(TypeElement resultType, Value input) {
        return new Acosh(resultType, input);
    }

    @OpFactory.OpDeclaration(Adagrad.NAME)
    public static final class Adagrad extends OnnxOp {
        public static final String NAME = "Adagrad";
        
        public enum Attribute implements OnnxAttribute {
            epsilon(Float.class, true, null),
            decay_factor(Float.class, true, null),
            norm_coefficient(Float.class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T1(new OnnxType.TypeVariable("T1", List.of(/* @@@ [tensor<float>, tensor<double>] */))),
            T2(new OnnxType.TypeVariable("T2", List.of(/* @@@ [tensor<int64>] */))),
            T3(new OnnxType.TypeVariable("T3", List.of(/* @@@ [tensor<float>, tensor<double>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            R(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            T(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),
            inputs(TypeConstraint.T3.typeVariable(), Quantifier.VARIADIC),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            outputs(TypeConstraint.T3.typeVariable(), Quantifier.VARIADIC),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public Adagrad(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        Adagrad(Adagrad that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public Adagrad transform(CopyContext cc, OpTransformer ot) {
            return new Adagrad(this, cc);
        }
        
        Adagrad(TypeElement resultType, Value R, Value T, List<Value> inputs, java.util.Optional<Float> epsilon, java.util.Optional<Float> decay_factor, java.util.Optional<Float> norm_coefficient) {
            super(SCHEMA, resultType, Set.of(), List.of(R, T, inputs), List.of(epsilon, decay_factor, norm_coefficient));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(R(), T(), inputs()));
        }
        
        public Value R() {
            return operands().get(0);
        }
        
        public Value T() {
            return operands().get(1);
        }
        
        public List<Value> inputs() {
            return operands().subList(2, operands().size());
        }
        
        public java.util.Optional<Float> epsilon() {
            Float epsilon = Attribute.epsilon.access(Float.class, onnxAttributes);
            return java.util.Optional.ofNullable(epsilon);
        }
        
        public java.util.Optional<Float> decay_factor() {
            Float decay_factor = Attribute.decay_factor.access(Float.class, onnxAttributes);
            return java.util.Optional.ofNullable(decay_factor);
        }
        
        public java.util.Optional<Float> norm_coefficient() {
            Float norm_coefficient = Attribute.norm_coefficient.access(Float.class, onnxAttributes);
            return java.util.Optional.ofNullable(norm_coefficient);
        }
        
    }
    
    public static Adagrad Adagrad(TypeElement resultType, Value R, Value T, List<Value> inputs, java.util.Optional<Float> epsilon, java.util.Optional<Float> decay_factor, java.util.Optional<Float> norm_coefficient) {
        return new Adagrad(resultType, R, T, inputs, epsilon, decay_factor, norm_coefficient);
    }

    @OpFactory.OpDeclaration(Adam.NAME)
    public static final class Adam extends OnnxOp {
        public static final String NAME = "Adam";
        
        public enum Attribute implements OnnxAttribute {
            epsilon(Float.class, true, null),
            norm_coefficient_post(Float.class, true, null),
            norm_coefficient(Float.class, true, null),
            alpha(Float.class, true, null),
            beta(Float.class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T1(new OnnxType.TypeVariable("T1", List.of(/* @@@ [tensor<float>, tensor<double>] */))),
            T2(new OnnxType.TypeVariable("T2", List.of(/* @@@ [tensor<int64>] */))),
            T3(new OnnxType.TypeVariable("T3", List.of(/* @@@ [tensor<float>, tensor<double>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            R(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            T(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),
            inputs(TypeConstraint.T3.typeVariable(), Quantifier.VARIADIC),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            outputs(TypeConstraint.T3.typeVariable(), Quantifier.VARIADIC),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public Adam(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        Adam(Adam that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public Adam transform(CopyContext cc, OpTransformer ot) {
            return new Adam(this, cc);
        }
        
        Adam(TypeElement resultType, Value R, Value T, List<Value> inputs, java.util.Optional<Float> epsilon, java.util.Optional<Float> norm_coefficient_post, java.util.Optional<Float> norm_coefficient, java.util.Optional<Float> alpha, java.util.Optional<Float> beta) {
            super(SCHEMA, resultType, Set.of(), List.of(R, T, inputs), List.of(epsilon, norm_coefficient_post, norm_coefficient, alpha, beta));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(R(), T(), inputs()));
        }
        
        public Value R() {
            return operands().get(0);
        }
        
        public Value T() {
            return operands().get(1);
        }
        
        public List<Value> inputs() {
            return operands().subList(2, operands().size());
        }
        
        public java.util.Optional<Float> epsilon() {
            Float epsilon = Attribute.epsilon.access(Float.class, onnxAttributes);
            return java.util.Optional.ofNullable(epsilon);
        }
        
        public java.util.Optional<Float> norm_coefficient_post() {
            Float norm_coefficient_post = Attribute.norm_coefficient_post.access(Float.class, onnxAttributes);
            return java.util.Optional.ofNullable(norm_coefficient_post);
        }
        
        public java.util.Optional<Float> norm_coefficient() {
            Float norm_coefficient = Attribute.norm_coefficient.access(Float.class, onnxAttributes);
            return java.util.Optional.ofNullable(norm_coefficient);
        }
        
        public java.util.Optional<Float> alpha() {
            Float alpha = Attribute.alpha.access(Float.class, onnxAttributes);
            return java.util.Optional.ofNullable(alpha);
        }
        
        public java.util.Optional<Float> beta() {
            Float beta = Attribute.beta.access(Float.class, onnxAttributes);
            return java.util.Optional.ofNullable(beta);
        }
        
    }
    
    public static Adam Adam(TypeElement resultType, Value R, Value T, List<Value> inputs, java.util.Optional<Float> epsilon, java.util.Optional<Float> norm_coefficient_post, java.util.Optional<Float> norm_coefficient, java.util.Optional<Float> alpha, java.util.Optional<Float> beta) {
        return new Adam(resultType, R, T, inputs, epsilon, norm_coefficient_post, norm_coefficient, alpha, beta);
    }

    @OpFactory.OpDeclaration(Add.NAME)
    public static final class Add extends OnnxOp {
        public static final String NAME = "Add";
        
        public enum Attribute implements OnnxAttribute.None { }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<uint8>, tensor<uint16>, tensor<uint32>, tensor<uint64>, tensor<int8>, tensor<int16>, tensor<int32>, tensor<int64>, tensor<float16>, tensor<float>, tensor<double>, tensor<bfloat16>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            A(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            B(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            C(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public Add(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        Add(Add that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public Add transform(CopyContext cc, OpTransformer ot) {
            return new Add(this, cc);
        }
        
        Add(TypeElement resultType, Value A, Value B) {
            super(SCHEMA, resultType, Set.of(), List.of(A, B), List.of());
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(A(), B()));
        }
        
        public Value A() {
            return operands().get(0);
        }
        
        public Value B() {
            return operands().get(1);
        }
        
    }
    
    public static Add Add(TypeElement resultType, Value A, Value B) {
        return new Add(resultType, A, B);
    }

    @OpFactory.OpDeclaration(AffineGrid.NAME)
    public static final class AffineGrid extends OnnxOp {
        public static final String NAME = "AffineGrid";
        
        public enum Attribute implements OnnxAttribute {
            align_corners(Integer.class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T1(new OnnxType.TypeVariable("T1", List.of(/* @@@ [tensor<bfloat16>, tensor<float16>, tensor<float>, tensor<double>] */))),
            T2(new OnnxType.TypeVariable("T2", List.of(/* @@@ [tensor<int64>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            theta(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            size(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            grid(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public AffineGrid(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        AffineGrid(AffineGrid that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public AffineGrid transform(CopyContext cc, OpTransformer ot) {
            return new AffineGrid(this, cc);
        }
        
        AffineGrid(TypeElement resultType, Value theta, Value size, java.util.Optional<Integer> align_corners) {
            super(SCHEMA, resultType, Set.of(), List.of(theta, size), List.of(align_corners));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(theta(), size()));
        }
        
        public Value theta() {
            return operands().get(0);
        }
        
        public Value size() {
            return operands().get(1);
        }
        
        public java.util.Optional<Integer> align_corners() {
            Integer align_corners = Attribute.align_corners.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(align_corners);
        }
        
    }
    
    public static AffineGrid AffineGrid(TypeElement resultType, Value theta, Value size, java.util.Optional<Integer> align_corners) {
        return new AffineGrid(resultType, theta, size, align_corners);
    }

    @OpFactory.OpDeclaration(And.NAME)
    public static final class And extends OnnxOp {
        public static final String NAME = "And";
        
        public enum Attribute implements OnnxAttribute.None { }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<bool>] */))),
            T1(new OnnxType.TypeVariable("T1", List.of(/* @@@ [tensor<bool>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            A(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            B(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            C(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public And(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        And(And that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public And transform(CopyContext cc, OpTransformer ot) {
            return new And(this, cc);
        }
        
        And(TypeElement resultType, Value A, Value B) {
            super(SCHEMA, resultType, Set.of(), List.of(A, B), List.of());
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(A(), B()));
        }
        
        public Value A() {
            return operands().get(0);
        }
        
        public Value B() {
            return operands().get(1);
        }
        
    }
    
    public static And And(TypeElement resultType, Value A, Value B) {
        return new And(resultType, A, B);
    }

    @OpFactory.OpDeclaration(ArgMax.NAME)
    public static final class ArgMax extends OnnxOp {
        public static final String NAME = "ArgMax";
        
        public enum Attribute implements OnnxAttribute {
            keepdims(Integer.class, true, null),
            select_last_index(Integer.class, true, null),
            axis(Integer.class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<uint8>, tensor<uint16>, tensor<uint32>, tensor<uint64>, tensor<int8>, tensor<int16>, tensor<int32>, tensor<int64>, tensor<float16>, tensor<float>, tensor<double>, tensor<bfloat16>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            data(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            reduced(null /* @@@ tensor<int64> */, Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public ArgMax(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        ArgMax(ArgMax that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public ArgMax transform(CopyContext cc, OpTransformer ot) {
            return new ArgMax(this, cc);
        }
        
        ArgMax(TypeElement resultType, Value data, java.util.Optional<Integer> keepdims, java.util.Optional<Integer> select_last_index, java.util.Optional<Integer> axis) {
            super(SCHEMA, resultType, Set.of(), List.of(data), List.of(keepdims, select_last_index, axis));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(data()));
        }
        
        public Value data() {
            return operands().get(0);
        }
        
        public java.util.Optional<Integer> keepdims() {
            Integer keepdims = Attribute.keepdims.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(keepdims);
        }
        
        public java.util.Optional<Integer> select_last_index() {
            Integer select_last_index = Attribute.select_last_index.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(select_last_index);
        }
        
        public java.util.Optional<Integer> axis() {
            Integer axis = Attribute.axis.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(axis);
        }
        
    }
    
    public static ArgMax ArgMax(TypeElement resultType, Value data, java.util.Optional<Integer> keepdims, java.util.Optional<Integer> select_last_index, java.util.Optional<Integer> axis) {
        return new ArgMax(resultType, data, keepdims, select_last_index, axis);
    }

    @OpFactory.OpDeclaration(ArgMin.NAME)
    public static final class ArgMin extends OnnxOp {
        public static final String NAME = "ArgMin";
        
        public enum Attribute implements OnnxAttribute {
            keepdims(Integer.class, true, null),
            select_last_index(Integer.class, true, null),
            axis(Integer.class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<uint8>, tensor<uint16>, tensor<uint32>, tensor<uint64>, tensor<int8>, tensor<int16>, tensor<int32>, tensor<int64>, tensor<float16>, tensor<float>, tensor<double>, tensor<bfloat16>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            data(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            reduced(null /* @@@ tensor<int64> */, Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public ArgMin(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        ArgMin(ArgMin that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public ArgMin transform(CopyContext cc, OpTransformer ot) {
            return new ArgMin(this, cc);
        }
        
        ArgMin(TypeElement resultType, Value data, java.util.Optional<Integer> keepdims, java.util.Optional<Integer> select_last_index, java.util.Optional<Integer> axis) {
            super(SCHEMA, resultType, Set.of(), List.of(data), List.of(keepdims, select_last_index, axis));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(data()));
        }
        
        public Value data() {
            return operands().get(0);
        }
        
        public java.util.Optional<Integer> keepdims() {
            Integer keepdims = Attribute.keepdims.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(keepdims);
        }
        
        public java.util.Optional<Integer> select_last_index() {
            Integer select_last_index = Attribute.select_last_index.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(select_last_index);
        }
        
        public java.util.Optional<Integer> axis() {
            Integer axis = Attribute.axis.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(axis);
        }
        
    }
    
    public static ArgMin ArgMin(TypeElement resultType, Value data, java.util.Optional<Integer> keepdims, java.util.Optional<Integer> select_last_index, java.util.Optional<Integer> axis) {
        return new ArgMin(resultType, data, keepdims, select_last_index, axis);
    }

    @OpFactory.OpDeclaration(ArrayFeatureExtractor.NAME)
    public static final class ArrayFeatureExtractor extends OnnxOp {
        public static final String NAME = "ArrayFeatureExtractor";
        
        public enum Attribute implements OnnxAttribute.None { }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<float>, tensor<double>, tensor<int64>, tensor<int32>, tensor<string>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            Y(null /* @@@ tensor<int64> */, Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            Z(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public ArrayFeatureExtractor(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        ArrayFeatureExtractor(ArrayFeatureExtractor that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public ArrayFeatureExtractor transform(CopyContext cc, OpTransformer ot) {
            return new ArrayFeatureExtractor(this, cc);
        }
        
        ArrayFeatureExtractor(TypeElement resultType, Value X, Value Y) {
            super(SCHEMA, resultType, Set.of(), List.of(X, Y), List.of());
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X(), Y()));
        }
        
        public Value X() {
            return operands().get(0);
        }
        
        public Value Y() {
            return operands().get(1);
        }
        
    }
    
    public static ArrayFeatureExtractor ArrayFeatureExtractor(TypeElement resultType, Value X, Value Y) {
        return new ArrayFeatureExtractor(resultType, X, Y);
    }

    @OpFactory.OpDeclaration(Asin.NAME)
    public static final class Asin extends OnnxOp {
        public static final String NAME = "Asin";
        
        public enum Attribute implements OnnxAttribute.None { }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<bfloat16>, tensor<float16>, tensor<float>, tensor<double>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            input(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public Asin(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        Asin(Asin that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public Asin transform(CopyContext cc, OpTransformer ot) {
            return new Asin(this, cc);
        }
        
        Asin(TypeElement resultType, Value input) {
            super(SCHEMA, resultType, Set.of(), List.of(input), List.of());
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(input()));
        }
        
        public Value input() {
            return operands().get(0);
        }
        
    }
    
    public static Asin Asin(TypeElement resultType, Value input) {
        return new Asin(resultType, input);
    }

    @OpFactory.OpDeclaration(Asinh.NAME)
    public static final class Asinh extends OnnxOp {
        public static final String NAME = "Asinh";
        
        public enum Attribute implements OnnxAttribute.None { }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<bfloat16>, tensor<float16>, tensor<float>, tensor<double>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            input(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public Asinh(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        Asinh(Asinh that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public Asinh transform(CopyContext cc, OpTransformer ot) {
            return new Asinh(this, cc);
        }
        
        Asinh(TypeElement resultType, Value input) {
            super(SCHEMA, resultType, Set.of(), List.of(input), List.of());
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(input()));
        }
        
        public Value input() {
            return operands().get(0);
        }
        
    }
    
    public static Asinh Asinh(TypeElement resultType, Value input) {
        return new Asinh(resultType, input);
    }

    @OpFactory.OpDeclaration(Atan.NAME)
    public static final class Atan extends OnnxOp {
        public static final String NAME = "Atan";
        
        public enum Attribute implements OnnxAttribute.None { }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<bfloat16>, tensor<float16>, tensor<float>, tensor<double>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            input(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public Atan(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        Atan(Atan that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public Atan transform(CopyContext cc, OpTransformer ot) {
            return new Atan(this, cc);
        }
        
        Atan(TypeElement resultType, Value input) {
            super(SCHEMA, resultType, Set.of(), List.of(input), List.of());
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(input()));
        }
        
        public Value input() {
            return operands().get(0);
        }
        
    }
    
    public static Atan Atan(TypeElement resultType, Value input) {
        return new Atan(resultType, input);
    }

    @OpFactory.OpDeclaration(Atanh.NAME)
    public static final class Atanh extends OnnxOp {
        public static final String NAME = "Atanh";
        
        public enum Attribute implements OnnxAttribute.None { }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<bfloat16>, tensor<float16>, tensor<float>, tensor<double>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            input(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public Atanh(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        Atanh(Atanh that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public Atanh transform(CopyContext cc, OpTransformer ot) {
            return new Atanh(this, cc);
        }
        
        Atanh(TypeElement resultType, Value input) {
            super(SCHEMA, resultType, Set.of(), List.of(input), List.of());
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(input()));
        }
        
        public Value input() {
            return operands().get(0);
        }
        
    }
    
    public static Atanh Atanh(TypeElement resultType, Value input) {
        return new Atanh(resultType, input);
    }

    @OpFactory.OpDeclaration(AveragePool.NAME)
    public static final class AveragePool extends OnnxOp {
        public static final String NAME = "AveragePool";
        
        public enum Attribute implements OnnxAttribute {
            pads(int[].class, true, null),
            dilations(int[].class, true, null),
            auto_pad(String.class, true, null),
            count_include_pad(Integer.class, true, null),
            ceil_mode(Integer.class, true, null),
            strides(int[].class, true, null),
            kernel_shape(int[].class, false, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<bfloat16>, tensor<float16>, tensor<float>, tensor<double>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public AveragePool(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        AveragePool(AveragePool that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public AveragePool transform(CopyContext cc, OpTransformer ot) {
            return new AveragePool(this, cc);
        }
        
        AveragePool(TypeElement resultType, Value X, java.util.Optional<int[]> pads, java.util.Optional<int[]> dilations, java.util.Optional<String> auto_pad, java.util.Optional<Integer> count_include_pad, java.util.Optional<Integer> ceil_mode, java.util.Optional<int[]> strides, int[] kernel_shape) {
            super(SCHEMA, resultType, Set.of(), List.of(X), List.of(pads, dilations, auto_pad, count_include_pad, ceil_mode, strides, kernel_shape));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X()));
        }
        
        public Value X() {
            return operands().get(0);
        }
        
        public java.util.Optional<int[]> pads() {
            int[] pads = Attribute.pads.access(int[].class, onnxAttributes);
            return java.util.Optional.ofNullable(pads).map(int[]::clone);
        }
        
        public java.util.Optional<int[]> dilations() {
            int[] dilations = Attribute.dilations.access(int[].class, onnxAttributes);
            return java.util.Optional.ofNullable(dilations).map(int[]::clone);
        }
        
        public java.util.Optional<String> auto_pad() {
            String auto_pad = Attribute.auto_pad.access(String.class, onnxAttributes);
            return java.util.Optional.ofNullable(auto_pad);
        }
        
        public java.util.Optional<Integer> count_include_pad() {
            Integer count_include_pad = Attribute.count_include_pad.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(count_include_pad);
        }
        
        public java.util.Optional<Integer> ceil_mode() {
            Integer ceil_mode = Attribute.ceil_mode.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(ceil_mode);
        }
        
        public java.util.Optional<int[]> strides() {
            int[] strides = Attribute.strides.access(int[].class, onnxAttributes);
            return java.util.Optional.ofNullable(strides).map(int[]::clone);
        }
        
        public int[] kernel_shape() {
            int[] kernel_shape = Attribute.kernel_shape.access(int[].class, onnxAttributes);
            return kernel_shape.clone();
        }
        
    }
    
    public static AveragePool AveragePool(TypeElement resultType, Value X, java.util.Optional<int[]> pads, java.util.Optional<int[]> dilations, java.util.Optional<String> auto_pad, java.util.Optional<Integer> count_include_pad, java.util.Optional<Integer> ceil_mode, java.util.Optional<int[]> strides, int[] kernel_shape) {
        return new AveragePool(resultType, X, pads, dilations, auto_pad, count_include_pad, ceil_mode, strides, kernel_shape);
    }

    @OpFactory.OpDeclaration(BatchNormalization.NAME)
    public static final class BatchNormalization extends OnnxOp {
        public static final String NAME = "BatchNormalization";
        
        public enum Attribute implements OnnxAttribute {
            epsilon(Float.class, true, null),
            training_mode(Integer.class, true, null),
            momentum(Float.class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<float16>, tensor<float>, tensor<double>, tensor<bfloat16>] */))),
            T1(new OnnxType.TypeVariable("T1", List.of(/* @@@ [tensor<float16>, tensor<float>, tensor<double>, tensor<bfloat16>] */))),
            T2(new OnnxType.TypeVariable("T2", List.of(/* @@@ [tensor<float16>, tensor<float>, tensor<double>, tensor<bfloat16>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            scale(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            B(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            input_mean(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),
            input_var(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            running_mean(TypeConstraint.T2.typeVariable(), Quantifier.OPTIONAL),
            running_var(TypeConstraint.T2.typeVariable(), Quantifier.OPTIONAL),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public BatchNormalization(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        BatchNormalization(BatchNormalization that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public BatchNormalization transform(CopyContext cc, OpTransformer ot) {
            return new BatchNormalization(this, cc);
        }
        
        BatchNormalization(TypeElement resultType, Value X, Value scale, Value B, Value input_mean, Value input_var, java.util.Optional<Float> epsilon, java.util.Optional<Integer> training_mode, java.util.Optional<Float> momentum) {
            super(SCHEMA, resultType, Set.of(), List.of(X, scale, B, input_mean, input_var), List.of(epsilon, training_mode, momentum));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X(), scale(), B(), input_mean(), input_var()));
        }
        
        public Value X() {
            return operands().get(0);
        }
        
        public Value scale() {
            return operands().get(1);
        }
        
        public Value B() {
            return operands().get(2);
        }
        
        public Value input_mean() {
            return operands().get(3);
        }
        
        public Value input_var() {
            return operands().get(4);
        }
        
        public java.util.Optional<Float> epsilon() {
            Float epsilon = Attribute.epsilon.access(Float.class, onnxAttributes);
            return java.util.Optional.ofNullable(epsilon);
        }
        
        public java.util.Optional<Integer> training_mode() {
            Integer training_mode = Attribute.training_mode.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(training_mode);
        }
        
        public java.util.Optional<Float> momentum() {
            Float momentum = Attribute.momentum.access(Float.class, onnxAttributes);
            return java.util.Optional.ofNullable(momentum);
        }
        
    }
    
    public static BatchNormalization BatchNormalization(TypeElement resultType, Value X, Value scale, Value B, Value input_mean, Value input_var, java.util.Optional<Float> epsilon, java.util.Optional<Integer> training_mode, java.util.Optional<Float> momentum) {
        return new BatchNormalization(resultType, X, scale, B, input_mean, input_var, epsilon, training_mode, momentum);
    }

    @OpFactory.OpDeclaration(Bernoulli.NAME)
    public static final class Bernoulli extends OnnxOp {
        public static final String NAME = "Bernoulli";
        
        public enum Attribute implements OnnxAttribute {
            seed(Float.class, true, null),
            dtype(Integer.class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T1(new OnnxType.TypeVariable("T1", List.of(/* @@@ [tensor<bfloat16>, tensor<float16>, tensor<float>, tensor<double>] */))),
            T2(new OnnxType.TypeVariable("T2", List.of(/* @@@ [tensor<uint8>, tensor<uint16>, tensor<uint32>, tensor<uint64>, tensor<int8>, tensor<int16>, tensor<int32>, tensor<int64>, tensor<bfloat16>, tensor<float16>, tensor<float>, tensor<double>, tensor<bool>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            input(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public Bernoulli(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        Bernoulli(Bernoulli that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public Bernoulli transform(CopyContext cc, OpTransformer ot) {
            return new Bernoulli(this, cc);
        }
        
        Bernoulli(TypeElement resultType, Value input, java.util.Optional<Float> seed, java.util.Optional<Integer> dtype) {
            super(SCHEMA, resultType, Set.of(), List.of(input), List.of(seed, dtype));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(input()));
        }
        
        public Value input() {
            return operands().get(0);
        }
        
        public java.util.Optional<Float> seed() {
            Float seed = Attribute.seed.access(Float.class, onnxAttributes);
            return java.util.Optional.ofNullable(seed);
        }
        
        public java.util.Optional<Integer> dtype() {
            Integer dtype = Attribute.dtype.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(dtype);
        }
        
    }
    
    public static Bernoulli Bernoulli(TypeElement resultType, Value input, java.util.Optional<Float> seed, java.util.Optional<Integer> dtype) {
        return new Bernoulli(resultType, input, seed, dtype);
    }

    @OpFactory.OpDeclaration(Binarizer.NAME)
    public static final class Binarizer extends OnnxOp {
        public static final String NAME = "Binarizer";
        
        public enum Attribute implements OnnxAttribute {
            threshold(Float.class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<float>, tensor<double>, tensor<int64>, tensor<int32>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public Binarizer(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        Binarizer(Binarizer that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public Binarizer transform(CopyContext cc, OpTransformer ot) {
            return new Binarizer(this, cc);
        }
        
        Binarizer(TypeElement resultType, Value X, java.util.Optional<Float> threshold) {
            super(SCHEMA, resultType, Set.of(), List.of(X), List.of(threshold));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X()));
        }
        
        public Value X() {
            return operands().get(0);
        }
        
        public java.util.Optional<Float> threshold() {
            Float threshold = Attribute.threshold.access(Float.class, onnxAttributes);
            return java.util.Optional.ofNullable(threshold);
        }
        
    }
    
    public static Binarizer Binarizer(TypeElement resultType, Value X, java.util.Optional<Float> threshold) {
        return new Binarizer(resultType, X, threshold);
    }

    @OpFactory.OpDeclaration(BitShift.NAME)
    public static final class BitShift extends OnnxOp {
        public static final String NAME = "BitShift";
        
        public enum Attribute implements OnnxAttribute {
            direction(String.class, false, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<uint8>, tensor<uint16>, tensor<uint32>, tensor<uint64>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            Z(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public BitShift(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        BitShift(BitShift that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public BitShift transform(CopyContext cc, OpTransformer ot) {
            return new BitShift(this, cc);
        }
        
        BitShift(TypeElement resultType, Value X, Value Y, String direction) {
            super(SCHEMA, resultType, Set.of(), List.of(X, Y), List.of(direction));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X(), Y()));
        }
        
        public Value X() {
            return operands().get(0);
        }
        
        public Value Y() {
            return operands().get(1);
        }
        
        public String direction() {
            String direction = Attribute.direction.access(String.class, onnxAttributes);
            return direction;
        }
        
    }
    
    public static BitShift BitShift(TypeElement resultType, Value X, Value Y, String direction) {
        return new BitShift(resultType, X, Y, direction);
    }

    @OpFactory.OpDeclaration(BitwiseAnd.NAME)
    public static final class BitwiseAnd extends OnnxOp {
        public static final String NAME = "BitwiseAnd";
        
        public enum Attribute implements OnnxAttribute.None { }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<uint8>, tensor<uint16>, tensor<uint32>, tensor<uint64>, tensor<int8>, tensor<int16>, tensor<int32>, tensor<int64>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            A(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            B(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            C(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public BitwiseAnd(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        BitwiseAnd(BitwiseAnd that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public BitwiseAnd transform(CopyContext cc, OpTransformer ot) {
            return new BitwiseAnd(this, cc);
        }
        
        BitwiseAnd(TypeElement resultType, Value A, Value B) {
            super(SCHEMA, resultType, Set.of(), List.of(A, B), List.of());
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(A(), B()));
        }
        
        public Value A() {
            return operands().get(0);
        }
        
        public Value B() {
            return operands().get(1);
        }
        
    }
    
    public static BitwiseAnd BitwiseAnd(TypeElement resultType, Value A, Value B) {
        return new BitwiseAnd(resultType, A, B);
    }

    @OpFactory.OpDeclaration(BitwiseNot.NAME)
    public static final class BitwiseNot extends OnnxOp {
        public static final String NAME = "BitwiseNot";
        
        public enum Attribute implements OnnxAttribute.None { }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<uint8>, tensor<uint16>, tensor<uint32>, tensor<uint64>, tensor<int8>, tensor<int16>, tensor<int32>, tensor<int64>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public BitwiseNot(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        BitwiseNot(BitwiseNot that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public BitwiseNot transform(CopyContext cc, OpTransformer ot) {
            return new BitwiseNot(this, cc);
        }
        
        BitwiseNot(TypeElement resultType, Value X) {
            super(SCHEMA, resultType, Set.of(), List.of(X), List.of());
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X()));
        }
        
        public Value X() {
            return operands().get(0);
        }
        
    }
    
    public static BitwiseNot BitwiseNot(TypeElement resultType, Value X) {
        return new BitwiseNot(resultType, X);
    }

    @OpFactory.OpDeclaration(BitwiseOr.NAME)
    public static final class BitwiseOr extends OnnxOp {
        public static final String NAME = "BitwiseOr";
        
        public enum Attribute implements OnnxAttribute.None { }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<uint8>, tensor<uint16>, tensor<uint32>, tensor<uint64>, tensor<int8>, tensor<int16>, tensor<int32>, tensor<int64>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            A(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            B(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            C(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public BitwiseOr(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        BitwiseOr(BitwiseOr that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public BitwiseOr transform(CopyContext cc, OpTransformer ot) {
            return new BitwiseOr(this, cc);
        }
        
        BitwiseOr(TypeElement resultType, Value A, Value B) {
            super(SCHEMA, resultType, Set.of(), List.of(A, B), List.of());
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(A(), B()));
        }
        
        public Value A() {
            return operands().get(0);
        }
        
        public Value B() {
            return operands().get(1);
        }
        
    }
    
    public static BitwiseOr BitwiseOr(TypeElement resultType, Value A, Value B) {
        return new BitwiseOr(resultType, A, B);
    }

    @OpFactory.OpDeclaration(BitwiseXor.NAME)
    public static final class BitwiseXor extends OnnxOp {
        public static final String NAME = "BitwiseXor";
        
        public enum Attribute implements OnnxAttribute.None { }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<uint8>, tensor<uint16>, tensor<uint32>, tensor<uint64>, tensor<int8>, tensor<int16>, tensor<int32>, tensor<int64>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            A(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            B(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            C(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public BitwiseXor(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        BitwiseXor(BitwiseXor that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public BitwiseXor transform(CopyContext cc, OpTransformer ot) {
            return new BitwiseXor(this, cc);
        }
        
        BitwiseXor(TypeElement resultType, Value A, Value B) {
            super(SCHEMA, resultType, Set.of(), List.of(A, B), List.of());
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(A(), B()));
        }
        
        public Value A() {
            return operands().get(0);
        }
        
        public Value B() {
            return operands().get(1);
        }
        
    }
    
    public static BitwiseXor BitwiseXor(TypeElement resultType, Value A, Value B) {
        return new BitwiseXor(resultType, A, B);
    }

    @OpFactory.OpDeclaration(BlackmanWindow.NAME)
    public static final class BlackmanWindow extends OnnxOp {
        public static final String NAME = "BlackmanWindow";
        
        public enum Attribute implements OnnxAttribute {
            periodic(Integer.class, true, null),
            output_datatype(Integer.class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T1(new OnnxType.TypeVariable("T1", List.of(/* @@@ [tensor<int32>, tensor<int64>] */))),
            T2(new OnnxType.TypeVariable("T2", List.of(/* @@@ [tensor<uint8>, tensor<uint16>, tensor<uint32>, tensor<uint64>, tensor<int8>, tensor<int16>, tensor<int32>, tensor<int64>, tensor<float16>, tensor<float>, tensor<double>, tensor<bfloat16>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            size(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public BlackmanWindow(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        BlackmanWindow(BlackmanWindow that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public BlackmanWindow transform(CopyContext cc, OpTransformer ot) {
            return new BlackmanWindow(this, cc);
        }
        
        BlackmanWindow(TypeElement resultType, Value size, java.util.Optional<Integer> periodic, java.util.Optional<Integer> output_datatype) {
            super(SCHEMA, resultType, Set.of(), List.of(size), List.of(periodic, output_datatype));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(size()));
        }
        
        public Value size() {
            return operands().get(0);
        }
        
        public java.util.Optional<Integer> periodic() {
            Integer periodic = Attribute.periodic.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(periodic);
        }
        
        public java.util.Optional<Integer> output_datatype() {
            Integer output_datatype = Attribute.output_datatype.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(output_datatype);
        }
        
    }
    
    public static BlackmanWindow BlackmanWindow(TypeElement resultType, Value size, java.util.Optional<Integer> periodic, java.util.Optional<Integer> output_datatype) {
        return new BlackmanWindow(resultType, size, periodic, output_datatype);
    }

    @OpFactory.OpDeclaration(Cast.NAME)
    public static final class Cast extends OnnxOp {
        public static final String NAME = "Cast";
        
        public enum Attribute implements OnnxAttribute {
            saturate(Integer.class, true, null),
            to(Integer.class, false, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T1(new OnnxType.TypeVariable("T1", List.of(/* @@@ [tensor<uint8>, tensor<uint16>, tensor<uint32>, tensor<uint64>, tensor<int8>, tensor<int16>, tensor<int32>, tensor<int64>, tensor<bfloat16>, tensor<float16>, tensor<float>, tensor<double>, tensor<string>, tensor<bool>, tensor<float8e4m3fn>, tensor<float8e4m3fnuz>, tensor<float8e5m2>, tensor<float8e5m2fnuz>, tensor<uint4>, tensor<int4>, tensor<float4e2m1>] */))),
            T2(new OnnxType.TypeVariable("T2", List.of(/* @@@ [tensor<uint8>, tensor<uint16>, tensor<uint32>, tensor<uint64>, tensor<int8>, tensor<int16>, tensor<int32>, tensor<int64>, tensor<bfloat16>, tensor<float16>, tensor<float>, tensor<double>, tensor<string>, tensor<bool>, tensor<float8e4m3fn>, tensor<float8e4m3fnuz>, tensor<float8e5m2>, tensor<float8e5m2fnuz>, tensor<uint4>, tensor<int4>, tensor<float4e2m1>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            input(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public Cast(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        Cast(Cast that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public Cast transform(CopyContext cc, OpTransformer ot) {
            return new Cast(this, cc);
        }
        
        Cast(TypeElement resultType, Value input, java.util.Optional<Integer> saturate, int to) {
            super(SCHEMA, resultType, Set.of(), List.of(input), List.of(saturate, to));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(input()));
        }
        
        public Value input() {
            return operands().get(0);
        }
        
        public java.util.Optional<Integer> saturate() {
            Integer saturate = Attribute.saturate.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(saturate);
        }
        
        public int to() {
            int to = Attribute.to.access(int.class, onnxAttributes);
            return to;
        }
        
    }
    
    public static Cast Cast(TypeElement resultType, Value input, java.util.Optional<Integer> saturate, int to) {
        return new Cast(resultType, input, saturate, to);
    }

    @OpFactory.OpDeclaration(CastLike.NAME)
    public static final class CastLike extends OnnxOp {
        public static final String NAME = "CastLike";
        
        public enum Attribute implements OnnxAttribute {
            saturate(Integer.class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T1(new OnnxType.TypeVariable("T1", List.of(/* @@@ [tensor<uint8>, tensor<uint16>, tensor<uint32>, tensor<uint64>, tensor<int8>, tensor<int16>, tensor<int32>, tensor<int64>, tensor<bfloat16>, tensor<float16>, tensor<float>, tensor<double>, tensor<string>, tensor<bool>, tensor<float8e4m3fn>, tensor<float8e4m3fnuz>, tensor<float8e5m2>, tensor<float8e5m2fnuz>, tensor<uint4>, tensor<int4>, tensor<float4e2m1>] */))),
            T2(new OnnxType.TypeVariable("T2", List.of(/* @@@ [tensor<uint8>, tensor<uint16>, tensor<uint32>, tensor<uint64>, tensor<int8>, tensor<int16>, tensor<int32>, tensor<int64>, tensor<bfloat16>, tensor<float16>, tensor<float>, tensor<double>, tensor<string>, tensor<bool>, tensor<float8e4m3fn>, tensor<float8e4m3fnuz>, tensor<float8e5m2>, tensor<float8e5m2fnuz>, tensor<uint4>, tensor<int4>, tensor<float4e2m1>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            input(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            target_type(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public CastLike(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        CastLike(CastLike that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public CastLike transform(CopyContext cc, OpTransformer ot) {
            return new CastLike(this, cc);
        }
        
        CastLike(TypeElement resultType, Value input, Value target_type, java.util.Optional<Integer> saturate) {
            super(SCHEMA, resultType, Set.of(), List.of(input, target_type), List.of(saturate));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(input(), target_type()));
        }
        
        public Value input() {
            return operands().get(0);
        }
        
        public Value target_type() {
            return operands().get(1);
        }
        
        public java.util.Optional<Integer> saturate() {
            Integer saturate = Attribute.saturate.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(saturate);
        }
        
    }
    
    public static CastLike CastLike(TypeElement resultType, Value input, Value target_type, java.util.Optional<Integer> saturate) {
        return new CastLike(resultType, input, target_type, saturate);
    }

    @OpFactory.OpDeclaration(CastMap.NAME)
    public static final class CastMap extends OnnxOp {
        public static final String NAME = "CastMap";
        
        public enum Attribute implements OnnxAttribute {
            map_form(String.class, true, null),
            cast_to(String.class, true, null),
            max_map(Integer.class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T1(new OnnxType.TypeVariable("T1", List.of(/* @@@ [map<int64, string>, map<int64, float>] */))),
            T2(new OnnxType.TypeVariable("T2", List.of(/* @@@ [tensor<string>, tensor<float>, tensor<int64>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public CastMap(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        CastMap(CastMap that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public CastMap transform(CopyContext cc, OpTransformer ot) {
            return new CastMap(this, cc);
        }
        
        CastMap(TypeElement resultType, Value X, java.util.Optional<String> map_form, java.util.Optional<String> cast_to, java.util.Optional<Integer> max_map) {
            super(SCHEMA, resultType, Set.of(), List.of(X), List.of(map_form, cast_to, max_map));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X()));
        }
        
        public Value X() {
            return operands().get(0);
        }
        
        public java.util.Optional<String> map_form() {
            String map_form = Attribute.map_form.access(String.class, onnxAttributes);
            return java.util.Optional.ofNullable(map_form);
        }
        
        public java.util.Optional<String> cast_to() {
            String cast_to = Attribute.cast_to.access(String.class, onnxAttributes);
            return java.util.Optional.ofNullable(cast_to);
        }
        
        public java.util.Optional<Integer> max_map() {
            Integer max_map = Attribute.max_map.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(max_map);
        }
        
    }
    
    public static CastMap CastMap(TypeElement resultType, Value X, java.util.Optional<String> map_form, java.util.Optional<String> cast_to, java.util.Optional<Integer> max_map) {
        return new CastMap(resultType, X, map_form, cast_to, max_map);
    }

    @OpFactory.OpDeclaration(CategoryMapper.NAME)
    public static final class CategoryMapper extends OnnxOp {
        public static final String NAME = "CategoryMapper";
        
        public enum Attribute implements OnnxAttribute {
            cats_int64s(int[].class, true, null),
            cats_strings(String[].class, true, null),
            default_int64(Integer.class, true, null),
            default_string(String.class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T1(new OnnxType.TypeVariable("T1", List.of(/* @@@ [tensor<string>, tensor<int64>] */))),
            T2(new OnnxType.TypeVariable("T2", List.of(/* @@@ [tensor<string>, tensor<int64>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public CategoryMapper(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        CategoryMapper(CategoryMapper that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public CategoryMapper transform(CopyContext cc, OpTransformer ot) {
            return new CategoryMapper(this, cc);
        }
        
        CategoryMapper(TypeElement resultType, Value X, java.util.Optional<int[]> cats_int64s, java.util.Optional<String[]> cats_strings, java.util.Optional<Integer> default_int64, java.util.Optional<String> default_string) {
            super(SCHEMA, resultType, Set.of(), List.of(X), List.of(cats_int64s, cats_strings, default_int64, default_string));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X()));
        }
        
        public Value X() {
            return operands().get(0);
        }
        
        public java.util.Optional<int[]> cats_int64s() {
            int[] cats_int64s = Attribute.cats_int64s.access(int[].class, onnxAttributes);
            return java.util.Optional.ofNullable(cats_int64s).map(int[]::clone);
        }
        
        public java.util.Optional<String[]> cats_strings() {
            String[] cats_strings = Attribute.cats_strings.access(String[].class, onnxAttributes);
            return java.util.Optional.ofNullable(cats_strings).map(String[]::clone);
        }
        
        public java.util.Optional<Integer> default_int64() {
            Integer default_int64 = Attribute.default_int64.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(default_int64);
        }
        
        public java.util.Optional<String> default_string() {
            String default_string = Attribute.default_string.access(String.class, onnxAttributes);
            return java.util.Optional.ofNullable(default_string);
        }
        
    }
    
    public static CategoryMapper CategoryMapper(TypeElement resultType, Value X, java.util.Optional<int[]> cats_int64s, java.util.Optional<String[]> cats_strings, java.util.Optional<Integer> default_int64, java.util.Optional<String> default_string) {
        return new CategoryMapper(resultType, X, cats_int64s, cats_strings, default_int64, default_string);
    }

    @OpFactory.OpDeclaration(Ceil.NAME)
    public static final class Ceil extends OnnxOp {
        public static final String NAME = "Ceil";
        
        public enum Attribute implements OnnxAttribute.None { }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<float16>, tensor<float>, tensor<double>, tensor<bfloat16>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public Ceil(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        Ceil(Ceil that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public Ceil transform(CopyContext cc, OpTransformer ot) {
            return new Ceil(this, cc);
        }
        
        Ceil(TypeElement resultType, Value X) {
            super(SCHEMA, resultType, Set.of(), List.of(X), List.of());
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X()));
        }
        
        public Value X() {
            return operands().get(0);
        }
        
    }
    
    public static Ceil Ceil(TypeElement resultType, Value X) {
        return new Ceil(resultType, X);
    }

    @OpFactory.OpDeclaration(Celu.NAME)
    public static final class Celu extends OnnxOp {
        public static final String NAME = "Celu";
        
        public enum Attribute implements OnnxAttribute {
            alpha(Float.class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<float>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public Celu(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        Celu(Celu that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public Celu transform(CopyContext cc, OpTransformer ot) {
            return new Celu(this, cc);
        }
        
        Celu(TypeElement resultType, Value X, java.util.Optional<Float> alpha) {
            super(SCHEMA, resultType, Set.of(), List.of(X), List.of(alpha));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X()));
        }
        
        public Value X() {
            return operands().get(0);
        }
        
        public java.util.Optional<Float> alpha() {
            Float alpha = Attribute.alpha.access(Float.class, onnxAttributes);
            return java.util.Optional.ofNullable(alpha);
        }
        
    }
    
    public static Celu Celu(TypeElement resultType, Value X, java.util.Optional<Float> alpha) {
        return new Celu(resultType, X, alpha);
    }

    @OpFactory.OpDeclaration(CenterCropPad.NAME)
    public static final class CenterCropPad extends OnnxOp {
        public static final String NAME = "CenterCropPad";
        
        public enum Attribute implements OnnxAttribute {
            axes(int[].class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<uint8>, tensor<uint16>, tensor<uint32>, tensor<uint64>, tensor<int8>, tensor<int16>, tensor<int32>, tensor<int64>, tensor<bfloat16>, tensor<float16>, tensor<float>, tensor<double>, tensor<string>, tensor<bool>, tensor<complex64>, tensor<complex128>] */))),
            Tind(new OnnxType.TypeVariable("Tind", List.of(/* @@@ [tensor<int32>, tensor<int64>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            input_data(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            shape(TypeConstraint.Tind.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            output_data(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public CenterCropPad(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        CenterCropPad(CenterCropPad that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public CenterCropPad transform(CopyContext cc, OpTransformer ot) {
            return new CenterCropPad(this, cc);
        }
        
        CenterCropPad(TypeElement resultType, Value input_data, Value shape, java.util.Optional<int[]> axes) {
            super(SCHEMA, resultType, Set.of(), List.of(input_data, shape), List.of(axes));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(input_data(), shape()));
        }
        
        public Value input_data() {
            return operands().get(0);
        }
        
        public Value shape() {
            return operands().get(1);
        }
        
        public java.util.Optional<int[]> axes() {
            int[] axes = Attribute.axes.access(int[].class, onnxAttributes);
            return java.util.Optional.ofNullable(axes).map(int[]::clone);
        }
        
    }
    
    public static CenterCropPad CenterCropPad(TypeElement resultType, Value input_data, Value shape, java.util.Optional<int[]> axes) {
        return new CenterCropPad(resultType, input_data, shape, axes);
    }

    @OpFactory.OpDeclaration(Clip.NAME)
    public static final class Clip extends OnnxOp {
        public static final String NAME = "Clip";
        
        public enum Attribute implements OnnxAttribute.None { }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<uint8>, tensor<uint16>, tensor<uint32>, tensor<uint64>, tensor<int8>, tensor<int16>, tensor<int32>, tensor<int64>, tensor<float16>, tensor<float>, tensor<double>, tensor<bfloat16>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            input(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            min(TypeConstraint.T.typeVariable(), Quantifier.OPTIONAL),
            max(TypeConstraint.T.typeVariable(), Quantifier.OPTIONAL),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public Clip(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        Clip(Clip that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public Clip transform(CopyContext cc, OpTransformer ot) {
            return new Clip(this, cc);
        }
        
        Clip(TypeElement resultType, Value input, java.util.Optional<Value> min, java.util.Optional<Value> max) {
            super(SCHEMA, resultType, Set.of(), List.of(input, min, max), List.of());
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(input(), min(), max()));
        }
        
        public Value input() {
            return operands().get(0);
        }
        
        public java.util.Optional<Value> min() {
            int i = optionalInputArguments.indexOf(InputParameter.min);
            return i != -1 ? java.util.Optional.of(operands().get(1 + i)) : java.util.Optional.empty();
        }
        
        public java.util.Optional<Value> max() {
            int i = optionalInputArguments.indexOf(InputParameter.max);
            return i != -1 ? java.util.Optional.of(operands().get(1 + i)) : java.util.Optional.empty();
        }
        
    }
    
    public static Clip Clip(TypeElement resultType, Value input, java.util.Optional<Value> min, java.util.Optional<Value> max) {
        return new Clip(resultType, input, min, max);
    }

    @OpFactory.OpDeclaration(Col2Im.NAME)
    public static final class Col2Im extends OnnxOp {
        public static final String NAME = "Col2Im";
        
        public enum Attribute implements OnnxAttribute {
            pads(int[].class, true, null),
            dilations(int[].class, true, null),
            strides(int[].class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<uint8>, tensor<uint16>, tensor<uint32>, tensor<uint64>, tensor<int8>, tensor<int16>, tensor<int32>, tensor<int64>, tensor<bfloat16>, tensor<float16>, tensor<float>, tensor<double>, tensor<string>, tensor<bool>, tensor<complex64>, tensor<complex128>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            input(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            image_shape(null /* @@@ tensor<int64> */, Quantifier.REQUIRED),
            block_shape(null /* @@@ tensor<int64> */, Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public Col2Im(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        Col2Im(Col2Im that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public Col2Im transform(CopyContext cc, OpTransformer ot) {
            return new Col2Im(this, cc);
        }
        
        Col2Im(TypeElement resultType, Value input, Value image_shape, Value block_shape, java.util.Optional<int[]> pads, java.util.Optional<int[]> dilations, java.util.Optional<int[]> strides) {
            super(SCHEMA, resultType, Set.of(), List.of(input, image_shape, block_shape), List.of(pads, dilations, strides));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(input(), image_shape(), block_shape()));
        }
        
        public Value input() {
            return operands().get(0);
        }
        
        public Value image_shape() {
            return operands().get(1);
        }
        
        public Value block_shape() {
            return operands().get(2);
        }
        
        public java.util.Optional<int[]> pads() {
            int[] pads = Attribute.pads.access(int[].class, onnxAttributes);
            return java.util.Optional.ofNullable(pads).map(int[]::clone);
        }
        
        public java.util.Optional<int[]> dilations() {
            int[] dilations = Attribute.dilations.access(int[].class, onnxAttributes);
            return java.util.Optional.ofNullable(dilations).map(int[]::clone);
        }
        
        public java.util.Optional<int[]> strides() {
            int[] strides = Attribute.strides.access(int[].class, onnxAttributes);
            return java.util.Optional.ofNullable(strides).map(int[]::clone);
        }
        
    }
    
    public static Col2Im Col2Im(TypeElement resultType, Value input, Value image_shape, Value block_shape, java.util.Optional<int[]> pads, java.util.Optional<int[]> dilations, java.util.Optional<int[]> strides) {
        return new Col2Im(resultType, input, image_shape, block_shape, pads, dilations, strides);
    }

    @OpFactory.OpDeclaration(Compress.NAME)
    public static final class Compress extends OnnxOp {
        public static final String NAME = "Compress";
        
        public enum Attribute implements OnnxAttribute {
            axis(Integer.class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<uint8>, tensor<uint16>, tensor<uint32>, tensor<uint64>, tensor<int8>, tensor<int16>, tensor<int32>, tensor<int64>, tensor<float16>, tensor<float>, tensor<double>, tensor<string>, tensor<bool>, tensor<complex64>, tensor<complex128>] */))),
            T1(new OnnxType.TypeVariable("T1", List.of(/* @@@ [tensor<bool>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            input(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            condition(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public Compress(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        Compress(Compress that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public Compress transform(CopyContext cc, OpTransformer ot) {
            return new Compress(this, cc);
        }
        
        Compress(TypeElement resultType, Value input, Value condition, java.util.Optional<Integer> axis) {
            super(SCHEMA, resultType, Set.of(), List.of(input, condition), List.of(axis));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(input(), condition()));
        }
        
        public Value input() {
            return operands().get(0);
        }
        
        public Value condition() {
            return operands().get(1);
        }
        
        public java.util.Optional<Integer> axis() {
            Integer axis = Attribute.axis.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(axis);
        }
        
    }
    
    public static Compress Compress(TypeElement resultType, Value input, Value condition, java.util.Optional<Integer> axis) {
        return new Compress(resultType, input, condition, axis);
    }

    @OpFactory.OpDeclaration(Concat.NAME)
    public static final class Concat extends OnnxOp {
        public static final String NAME = "Concat";
        
        public enum Attribute implements OnnxAttribute {
            axis(Integer.class, false, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<uint8>, tensor<uint16>, tensor<uint32>, tensor<uint64>, tensor<int8>, tensor<int16>, tensor<int32>, tensor<int64>, tensor<bfloat16>, tensor<float16>, tensor<float>, tensor<double>, tensor<string>, tensor<bool>, tensor<complex64>, tensor<complex128>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            inputs(TypeConstraint.T.typeVariable(), Quantifier.VARIADIC),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            concat_result(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public Concat(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        Concat(Concat that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public Concat transform(CopyContext cc, OpTransformer ot) {
            return new Concat(this, cc);
        }
        
        Concat(TypeElement resultType, List<Value> inputs, int axis) {
            super(SCHEMA, resultType, Set.of(), List.of(inputs), List.of(axis));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(inputs()));
        }
        
        public List<Value> inputs() {
            return operands();
        }
        
        public int axis() {
            int axis = Attribute.axis.access(int.class, onnxAttributes);
            return axis;
        }
        
    }
    
    public static Concat Concat(TypeElement resultType, List<Value> inputs, int axis) {
        return new Concat(resultType, inputs, axis);
    }

    @OpFactory.OpDeclaration(ConcatFromSequence.NAME)
    public static final class ConcatFromSequence extends OnnxOp {
        public static final String NAME = "ConcatFromSequence";
        
        public enum Attribute implements OnnxAttribute {
            axis(Integer.class, false, null),
            new_axis(Integer.class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            S(new OnnxType.TypeVariable("S", List.of(/* @@@ [seq<tensor<uint8>>, seq<tensor<uint16>>, seq<tensor<uint32>>, seq<tensor<uint64>>, seq<tensor<int8>>, seq<tensor<int16>>, seq<tensor<int32>>, seq<tensor<int64>>, seq<tensor<float16>>, seq<tensor<float>>, seq<tensor<double>>, seq<tensor<string>>, seq<tensor<bool>>, seq<tensor<complex64>>, seq<tensor<complex128>>] */))),
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<uint8>, tensor<uint16>, tensor<uint32>, tensor<uint64>, tensor<int8>, tensor<int16>, tensor<int32>, tensor<int64>, tensor<float16>, tensor<float>, tensor<double>, tensor<string>, tensor<bool>, tensor<complex64>, tensor<complex128>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            input_sequence(TypeConstraint.S.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            concat_result(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public ConcatFromSequence(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        ConcatFromSequence(ConcatFromSequence that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public ConcatFromSequence transform(CopyContext cc, OpTransformer ot) {
            return new ConcatFromSequence(this, cc);
        }
        
        ConcatFromSequence(TypeElement resultType, Value input_sequence, int axis, java.util.Optional<Integer> new_axis) {
            super(SCHEMA, resultType, Set.of(), List.of(input_sequence), List.of(axis, new_axis));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(input_sequence()));
        }
        
        public Value input_sequence() {
            return operands().get(0);
        }
        
        public int axis() {
            int axis = Attribute.axis.access(int.class, onnxAttributes);
            return axis;
        }
        
        public java.util.Optional<Integer> new_axis() {
            Integer new_axis = Attribute.new_axis.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(new_axis);
        }
        
    }
    
    public static ConcatFromSequence ConcatFromSequence(TypeElement resultType, Value input_sequence, int axis, java.util.Optional<Integer> new_axis) {
        return new ConcatFromSequence(resultType, input_sequence, axis, new_axis);
    }

    @OpFactory.OpDeclaration(Constant.NAME)
    public static final class Constant extends OnnxOp {
        public static final String NAME = "Constant";
        
        public enum Attribute implements OnnxAttribute {
            value_int(Integer.class, true, null),
            value_floats(float[].class, true, null),
            value_strings(String[].class, true, null),
            value_float(Float.class, true, null),
            value_string(String.class, true, null),
            value_ints(int[].class, true, null),
            sparse_value(Object.class, true, null),
            value(Tensor.class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<uint8>, tensor<uint16>, tensor<uint32>, tensor<uint64>, tensor<int8>, tensor<int16>, tensor<int32>, tensor<int64>, tensor<bfloat16>, tensor<float16>, tensor<float>, tensor<double>, tensor<string>, tensor<bool>, tensor<complex64>, tensor<complex128>, tensor<float8e4m3fn>, tensor<float8e4m3fnuz>, tensor<float8e5m2>, tensor<float8e5m2fnuz>, tensor<uint4>, tensor<int4>, tensor<float4e2m1>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter.None { }
        
        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public Constant(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        Constant(Constant that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public Constant transform(CopyContext cc, OpTransformer ot) {
            return new Constant(this, cc);
        }
        
        Constant(TypeElement resultType, java.util.Optional<Integer> value_int, java.util.Optional<float[]> value_floats, java.util.Optional<String[]> value_strings, java.util.Optional<Float> value_float, java.util.Optional<String> value_string, java.util.Optional<int[]> value_ints, java.util.Optional<Object> sparse_value, java.util.Optional<Tensor<?>> value) {
            super(SCHEMA, resultType, Set.of(), List.of(), List.of(value_int, value_floats, value_strings, value_float, value_string, value_ints, sparse_value, value));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of());
        }
        
        public java.util.Optional<Integer> value_int() {
            Integer value_int = Attribute.value_int.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(value_int);
        }
        
        public java.util.Optional<float[]> value_floats() {
            float[] value_floats = Attribute.value_floats.access(float[].class, onnxAttributes);
            return java.util.Optional.ofNullable(value_floats).map(float[]::clone);
        }
        
        public java.util.Optional<String[]> value_strings() {
            String[] value_strings = Attribute.value_strings.access(String[].class, onnxAttributes);
            return java.util.Optional.ofNullable(value_strings).map(String[]::clone);
        }
        
        public java.util.Optional<Float> value_float() {
            Float value_float = Attribute.value_float.access(Float.class, onnxAttributes);
            return java.util.Optional.ofNullable(value_float);
        }
        
        public java.util.Optional<String> value_string() {
            String value_string = Attribute.value_string.access(String.class, onnxAttributes);
            return java.util.Optional.ofNullable(value_string);
        }
        
        public java.util.Optional<int[]> value_ints() {
            int[] value_ints = Attribute.value_ints.access(int[].class, onnxAttributes);
            return java.util.Optional.ofNullable(value_ints).map(int[]::clone);
        }
        
        public java.util.Optional<Object> sparse_value() {
            Object sparse_value = Attribute.sparse_value.access(Object.class, onnxAttributes);
            return java.util.Optional.ofNullable(sparse_value);
        }
        
        public java.util.Optional<Tensor<?>> value() {
            Tensor<?> value = Attribute.value.access(Tensor.class, onnxAttributes);
            return java.util.Optional.ofNullable(value);
        }
        
    }
    
    public static Constant Constant(TypeElement resultType, java.util.Optional<Integer> value_int, java.util.Optional<float[]> value_floats, java.util.Optional<String[]> value_strings, java.util.Optional<Float> value_float, java.util.Optional<String> value_string, java.util.Optional<int[]> value_ints, java.util.Optional<Object> sparse_value, java.util.Optional<Tensor<?>> value) {
        return new Constant(resultType, value_int, value_floats, value_strings, value_float, value_string, value_ints, sparse_value, value);
    }

    @OpFactory.OpDeclaration(ConstantOfShape.NAME)
    public static final class ConstantOfShape extends OnnxOp {
        public static final String NAME = "ConstantOfShape";
        
        public enum Attribute implements OnnxAttribute {
            value(Tensor.class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T1(new OnnxType.TypeVariable("T1", List.of(/* @@@ [tensor<int64>] */))),
            T2(new OnnxType.TypeVariable("T2", List.of(/* @@@ [tensor<float16>, tensor<float>, tensor<double>, tensor<int8>, tensor<int16>, tensor<int32>, tensor<int64>, tensor<uint8>, tensor<uint16>, tensor<uint32>, tensor<uint64>, tensor<uint4>, tensor<int4>, tensor<bool>, tensor<bfloat16>, tensor<float8e4m3fn>, tensor<float8e4m3fnuz>, tensor<float8e5m2>, tensor<float8e5m2fnuz>, tensor<float4e2m1>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            input(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public ConstantOfShape(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        ConstantOfShape(ConstantOfShape that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public ConstantOfShape transform(CopyContext cc, OpTransformer ot) {
            return new ConstantOfShape(this, cc);
        }
        
        ConstantOfShape(TypeElement resultType, Value input, java.util.Optional<Tensor<?>> value) {
            super(SCHEMA, resultType, Set.of(), List.of(input), List.of(value));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(input()));
        }
        
        public Value input() {
            return operands().get(0);
        }
        
        public java.util.Optional<Tensor<?>> value() {
            Tensor<?> value = Attribute.value.access(Tensor.class, onnxAttributes);
            return java.util.Optional.ofNullable(value);
        }
        
    }
    
    public static ConstantOfShape ConstantOfShape(TypeElement resultType, Value input, java.util.Optional<Tensor<?>> value) {
        return new ConstantOfShape(resultType, input, value);
    }

    @OpFactory.OpDeclaration(Conv.NAME)
    public static final class Conv extends OnnxOp {
        public static final String NAME = "Conv";
        
        public enum Attribute implements OnnxAttribute {
            pads(int[].class, true, null),
            dilations(int[].class, true, null),
            auto_pad(String.class, true, null),
            strides(int[].class, true, null),
            group(Integer.class, true, null),
            kernel_shape(int[].class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<bfloat16>, tensor<float16>, tensor<float>, tensor<double>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            W(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            B(TypeConstraint.T.typeVariable(), Quantifier.OPTIONAL),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public Conv(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        Conv(Conv that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public Conv transform(CopyContext cc, OpTransformer ot) {
            return new Conv(this, cc);
        }
        
        Conv(TypeElement resultType, Value X, Value W, java.util.Optional<Value> B, java.util.Optional<int[]> pads, java.util.Optional<int[]> dilations, java.util.Optional<String> auto_pad, java.util.Optional<int[]> strides, java.util.Optional<Integer> group, java.util.Optional<int[]> kernel_shape) {
            super(SCHEMA, resultType, Set.of(), List.of(X, W, B), List.of(pads, dilations, auto_pad, strides, group, kernel_shape));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X(), W(), B()));
        }
        
        public Value X() {
            return operands().get(0);
        }
        
        public Value W() {
            return operands().get(1);
        }
        
        public java.util.Optional<Value> B() {
            int i = optionalInputArguments.indexOf(InputParameter.B);
            return i != -1 ? java.util.Optional.of(operands().get(2 + i)) : java.util.Optional.empty();
        }
        
        public java.util.Optional<int[]> pads() {
            int[] pads = Attribute.pads.access(int[].class, onnxAttributes);
            return java.util.Optional.ofNullable(pads).map(int[]::clone);
        }
        
        public java.util.Optional<int[]> dilations() {
            int[] dilations = Attribute.dilations.access(int[].class, onnxAttributes);
            return java.util.Optional.ofNullable(dilations).map(int[]::clone);
        }
        
        public java.util.Optional<String> auto_pad() {
            String auto_pad = Attribute.auto_pad.access(String.class, onnxAttributes);
            return java.util.Optional.ofNullable(auto_pad);
        }
        
        public java.util.Optional<int[]> strides() {
            int[] strides = Attribute.strides.access(int[].class, onnxAttributes);
            return java.util.Optional.ofNullable(strides).map(int[]::clone);
        }
        
        public java.util.Optional<Integer> group() {
            Integer group = Attribute.group.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(group);
        }
        
        public java.util.Optional<int[]> kernel_shape() {
            int[] kernel_shape = Attribute.kernel_shape.access(int[].class, onnxAttributes);
            return java.util.Optional.ofNullable(kernel_shape).map(int[]::clone);
        }
        
    }
    
    public static Conv Conv(TypeElement resultType, Value X, Value W, java.util.Optional<Value> B, java.util.Optional<int[]> pads, java.util.Optional<int[]> dilations, java.util.Optional<String> auto_pad, java.util.Optional<int[]> strides, java.util.Optional<Integer> group, java.util.Optional<int[]> kernel_shape) {
        return new Conv(resultType, X, W, B, pads, dilations, auto_pad, strides, group, kernel_shape);
    }

    @OpFactory.OpDeclaration(ConvInteger.NAME)
    public static final class ConvInteger extends OnnxOp {
        public static final String NAME = "ConvInteger";
        
        public enum Attribute implements OnnxAttribute {
            pads(int[].class, true, null),
            dilations(int[].class, true, null),
            auto_pad(String.class, true, null),
            strides(int[].class, true, null),
            group(Integer.class, true, null),
            kernel_shape(int[].class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T1(new OnnxType.TypeVariable("T1", List.of(/* @@@ [tensor<int8>, tensor<uint8>] */))),
            T2(new OnnxType.TypeVariable("T2", List.of(/* @@@ [tensor<int8>, tensor<uint8>] */))),
            T3(new OnnxType.TypeVariable("T3", List.of(/* @@@ [tensor<int32>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            x(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            w(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),
            x_zero_point(TypeConstraint.T1.typeVariable(), Quantifier.OPTIONAL),
            w_zero_point(TypeConstraint.T2.typeVariable(), Quantifier.OPTIONAL),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            y(TypeConstraint.T3.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public ConvInteger(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        ConvInteger(ConvInteger that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public ConvInteger transform(CopyContext cc, OpTransformer ot) {
            return new ConvInteger(this, cc);
        }
        
        ConvInteger(TypeElement resultType, Value x, Value w, java.util.Optional<Value> x_zero_point, java.util.Optional<Value> w_zero_point, java.util.Optional<int[]> pads, java.util.Optional<int[]> dilations, java.util.Optional<String> auto_pad, java.util.Optional<int[]> strides, java.util.Optional<Integer> group, java.util.Optional<int[]> kernel_shape) {
            super(SCHEMA, resultType, Set.of(), List.of(x, w, x_zero_point, w_zero_point), List.of(pads, dilations, auto_pad, strides, group, kernel_shape));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(x(), w(), x_zero_point(), w_zero_point()));
        }
        
        public Value x() {
            return operands().get(0);
        }
        
        public Value w() {
            return operands().get(1);
        }
        
        public java.util.Optional<Value> x_zero_point() {
            int i = optionalInputArguments.indexOf(InputParameter.x_zero_point);
            return i != -1 ? java.util.Optional.of(operands().get(2 + i)) : java.util.Optional.empty();
        }
        
        public java.util.Optional<Value> w_zero_point() {
            int i = optionalInputArguments.indexOf(InputParameter.w_zero_point);
            return i != -1 ? java.util.Optional.of(operands().get(2 + i)) : java.util.Optional.empty();
        }
        
        public java.util.Optional<int[]> pads() {
            int[] pads = Attribute.pads.access(int[].class, onnxAttributes);
            return java.util.Optional.ofNullable(pads).map(int[]::clone);
        }
        
        public java.util.Optional<int[]> dilations() {
            int[] dilations = Attribute.dilations.access(int[].class, onnxAttributes);
            return java.util.Optional.ofNullable(dilations).map(int[]::clone);
        }
        
        public java.util.Optional<String> auto_pad() {
            String auto_pad = Attribute.auto_pad.access(String.class, onnxAttributes);
            return java.util.Optional.ofNullable(auto_pad);
        }
        
        public java.util.Optional<int[]> strides() {
            int[] strides = Attribute.strides.access(int[].class, onnxAttributes);
            return java.util.Optional.ofNullable(strides).map(int[]::clone);
        }
        
        public java.util.Optional<Integer> group() {
            Integer group = Attribute.group.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(group);
        }
        
        public java.util.Optional<int[]> kernel_shape() {
            int[] kernel_shape = Attribute.kernel_shape.access(int[].class, onnxAttributes);
            return java.util.Optional.ofNullable(kernel_shape).map(int[]::clone);
        }
        
    }
    
    public static ConvInteger ConvInteger(TypeElement resultType, Value x, Value w, java.util.Optional<Value> x_zero_point, java.util.Optional<Value> w_zero_point, java.util.Optional<int[]> pads, java.util.Optional<int[]> dilations, java.util.Optional<String> auto_pad, java.util.Optional<int[]> strides, java.util.Optional<Integer> group, java.util.Optional<int[]> kernel_shape) {
        return new ConvInteger(resultType, x, w, x_zero_point, w_zero_point, pads, dilations, auto_pad, strides, group, kernel_shape);
    }

    @OpFactory.OpDeclaration(ConvTranspose.NAME)
    public static final class ConvTranspose extends OnnxOp {
        public static final String NAME = "ConvTranspose";
        
        public enum Attribute implements OnnxAttribute {
            output_shape(int[].class, true, null),
            pads(int[].class, true, null),
            dilations(int[].class, true, null),
            auto_pad(String.class, true, null),
            strides(int[].class, true, null),
            group(Integer.class, true, null),
            kernel_shape(int[].class, true, null),
            output_padding(int[].class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<bfloat16>, tensor<float16>, tensor<float>, tensor<double>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            W(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            B(TypeConstraint.T.typeVariable(), Quantifier.OPTIONAL),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public ConvTranspose(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        ConvTranspose(ConvTranspose that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public ConvTranspose transform(CopyContext cc, OpTransformer ot) {
            return new ConvTranspose(this, cc);
        }
        
        ConvTranspose(TypeElement resultType, Value X, Value W, java.util.Optional<Value> B, java.util.Optional<int[]> output_shape, java.util.Optional<int[]> pads, java.util.Optional<int[]> dilations, java.util.Optional<String> auto_pad, java.util.Optional<int[]> strides, java.util.Optional<Integer> group, java.util.Optional<int[]> kernel_shape, java.util.Optional<int[]> output_padding) {
            super(SCHEMA, resultType, Set.of(), List.of(X, W, B), List.of(output_shape, pads, dilations, auto_pad, strides, group, kernel_shape, output_padding));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X(), W(), B()));
        }
        
        public Value X() {
            return operands().get(0);
        }
        
        public Value W() {
            return operands().get(1);
        }
        
        public java.util.Optional<Value> B() {
            int i = optionalInputArguments.indexOf(InputParameter.B);
            return i != -1 ? java.util.Optional.of(operands().get(2 + i)) : java.util.Optional.empty();
        }
        
        public java.util.Optional<int[]> output_shape() {
            int[] output_shape = Attribute.output_shape.access(int[].class, onnxAttributes);
            return java.util.Optional.ofNullable(output_shape).map(int[]::clone);
        }
        
        public java.util.Optional<int[]> pads() {
            int[] pads = Attribute.pads.access(int[].class, onnxAttributes);
            return java.util.Optional.ofNullable(pads).map(int[]::clone);
        }
        
        public java.util.Optional<int[]> dilations() {
            int[] dilations = Attribute.dilations.access(int[].class, onnxAttributes);
            return java.util.Optional.ofNullable(dilations).map(int[]::clone);
        }
        
        public java.util.Optional<String> auto_pad() {
            String auto_pad = Attribute.auto_pad.access(String.class, onnxAttributes);
            return java.util.Optional.ofNullable(auto_pad);
        }
        
        public java.util.Optional<int[]> strides() {
            int[] strides = Attribute.strides.access(int[].class, onnxAttributes);
            return java.util.Optional.ofNullable(strides).map(int[]::clone);
        }
        
        public java.util.Optional<Integer> group() {
            Integer group = Attribute.group.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(group);
        }
        
        public java.util.Optional<int[]> kernel_shape() {
            int[] kernel_shape = Attribute.kernel_shape.access(int[].class, onnxAttributes);
            return java.util.Optional.ofNullable(kernel_shape).map(int[]::clone);
        }
        
        public java.util.Optional<int[]> output_padding() {
            int[] output_padding = Attribute.output_padding.access(int[].class, onnxAttributes);
            return java.util.Optional.ofNullable(output_padding).map(int[]::clone);
        }
        
    }
    
    public static ConvTranspose ConvTranspose(TypeElement resultType, Value X, Value W, java.util.Optional<Value> B, java.util.Optional<int[]> output_shape, java.util.Optional<int[]> pads, java.util.Optional<int[]> dilations, java.util.Optional<String> auto_pad, java.util.Optional<int[]> strides, java.util.Optional<Integer> group, java.util.Optional<int[]> kernel_shape, java.util.Optional<int[]> output_padding) {
        return new ConvTranspose(resultType, X, W, B, output_shape, pads, dilations, auto_pad, strides, group, kernel_shape, output_padding);
    }

    @OpFactory.OpDeclaration(Cos.NAME)
    public static final class Cos extends OnnxOp {
        public static final String NAME = "Cos";
        
        public enum Attribute implements OnnxAttribute.None { }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<bfloat16>, tensor<float16>, tensor<float>, tensor<double>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            input(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public Cos(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        Cos(Cos that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public Cos transform(CopyContext cc, OpTransformer ot) {
            return new Cos(this, cc);
        }
        
        Cos(TypeElement resultType, Value input) {
            super(SCHEMA, resultType, Set.of(), List.of(input), List.of());
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(input()));
        }
        
        public Value input() {
            return operands().get(0);
        }
        
    }
    
    public static Cos Cos(TypeElement resultType, Value input) {
        return new Cos(resultType, input);
    }

    @OpFactory.OpDeclaration(Cosh.NAME)
    public static final class Cosh extends OnnxOp {
        public static final String NAME = "Cosh";
        
        public enum Attribute implements OnnxAttribute.None { }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<bfloat16>, tensor<float16>, tensor<float>, tensor<double>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            input(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public Cosh(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        Cosh(Cosh that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public Cosh transform(CopyContext cc, OpTransformer ot) {
            return new Cosh(this, cc);
        }
        
        Cosh(TypeElement resultType, Value input) {
            super(SCHEMA, resultType, Set.of(), List.of(input), List.of());
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(input()));
        }
        
        public Value input() {
            return operands().get(0);
        }
        
    }
    
    public static Cosh Cosh(TypeElement resultType, Value input) {
        return new Cosh(resultType, input);
    }

    @OpFactory.OpDeclaration(CumSum.NAME)
    public static final class CumSum extends OnnxOp {
        public static final String NAME = "CumSum";
        
        public enum Attribute implements OnnxAttribute {
            exclusive(Integer.class, true, null),
            reverse(Integer.class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<uint32>, tensor<uint64>, tensor<int32>, tensor<int64>, tensor<float16>, tensor<float>, tensor<double>, tensor<bfloat16>] */))),
            T2(new OnnxType.TypeVariable("T2", List.of(/* @@@ [tensor<int32>, tensor<int64>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            x(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            axis(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public CumSum(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        CumSum(CumSum that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public CumSum transform(CopyContext cc, OpTransformer ot) {
            return new CumSum(this, cc);
        }
        
        CumSum(TypeElement resultType, Value x, Value axis, java.util.Optional<Integer> exclusive, java.util.Optional<Integer> reverse) {
            super(SCHEMA, resultType, Set.of(), List.of(x, axis), List.of(exclusive, reverse));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(x(), axis()));
        }
        
        public Value x() {
            return operands().get(0);
        }
        
        public Value axis() {
            return operands().get(1);
        }
        
        public java.util.Optional<Integer> exclusive() {
            Integer exclusive = Attribute.exclusive.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(exclusive);
        }
        
        public java.util.Optional<Integer> reverse() {
            Integer reverse = Attribute.reverse.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(reverse);
        }
        
    }
    
    public static CumSum CumSum(TypeElement resultType, Value x, Value axis, java.util.Optional<Integer> exclusive, java.util.Optional<Integer> reverse) {
        return new CumSum(resultType, x, axis, exclusive, reverse);
    }

    @OpFactory.OpDeclaration(DFT.NAME)
    public static final class DFT extends OnnxOp {
        public static final String NAME = "DFT";
        
        public enum Attribute implements OnnxAttribute {
            inverse(Integer.class, true, null),
            onesided(Integer.class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T1(new OnnxType.TypeVariable("T1", List.of(/* @@@ [tensor<bfloat16>, tensor<float16>, tensor<float>, tensor<double>] */))),
            T2(new OnnxType.TypeVariable("T2", List.of(/* @@@ [tensor<int32>, tensor<int64>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            input(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            dft_length(TypeConstraint.T2.typeVariable(), Quantifier.OPTIONAL),
            axis(null /* @@@ tensor<int64> */, Quantifier.OPTIONAL),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public DFT(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        DFT(DFT that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public DFT transform(CopyContext cc, OpTransformer ot) {
            return new DFT(this, cc);
        }
        
        DFT(TypeElement resultType, Value input, java.util.Optional<Value> dft_length, java.util.Optional<Value> axis, java.util.Optional<Integer> inverse, java.util.Optional<Integer> onesided) {
            super(SCHEMA, resultType, Set.of(), List.of(input, dft_length, axis), List.of(inverse, onesided));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(input(), dft_length(), axis()));
        }
        
        public Value input() {
            return operands().get(0);
        }
        
        public java.util.Optional<Value> dft_length() {
            int i = optionalInputArguments.indexOf(InputParameter.dft_length);
            return i != -1 ? java.util.Optional.of(operands().get(1 + i)) : java.util.Optional.empty();
        }
        
        public java.util.Optional<Value> axis() {
            int i = optionalInputArguments.indexOf(InputParameter.axis);
            return i != -1 ? java.util.Optional.of(operands().get(1 + i)) : java.util.Optional.empty();
        }
        
        public java.util.Optional<Integer> inverse() {
            Integer inverse = Attribute.inverse.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(inverse);
        }
        
        public java.util.Optional<Integer> onesided() {
            Integer onesided = Attribute.onesided.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(onesided);
        }
        
    }
    
    public static DFT DFT(TypeElement resultType, Value input, java.util.Optional<Value> dft_length, java.util.Optional<Value> axis, java.util.Optional<Integer> inverse, java.util.Optional<Integer> onesided) {
        return new DFT(resultType, input, dft_length, axis, inverse, onesided);
    }

    @OpFactory.OpDeclaration(DeformConv.NAME)
    public static final class DeformConv extends OnnxOp {
        public static final String NAME = "DeformConv";
        
        public enum Attribute implements OnnxAttribute {
            pads(int[].class, true, null),
            dilations(int[].class, true, null),
            strides(int[].class, true, null),
            offset_group(Integer.class, true, null),
            group(Integer.class, true, null),
            kernel_shape(int[].class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<bfloat16>, tensor<float16>, tensor<float>, tensor<double>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            W(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            offset(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            B(TypeConstraint.T.typeVariable(), Quantifier.OPTIONAL),
            mask(TypeConstraint.T.typeVariable(), Quantifier.OPTIONAL),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public DeformConv(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        DeformConv(DeformConv that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public DeformConv transform(CopyContext cc, OpTransformer ot) {
            return new DeformConv(this, cc);
        }
        
        DeformConv(TypeElement resultType, Value X, Value W, Value offset, java.util.Optional<Value> B, java.util.Optional<Value> mask, java.util.Optional<int[]> pads, java.util.Optional<int[]> dilations, java.util.Optional<int[]> strides, java.util.Optional<Integer> offset_group, java.util.Optional<Integer> group, java.util.Optional<int[]> kernel_shape) {
            super(SCHEMA, resultType, Set.of(), List.of(X, W, offset, B, mask), List.of(pads, dilations, strides, offset_group, group, kernel_shape));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X(), W(), offset(), B(), mask()));
        }
        
        public Value X() {
            return operands().get(0);
        }
        
        public Value W() {
            return operands().get(1);
        }
        
        public Value offset() {
            return operands().get(2);
        }
        
        public java.util.Optional<Value> B() {
            int i = optionalInputArguments.indexOf(InputParameter.B);
            return i != -1 ? java.util.Optional.of(operands().get(3 + i)) : java.util.Optional.empty();
        }
        
        public java.util.Optional<Value> mask() {
            int i = optionalInputArguments.indexOf(InputParameter.mask);
            return i != -1 ? java.util.Optional.of(operands().get(3 + i)) : java.util.Optional.empty();
        }
        
        public java.util.Optional<int[]> pads() {
            int[] pads = Attribute.pads.access(int[].class, onnxAttributes);
            return java.util.Optional.ofNullable(pads).map(int[]::clone);
        }
        
        public java.util.Optional<int[]> dilations() {
            int[] dilations = Attribute.dilations.access(int[].class, onnxAttributes);
            return java.util.Optional.ofNullable(dilations).map(int[]::clone);
        }
        
        public java.util.Optional<int[]> strides() {
            int[] strides = Attribute.strides.access(int[].class, onnxAttributes);
            return java.util.Optional.ofNullable(strides).map(int[]::clone);
        }
        
        public java.util.Optional<Integer> offset_group() {
            Integer offset_group = Attribute.offset_group.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(offset_group);
        }
        
        public java.util.Optional<Integer> group() {
            Integer group = Attribute.group.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(group);
        }
        
        public java.util.Optional<int[]> kernel_shape() {
            int[] kernel_shape = Attribute.kernel_shape.access(int[].class, onnxAttributes);
            return java.util.Optional.ofNullable(kernel_shape).map(int[]::clone);
        }
        
    }
    
    public static DeformConv DeformConv(TypeElement resultType, Value X, Value W, Value offset, java.util.Optional<Value> B, java.util.Optional<Value> mask, java.util.Optional<int[]> pads, java.util.Optional<int[]> dilations, java.util.Optional<int[]> strides, java.util.Optional<Integer> offset_group, java.util.Optional<Integer> group, java.util.Optional<int[]> kernel_shape) {
        return new DeformConv(resultType, X, W, offset, B, mask, pads, dilations, strides, offset_group, group, kernel_shape);
    }

    @OpFactory.OpDeclaration(DepthToSpace.NAME)
    public static final class DepthToSpace extends OnnxOp {
        public static final String NAME = "DepthToSpace";
        
        public enum Attribute implements OnnxAttribute {
            mode(String.class, true, null),
            blocksize(Integer.class, false, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<uint8>, tensor<uint16>, tensor<uint32>, tensor<uint64>, tensor<int8>, tensor<int16>, tensor<int32>, tensor<int64>, tensor<bfloat16>, tensor<float16>, tensor<float>, tensor<double>, tensor<string>, tensor<bool>, tensor<complex64>, tensor<complex128>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            input(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public DepthToSpace(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        DepthToSpace(DepthToSpace that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public DepthToSpace transform(CopyContext cc, OpTransformer ot) {
            return new DepthToSpace(this, cc);
        }
        
        DepthToSpace(TypeElement resultType, Value input, java.util.Optional<String> mode, int blocksize) {
            super(SCHEMA, resultType, Set.of(), List.of(input), List.of(mode, blocksize));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(input()));
        }
        
        public Value input() {
            return operands().get(0);
        }
        
        public java.util.Optional<String> mode() {
            String mode = Attribute.mode.access(String.class, onnxAttributes);
            return java.util.Optional.ofNullable(mode);
        }
        
        public int blocksize() {
            int blocksize = Attribute.blocksize.access(int.class, onnxAttributes);
            return blocksize;
        }
        
    }
    
    public static DepthToSpace DepthToSpace(TypeElement resultType, Value input, java.util.Optional<String> mode, int blocksize) {
        return new DepthToSpace(resultType, input, mode, blocksize);
    }

    @OpFactory.OpDeclaration(DequantizeLinear.NAME)
    public static final class DequantizeLinear extends OnnxOp {
        public static final String NAME = "DequantizeLinear";
        
        public enum Attribute implements OnnxAttribute {
            axis(Integer.class, true, null),
            block_size(Integer.class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T1(new OnnxType.TypeVariable("T1", List.of(/* @@@ [tensor<int8>, tensor<uint8>, tensor<int16>, tensor<uint16>, tensor<int32>, tensor<float8e4m3fn>, tensor<float8e4m3fnuz>, tensor<float8e5m2>, tensor<float8e5m2fnuz>, tensor<uint4>, tensor<int4>, tensor<float4e2m1>] */))),
            T2(new OnnxType.TypeVariable("T2", List.of(/* @@@ [tensor<float>, tensor<float16>, tensor<bfloat16>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            x(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            x_scale(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),
            x_zero_point(TypeConstraint.T1.typeVariable(), Quantifier.OPTIONAL),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            y(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public DequantizeLinear(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        DequantizeLinear(DequantizeLinear that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public DequantizeLinear transform(CopyContext cc, OpTransformer ot) {
            return new DequantizeLinear(this, cc);
        }
        
        DequantizeLinear(TypeElement resultType, Value x, Value x_scale, java.util.Optional<Value> x_zero_point, java.util.Optional<Integer> axis, java.util.Optional<Integer> block_size) {
            super(SCHEMA, resultType, Set.of(), List.of(x, x_scale, x_zero_point), List.of(axis, block_size));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(x(), x_scale(), x_zero_point()));
        }
        
        public Value x() {
            return operands().get(0);
        }
        
        public Value x_scale() {
            return operands().get(1);
        }
        
        public java.util.Optional<Value> x_zero_point() {
            int i = optionalInputArguments.indexOf(InputParameter.x_zero_point);
            return i != -1 ? java.util.Optional.of(operands().get(2 + i)) : java.util.Optional.empty();
        }
        
        public java.util.Optional<Integer> axis() {
            Integer axis = Attribute.axis.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(axis);
        }
        
        public java.util.Optional<Integer> block_size() {
            Integer block_size = Attribute.block_size.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(block_size);
        }
        
    }
    
    public static DequantizeLinear DequantizeLinear(TypeElement resultType, Value x, Value x_scale, java.util.Optional<Value> x_zero_point, java.util.Optional<Integer> axis, java.util.Optional<Integer> block_size) {
        return new DequantizeLinear(resultType, x, x_scale, x_zero_point, axis, block_size);
    }

    @OpFactory.OpDeclaration(Det.NAME)
    public static final class Det extends OnnxOp {
        public static final String NAME = "Det";
        
        public enum Attribute implements OnnxAttribute.None { }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<bfloat16>, tensor<float16>, tensor<float>, tensor<double>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public Det(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        Det(Det that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public Det transform(CopyContext cc, OpTransformer ot) {
            return new Det(this, cc);
        }
        
        Det(TypeElement resultType, Value X) {
            super(SCHEMA, resultType, Set.of(), List.of(X), List.of());
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X()));
        }
        
        public Value X() {
            return operands().get(0);
        }
        
    }
    
    public static Det Det(TypeElement resultType, Value X) {
        return new Det(resultType, X);
    }

    @OpFactory.OpDeclaration(DictVectorizer.NAME)
    public static final class DictVectorizer extends OnnxOp {
        public static final String NAME = "DictVectorizer";
        
        public enum Attribute implements OnnxAttribute {
            string_vocabulary(String[].class, true, null),
            int64_vocabulary(int[].class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T1(new OnnxType.TypeVariable("T1", List.of(/* @@@ [map<string, int64>, map<int64, string>, map<int64, float>, map<int64, double>, map<string, float>, map<string, double>] */))),
            T2(new OnnxType.TypeVariable("T2", List.of(/* @@@ [tensor<int64>, tensor<float>, tensor<double>, tensor<string>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public DictVectorizer(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        DictVectorizer(DictVectorizer that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public DictVectorizer transform(CopyContext cc, OpTransformer ot) {
            return new DictVectorizer(this, cc);
        }
        
        DictVectorizer(TypeElement resultType, Value X, java.util.Optional<String[]> string_vocabulary, java.util.Optional<int[]> int64_vocabulary) {
            super(SCHEMA, resultType, Set.of(), List.of(X), List.of(string_vocabulary, int64_vocabulary));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X()));
        }
        
        public Value X() {
            return operands().get(0);
        }
        
        public java.util.Optional<String[]> string_vocabulary() {
            String[] string_vocabulary = Attribute.string_vocabulary.access(String[].class, onnxAttributes);
            return java.util.Optional.ofNullable(string_vocabulary).map(String[]::clone);
        }
        
        public java.util.Optional<int[]> int64_vocabulary() {
            int[] int64_vocabulary = Attribute.int64_vocabulary.access(int[].class, onnxAttributes);
            return java.util.Optional.ofNullable(int64_vocabulary).map(int[]::clone);
        }
        
    }
    
    public static DictVectorizer DictVectorizer(TypeElement resultType, Value X, java.util.Optional<String[]> string_vocabulary, java.util.Optional<int[]> int64_vocabulary) {
        return new DictVectorizer(resultType, X, string_vocabulary, int64_vocabulary);
    }

    @OpFactory.OpDeclaration(Div.NAME)
    public static final class Div extends OnnxOp {
        public static final String NAME = "Div";
        
        public enum Attribute implements OnnxAttribute.None { }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<uint8>, tensor<uint16>, tensor<uint32>, tensor<uint64>, tensor<int8>, tensor<int16>, tensor<int32>, tensor<int64>, tensor<float16>, tensor<float>, tensor<double>, tensor<bfloat16>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            A(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            B(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            C(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public Div(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        Div(Div that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public Div transform(CopyContext cc, OpTransformer ot) {
            return new Div(this, cc);
        }
        
        Div(TypeElement resultType, Value A, Value B) {
            super(SCHEMA, resultType, Set.of(), List.of(A, B), List.of());
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(A(), B()));
        }
        
        public Value A() {
            return operands().get(0);
        }
        
        public Value B() {
            return operands().get(1);
        }
        
    }
    
    public static Div Div(TypeElement resultType, Value A, Value B) {
        return new Div(resultType, A, B);
    }

    @OpFactory.OpDeclaration(Dropout.NAME)
    public static final class Dropout extends OnnxOp {
        public static final String NAME = "Dropout";
        
        public enum Attribute implements OnnxAttribute {
            seed(Integer.class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<bfloat16>, tensor<float16>, tensor<float>, tensor<double>, tensor<float8e4m3fn>, tensor<float8e4m3fnuz>, tensor<float8e5m2>, tensor<float8e5m2fnuz>] */))),
            T1(new OnnxType.TypeVariable("T1", List.of(/* @@@ [tensor<bfloat16>, tensor<float16>, tensor<float>, tensor<double>, tensor<float8e4m3fn>, tensor<float8e4m3fnuz>, tensor<float8e5m2>, tensor<float8e5m2fnuz>] */))),
            T2(new OnnxType.TypeVariable("T2", List.of(/* @@@ [tensor<bool>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            data(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ratio(TypeConstraint.T1.typeVariable(), Quantifier.OPTIONAL),
            training_mode(TypeConstraint.T2.typeVariable(), Quantifier.OPTIONAL),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            mask(TypeConstraint.T2.typeVariable(), Quantifier.OPTIONAL),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public Dropout(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        Dropout(Dropout that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public Dropout transform(CopyContext cc, OpTransformer ot) {
            return new Dropout(this, cc);
        }
        
        Dropout(TypeElement resultType, Value data, java.util.Optional<Value> ratio, java.util.Optional<Value> training_mode, java.util.Optional<Integer> seed) {
            super(SCHEMA, resultType, Set.of(), List.of(data, ratio, training_mode), List.of(seed));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(data(), ratio(), training_mode()));
        }
        
        public Value data() {
            return operands().get(0);
        }
        
        public java.util.Optional<Value> ratio() {
            int i = optionalInputArguments.indexOf(InputParameter.ratio);
            return i != -1 ? java.util.Optional.of(operands().get(1 + i)) : java.util.Optional.empty();
        }
        
        public java.util.Optional<Value> training_mode() {
            int i = optionalInputArguments.indexOf(InputParameter.training_mode);
            return i != -1 ? java.util.Optional.of(operands().get(1 + i)) : java.util.Optional.empty();
        }
        
        public java.util.Optional<Integer> seed() {
            Integer seed = Attribute.seed.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(seed);
        }
        
    }
    
    public static Dropout Dropout(TypeElement resultType, Value data, java.util.Optional<Value> ratio, java.util.Optional<Value> training_mode, java.util.Optional<Integer> seed) {
        return new Dropout(resultType, data, ratio, training_mode, seed);
    }

    @OpFactory.OpDeclaration(DynamicQuantizeLinear.NAME)
    public static final class DynamicQuantizeLinear extends OnnxOp {
        public static final String NAME = "DynamicQuantizeLinear";
        
        public enum Attribute implements OnnxAttribute.None { }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T1(new OnnxType.TypeVariable("T1", List.of(/* @@@ [tensor<float>] */))),
            T2(new OnnxType.TypeVariable("T2", List.of(/* @@@ [tensor<uint8>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            x(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            y(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),
            y_scale(null /* @@@ tensor<float> */, Quantifier.REQUIRED),
            y_zero_point(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public DynamicQuantizeLinear(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        DynamicQuantizeLinear(DynamicQuantizeLinear that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public DynamicQuantizeLinear transform(CopyContext cc, OpTransformer ot) {
            return new DynamicQuantizeLinear(this, cc);
        }
        
        DynamicQuantizeLinear(TypeElement resultType, Value x) {
            super(SCHEMA, resultType, Set.of(), List.of(x), List.of());
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(x()));
        }
        
        public Value x() {
            return operands().get(0);
        }
        
    }
    
    public static DynamicQuantizeLinear DynamicQuantizeLinear(TypeElement resultType, Value x) {
        return new DynamicQuantizeLinear(resultType, x);
    }

    @OpFactory.OpDeclaration(Einsum.NAME)
    public static final class Einsum extends OnnxOp {
        public static final String NAME = "Einsum";
        
        public enum Attribute implements OnnxAttribute {
            equation(String.class, false, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<uint8>, tensor<uint16>, tensor<uint32>, tensor<uint64>, tensor<int8>, tensor<int16>, tensor<int32>, tensor<int64>, tensor<float16>, tensor<float>, tensor<double>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            Inputs(TypeConstraint.T.typeVariable(), Quantifier.VARIADIC),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            Output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public Einsum(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        Einsum(Einsum that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public Einsum transform(CopyContext cc, OpTransformer ot) {
            return new Einsum(this, cc);
        }
        
        Einsum(TypeElement resultType, List<Value> Inputs, String equation) {
            super(SCHEMA, resultType, Set.of(), List.of(Inputs), List.of(equation));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(Inputs()));
        }
        
        public List<Value> Inputs() {
            return operands();
        }
        
        public String equation() {
            String equation = Attribute.equation.access(String.class, onnxAttributes);
            return equation;
        }
        
    }
    
    public static Einsum Einsum(TypeElement resultType, List<Value> Inputs, String equation) {
        return new Einsum(resultType, Inputs, equation);
    }

    @OpFactory.OpDeclaration(Elu.NAME)
    public static final class Elu extends OnnxOp {
        public static final String NAME = "Elu";
        
        public enum Attribute implements OnnxAttribute {
            alpha(Float.class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<bfloat16>, tensor<float16>, tensor<float>, tensor<double>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public Elu(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        Elu(Elu that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public Elu transform(CopyContext cc, OpTransformer ot) {
            return new Elu(this, cc);
        }
        
        Elu(TypeElement resultType, Value X, java.util.Optional<Float> alpha) {
            super(SCHEMA, resultType, Set.of(), List.of(X), List.of(alpha));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X()));
        }
        
        public Value X() {
            return operands().get(0);
        }
        
        public java.util.Optional<Float> alpha() {
            Float alpha = Attribute.alpha.access(Float.class, onnxAttributes);
            return java.util.Optional.ofNullable(alpha);
        }
        
    }
    
    public static Elu Elu(TypeElement resultType, Value X, java.util.Optional<Float> alpha) {
        return new Elu(resultType, X, alpha);
    }

    @OpFactory.OpDeclaration(Equal.NAME)
    public static final class Equal extends OnnxOp {
        public static final String NAME = "Equal";
        
        public enum Attribute implements OnnxAttribute.None { }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<bool>, tensor<uint8>, tensor<uint16>, tensor<uint32>, tensor<uint64>, tensor<int8>, tensor<int16>, tensor<int32>, tensor<int64>, tensor<float16>, tensor<float>, tensor<double>, tensor<bfloat16>, tensor<string>] */))),
            T1(new OnnxType.TypeVariable("T1", List.of(/* @@@ [tensor<bool>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            A(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            B(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            C(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public Equal(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        Equal(Equal that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public Equal transform(CopyContext cc, OpTransformer ot) {
            return new Equal(this, cc);
        }
        
        Equal(TypeElement resultType, Value A, Value B) {
            super(SCHEMA, resultType, Set.of(), List.of(A, B), List.of());
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(A(), B()));
        }
        
        public Value A() {
            return operands().get(0);
        }
        
        public Value B() {
            return operands().get(1);
        }
        
    }
    
    public static Equal Equal(TypeElement resultType, Value A, Value B) {
        return new Equal(resultType, A, B);
    }

    @OpFactory.OpDeclaration(Erf.NAME)
    public static final class Erf extends OnnxOp {
        public static final String NAME = "Erf";
        
        public enum Attribute implements OnnxAttribute.None { }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<uint8>, tensor<uint16>, tensor<uint32>, tensor<uint64>, tensor<int8>, tensor<int16>, tensor<int32>, tensor<int64>, tensor<float16>, tensor<float>, tensor<double>, tensor<bfloat16>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            input(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public Erf(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        Erf(Erf that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public Erf transform(CopyContext cc, OpTransformer ot) {
            return new Erf(this, cc);
        }
        
        Erf(TypeElement resultType, Value input) {
            super(SCHEMA, resultType, Set.of(), List.of(input), List.of());
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(input()));
        }
        
        public Value input() {
            return operands().get(0);
        }
        
    }
    
    public static Erf Erf(TypeElement resultType, Value input) {
        return new Erf(resultType, input);
    }

    @OpFactory.OpDeclaration(Exp.NAME)
    public static final class Exp extends OnnxOp {
        public static final String NAME = "Exp";
        
        public enum Attribute implements OnnxAttribute.None { }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<bfloat16>, tensor<float16>, tensor<float>, tensor<double>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            input(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public Exp(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        Exp(Exp that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public Exp transform(CopyContext cc, OpTransformer ot) {
            return new Exp(this, cc);
        }
        
        Exp(TypeElement resultType, Value input) {
            super(SCHEMA, resultType, Set.of(), List.of(input), List.of());
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(input()));
        }
        
        public Value input() {
            return operands().get(0);
        }
        
    }
    
    public static Exp Exp(TypeElement resultType, Value input) {
        return new Exp(resultType, input);
    }

    @OpFactory.OpDeclaration(Expand.NAME)
    public static final class Expand extends OnnxOp {
        public static final String NAME = "Expand";
        
        public enum Attribute implements OnnxAttribute.None { }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<uint8>, tensor<uint16>, tensor<uint32>, tensor<uint64>, tensor<int8>, tensor<int16>, tensor<int32>, tensor<int64>, tensor<bfloat16>, tensor<float16>, tensor<float>, tensor<double>, tensor<string>, tensor<bool>, tensor<complex64>, tensor<complex128>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            input(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            shape(null /* @@@ tensor<int64> */, Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public Expand(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        Expand(Expand that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public Expand transform(CopyContext cc, OpTransformer ot) {
            return new Expand(this, cc);
        }
        
        Expand(TypeElement resultType, Value input, Value shape) {
            super(SCHEMA, resultType, Set.of(), List.of(input, shape), List.of());
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(input(), shape()));
        }
        
        public Value input() {
            return operands().get(0);
        }
        
        public Value shape() {
            return operands().get(1);
        }
        
    }
    
    public static Expand Expand(TypeElement resultType, Value input, Value shape) {
        return new Expand(resultType, input, shape);
    }

    @OpFactory.OpDeclaration(EyeLike.NAME)
    public static final class EyeLike extends OnnxOp {
        public static final String NAME = "EyeLike";
        
        public enum Attribute implements OnnxAttribute {
            dtype(Integer.class, true, null),
            k(Integer.class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T1(new OnnxType.TypeVariable("T1", List.of(/* @@@ [tensor<uint8>, tensor<uint16>, tensor<uint32>, tensor<uint64>, tensor<int8>, tensor<int16>, tensor<int32>, tensor<int64>, tensor<bfloat16>, tensor<float16>, tensor<float>, tensor<double>, tensor<bool>] */))),
            T2(new OnnxType.TypeVariable("T2", List.of(/* @@@ [tensor<uint8>, tensor<uint16>, tensor<uint32>, tensor<uint64>, tensor<int8>, tensor<int16>, tensor<int32>, tensor<int64>, tensor<bfloat16>, tensor<float16>, tensor<float>, tensor<double>, tensor<bool>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            input(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public EyeLike(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        EyeLike(EyeLike that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public EyeLike transform(CopyContext cc, OpTransformer ot) {
            return new EyeLike(this, cc);
        }
        
        EyeLike(TypeElement resultType, Value input, java.util.Optional<Integer> dtype, java.util.Optional<Integer> k) {
            super(SCHEMA, resultType, Set.of(), List.of(input), List.of(dtype, k));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(input()));
        }
        
        public Value input() {
            return operands().get(0);
        }
        
        public java.util.Optional<Integer> dtype() {
            Integer dtype = Attribute.dtype.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(dtype);
        }
        
        public java.util.Optional<Integer> k() {
            Integer k = Attribute.k.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(k);
        }
        
    }
    
    public static EyeLike EyeLike(TypeElement resultType, Value input, java.util.Optional<Integer> dtype, java.util.Optional<Integer> k) {
        return new EyeLike(resultType, input, dtype, k);
    }

    @OpFactory.OpDeclaration(FeatureVectorizer.NAME)
    public static final class FeatureVectorizer extends OnnxOp {
        public static final String NAME = "FeatureVectorizer";
        
        public enum Attribute implements OnnxAttribute {
            inputdimensions(int[].class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T1(new OnnxType.TypeVariable("T1", List.of(/* @@@ [tensor<int32>, tensor<int64>, tensor<float>, tensor<double>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T1.typeVariable(), Quantifier.VARIADIC),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            Y(null /* @@@ tensor<float> */, Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public FeatureVectorizer(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        FeatureVectorizer(FeatureVectorizer that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public FeatureVectorizer transform(CopyContext cc, OpTransformer ot) {
            return new FeatureVectorizer(this, cc);
        }
        
        FeatureVectorizer(TypeElement resultType, List<Value> X, java.util.Optional<int[]> inputdimensions) {
            super(SCHEMA, resultType, Set.of(), List.of(X), List.of(inputdimensions));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X()));
        }
        
        public List<Value> X() {
            return operands();
        }
        
        public java.util.Optional<int[]> inputdimensions() {
            int[] inputdimensions = Attribute.inputdimensions.access(int[].class, onnxAttributes);
            return java.util.Optional.ofNullable(inputdimensions).map(int[]::clone);
        }
        
    }
    
    public static FeatureVectorizer FeatureVectorizer(TypeElement resultType, List<Value> X, java.util.Optional<int[]> inputdimensions) {
        return new FeatureVectorizer(resultType, X, inputdimensions);
    }

    @OpFactory.OpDeclaration(Flatten.NAME)
    public static final class Flatten extends OnnxOp {
        public static final String NAME = "Flatten";
        
        public enum Attribute implements OnnxAttribute {
            axis(Integer.class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<uint8>, tensor<uint16>, tensor<uint32>, tensor<uint64>, tensor<int8>, tensor<int16>, tensor<int32>, tensor<int64>, tensor<bfloat16>, tensor<float16>, tensor<float>, tensor<double>, tensor<string>, tensor<bool>, tensor<complex64>, tensor<complex128>, tensor<float8e4m3fn>, tensor<float8e4m3fnuz>, tensor<float8e5m2>, tensor<float8e5m2fnuz>, tensor<uint4>, tensor<int4>, tensor<float4e2m1>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            input(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public Flatten(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        Flatten(Flatten that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public Flatten transform(CopyContext cc, OpTransformer ot) {
            return new Flatten(this, cc);
        }
        
        Flatten(TypeElement resultType, Value input, java.util.Optional<Integer> axis) {
            super(SCHEMA, resultType, Set.of(), List.of(input), List.of(axis));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(input()));
        }
        
        public Value input() {
            return operands().get(0);
        }
        
        public java.util.Optional<Integer> axis() {
            Integer axis = Attribute.axis.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(axis);
        }
        
    }
    
    public static Flatten Flatten(TypeElement resultType, Value input, java.util.Optional<Integer> axis) {
        return new Flatten(resultType, input, axis);
    }

    @OpFactory.OpDeclaration(Floor.NAME)
    public static final class Floor extends OnnxOp {
        public static final String NAME = "Floor";
        
        public enum Attribute implements OnnxAttribute.None { }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<float16>, tensor<float>, tensor<double>, tensor<bfloat16>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public Floor(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        Floor(Floor that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public Floor transform(CopyContext cc, OpTransformer ot) {
            return new Floor(this, cc);
        }
        
        Floor(TypeElement resultType, Value X) {
            super(SCHEMA, resultType, Set.of(), List.of(X), List.of());
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X()));
        }
        
        public Value X() {
            return operands().get(0);
        }
        
    }
    
    public static Floor Floor(TypeElement resultType, Value X) {
        return new Floor(resultType, X);
    }

    @OpFactory.OpDeclaration(GRU.NAME)
    public static final class GRU extends OnnxOp {
        public static final String NAME = "GRU";
        
        public enum Attribute implements OnnxAttribute {
            layout(Integer.class, true, null),
            activation_alpha(float[].class, true, null),
            hidden_size(Integer.class, true, null),
            activation_beta(float[].class, true, null),
            activations(String[].class, true, null),
            linear_before_reset(Integer.class, true, null),
            clip(Float.class, true, null),
            direction(String.class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<bfloat16>, tensor<float16>, tensor<float>, tensor<double>] */))),
            T1(new OnnxType.TypeVariable("T1", List.of(/* @@@ [tensor<int32>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            W(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            R(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            B(TypeConstraint.T.typeVariable(), Quantifier.OPTIONAL),
            sequence_lens(TypeConstraint.T1.typeVariable(), Quantifier.OPTIONAL),
            initial_h(TypeConstraint.T.typeVariable(), Quantifier.OPTIONAL),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T.typeVariable(), Quantifier.OPTIONAL),
            Y_h(TypeConstraint.T.typeVariable(), Quantifier.OPTIONAL),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public GRU(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        GRU(GRU that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public GRU transform(CopyContext cc, OpTransformer ot) {
            return new GRU(this, cc);
        }
        
        GRU(TypeElement resultType, Value X, Value W, Value R, java.util.Optional<Value> B, java.util.Optional<Value> sequence_lens, java.util.Optional<Value> initial_h, java.util.Optional<Integer> layout, java.util.Optional<float[]> activation_alpha, java.util.Optional<Integer> hidden_size, java.util.Optional<float[]> activation_beta, java.util.Optional<String[]> activations, java.util.Optional<Integer> linear_before_reset, java.util.Optional<Float> clip, java.util.Optional<String> direction) {
            super(SCHEMA, resultType, Set.of(), List.of(X, W, R, B, sequence_lens, initial_h), List.of(layout, activation_alpha, hidden_size, activation_beta, activations, linear_before_reset, clip, direction));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X(), W(), R(), B(), sequence_lens(), initial_h()));
        }
        
        public Value X() {
            return operands().get(0);
        }
        
        public Value W() {
            return operands().get(1);
        }
        
        public Value R() {
            return operands().get(2);
        }
        
        public java.util.Optional<Value> B() {
            int i = optionalInputArguments.indexOf(InputParameter.B);
            return i != -1 ? java.util.Optional.of(operands().get(3 + i)) : java.util.Optional.empty();
        }
        
        public java.util.Optional<Value> sequence_lens() {
            int i = optionalInputArguments.indexOf(InputParameter.sequence_lens);
            return i != -1 ? java.util.Optional.of(operands().get(3 + i)) : java.util.Optional.empty();
        }
        
        public java.util.Optional<Value> initial_h() {
            int i = optionalInputArguments.indexOf(InputParameter.initial_h);
            return i != -1 ? java.util.Optional.of(operands().get(3 + i)) : java.util.Optional.empty();
        }
        
        public java.util.Optional<Integer> layout() {
            Integer layout = Attribute.layout.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(layout);
        }
        
        public java.util.Optional<float[]> activation_alpha() {
            float[] activation_alpha = Attribute.activation_alpha.access(float[].class, onnxAttributes);
            return java.util.Optional.ofNullable(activation_alpha).map(float[]::clone);
        }
        
        public java.util.Optional<Integer> hidden_size() {
            Integer hidden_size = Attribute.hidden_size.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(hidden_size);
        }
        
        public java.util.Optional<float[]> activation_beta() {
            float[] activation_beta = Attribute.activation_beta.access(float[].class, onnxAttributes);
            return java.util.Optional.ofNullable(activation_beta).map(float[]::clone);
        }
        
        public java.util.Optional<String[]> activations() {
            String[] activations = Attribute.activations.access(String[].class, onnxAttributes);
            return java.util.Optional.ofNullable(activations).map(String[]::clone);
        }
        
        public java.util.Optional<Integer> linear_before_reset() {
            Integer linear_before_reset = Attribute.linear_before_reset.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(linear_before_reset);
        }
        
        public java.util.Optional<Float> clip() {
            Float clip = Attribute.clip.access(Float.class, onnxAttributes);
            return java.util.Optional.ofNullable(clip);
        }
        
        public java.util.Optional<String> direction() {
            String direction = Attribute.direction.access(String.class, onnxAttributes);
            return java.util.Optional.ofNullable(direction);
        }
        
    }
    
    public static GRU GRU(TypeElement resultType, Value X, Value W, Value R, java.util.Optional<Value> B, java.util.Optional<Value> sequence_lens, java.util.Optional<Value> initial_h, java.util.Optional<Integer> layout, java.util.Optional<float[]> activation_alpha, java.util.Optional<Integer> hidden_size, java.util.Optional<float[]> activation_beta, java.util.Optional<String[]> activations, java.util.Optional<Integer> linear_before_reset, java.util.Optional<Float> clip, java.util.Optional<String> direction) {
        return new GRU(resultType, X, W, R, B, sequence_lens, initial_h, layout, activation_alpha, hidden_size, activation_beta, activations, linear_before_reset, clip, direction);
    }

    @OpFactory.OpDeclaration(Gather.NAME)
    public static final class Gather extends OnnxOp {
        public static final String NAME = "Gather";
        
        public enum Attribute implements OnnxAttribute {
            axis(Integer.class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<uint8>, tensor<uint16>, tensor<uint32>, tensor<uint64>, tensor<int8>, tensor<int16>, tensor<int32>, tensor<int64>, tensor<bfloat16>, tensor<float16>, tensor<float>, tensor<double>, tensor<string>, tensor<bool>, tensor<complex64>, tensor<complex128>] */))),
            Tind(new OnnxType.TypeVariable("Tind", List.of(/* @@@ [tensor<int32>, tensor<int64>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            data(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            indices(TypeConstraint.Tind.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public Gather(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        Gather(Gather that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public Gather transform(CopyContext cc, OpTransformer ot) {
            return new Gather(this, cc);
        }
        
        Gather(TypeElement resultType, Value data, Value indices, java.util.Optional<Integer> axis) {
            super(SCHEMA, resultType, Set.of(), List.of(data, indices), List.of(axis));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(data(), indices()));
        }
        
        public Value data() {
            return operands().get(0);
        }
        
        public Value indices() {
            return operands().get(1);
        }
        
        public java.util.Optional<Integer> axis() {
            Integer axis = Attribute.axis.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(axis);
        }
        
    }
    
    public static Gather Gather(TypeElement resultType, Value data, Value indices, java.util.Optional<Integer> axis) {
        return new Gather(resultType, data, indices, axis);
    }

    @OpFactory.OpDeclaration(GatherElements.NAME)
    public static final class GatherElements extends OnnxOp {
        public static final String NAME = "GatherElements";
        
        public enum Attribute implements OnnxAttribute {
            axis(Integer.class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<uint8>, tensor<uint16>, tensor<uint32>, tensor<uint64>, tensor<int8>, tensor<int16>, tensor<int32>, tensor<int64>, tensor<bfloat16>, tensor<float16>, tensor<float>, tensor<double>, tensor<string>, tensor<bool>, tensor<complex64>, tensor<complex128>] */))),
            Tind(new OnnxType.TypeVariable("Tind", List.of(/* @@@ [tensor<int32>, tensor<int64>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            data(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            indices(TypeConstraint.Tind.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public GatherElements(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        GatherElements(GatherElements that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public GatherElements transform(CopyContext cc, OpTransformer ot) {
            return new GatherElements(this, cc);
        }
        
        GatherElements(TypeElement resultType, Value data, Value indices, java.util.Optional<Integer> axis) {
            super(SCHEMA, resultType, Set.of(), List.of(data, indices), List.of(axis));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(data(), indices()));
        }
        
        public Value data() {
            return operands().get(0);
        }
        
        public Value indices() {
            return operands().get(1);
        }
        
        public java.util.Optional<Integer> axis() {
            Integer axis = Attribute.axis.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(axis);
        }
        
    }
    
    public static GatherElements GatherElements(TypeElement resultType, Value data, Value indices, java.util.Optional<Integer> axis) {
        return new GatherElements(resultType, data, indices, axis);
    }

    @OpFactory.OpDeclaration(GatherND.NAME)
    public static final class GatherND extends OnnxOp {
        public static final String NAME = "GatherND";
        
        public enum Attribute implements OnnxAttribute {
            batch_dims(Integer.class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<uint8>, tensor<uint16>, tensor<uint32>, tensor<uint64>, tensor<int8>, tensor<int16>, tensor<int32>, tensor<int64>, tensor<bfloat16>, tensor<float16>, tensor<float>, tensor<double>, tensor<string>, tensor<bool>, tensor<complex64>, tensor<complex128>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            data(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            indices(null /* @@@ tensor<int64> */, Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public GatherND(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        GatherND(GatherND that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public GatherND transform(CopyContext cc, OpTransformer ot) {
            return new GatherND(this, cc);
        }
        
        GatherND(TypeElement resultType, Value data, Value indices, java.util.Optional<Integer> batch_dims) {
            super(SCHEMA, resultType, Set.of(), List.of(data, indices), List.of(batch_dims));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(data(), indices()));
        }
        
        public Value data() {
            return operands().get(0);
        }
        
        public Value indices() {
            return operands().get(1);
        }
        
        public java.util.Optional<Integer> batch_dims() {
            Integer batch_dims = Attribute.batch_dims.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(batch_dims);
        }
        
    }
    
    public static GatherND GatherND(TypeElement resultType, Value data, Value indices, java.util.Optional<Integer> batch_dims) {
        return new GatherND(resultType, data, indices, batch_dims);
    }

    @OpFactory.OpDeclaration(Gelu.NAME)
    public static final class Gelu extends OnnxOp {
        public static final String NAME = "Gelu";
        
        public enum Attribute implements OnnxAttribute {
            approximate(String.class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<float16>, tensor<float>, tensor<double>, tensor<bfloat16>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public Gelu(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        Gelu(Gelu that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public Gelu transform(CopyContext cc, OpTransformer ot) {
            return new Gelu(this, cc);
        }
        
        Gelu(TypeElement resultType, Value X, java.util.Optional<String> approximate) {
            super(SCHEMA, resultType, Set.of(), List.of(X), List.of(approximate));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X()));
        }
        
        public Value X() {
            return operands().get(0);
        }
        
        public java.util.Optional<String> approximate() {
            String approximate = Attribute.approximate.access(String.class, onnxAttributes);
            return java.util.Optional.ofNullable(approximate);
        }
        
    }
    
    public static Gelu Gelu(TypeElement resultType, Value X, java.util.Optional<String> approximate) {
        return new Gelu(resultType, X, approximate);
    }

    @OpFactory.OpDeclaration(Gemm.NAME)
    public static final class Gemm extends OnnxOp {
        public static final String NAME = "Gemm";
        
        public enum Attribute implements OnnxAttribute {
            alpha(Float.class, true, null),
            transB(Integer.class, true, null),
            beta(Float.class, true, null),
            transA(Integer.class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<float16>, tensor<float>, tensor<double>, tensor<uint32>, tensor<uint64>, tensor<int32>, tensor<int64>, tensor<bfloat16>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            A(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            B(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            C(TypeConstraint.T.typeVariable(), Quantifier.OPTIONAL),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public Gemm(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        Gemm(Gemm that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public Gemm transform(CopyContext cc, OpTransformer ot) {
            return new Gemm(this, cc);
        }
        
        Gemm(TypeElement resultType, Value A, Value B, java.util.Optional<Value> C, java.util.Optional<Float> alpha, java.util.Optional<Integer> transB, java.util.Optional<Float> beta, java.util.Optional<Integer> transA) {
            super(SCHEMA, resultType, Set.of(), List.of(A, B, C), List.of(alpha, transB, beta, transA));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(A(), B(), C()));
        }
        
        public Value A() {
            return operands().get(0);
        }
        
        public Value B() {
            return operands().get(1);
        }
        
        public java.util.Optional<Value> C() {
            int i = optionalInputArguments.indexOf(InputParameter.C);
            return i != -1 ? java.util.Optional.of(operands().get(2 + i)) : java.util.Optional.empty();
        }
        
        public java.util.Optional<Float> alpha() {
            Float alpha = Attribute.alpha.access(Float.class, onnxAttributes);
            return java.util.Optional.ofNullable(alpha);
        }
        
        public java.util.Optional<Integer> transB() {
            Integer transB = Attribute.transB.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(transB);
        }
        
        public java.util.Optional<Float> beta() {
            Float beta = Attribute.beta.access(Float.class, onnxAttributes);
            return java.util.Optional.ofNullable(beta);
        }
        
        public java.util.Optional<Integer> transA() {
            Integer transA = Attribute.transA.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(transA);
        }
        
    }
    
    public static Gemm Gemm(TypeElement resultType, Value A, Value B, java.util.Optional<Value> C, java.util.Optional<Float> alpha, java.util.Optional<Integer> transB, java.util.Optional<Float> beta, java.util.Optional<Integer> transA) {
        return new Gemm(resultType, A, B, C, alpha, transB, beta, transA);
    }

    @OpFactory.OpDeclaration(GlobalAveragePool.NAME)
    public static final class GlobalAveragePool extends OnnxOp {
        public static final String NAME = "GlobalAveragePool";
        
        public enum Attribute implements OnnxAttribute.None { }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<bfloat16>, tensor<float16>, tensor<float>, tensor<double>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public GlobalAveragePool(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        GlobalAveragePool(GlobalAveragePool that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public GlobalAveragePool transform(CopyContext cc, OpTransformer ot) {
            return new GlobalAveragePool(this, cc);
        }
        
        GlobalAveragePool(TypeElement resultType, Value X) {
            super(SCHEMA, resultType, Set.of(), List.of(X), List.of());
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X()));
        }
        
        public Value X() {
            return operands().get(0);
        }
        
    }
    
    public static GlobalAveragePool GlobalAveragePool(TypeElement resultType, Value X) {
        return new GlobalAveragePool(resultType, X);
    }

    @OpFactory.OpDeclaration(GlobalLpPool.NAME)
    public static final class GlobalLpPool extends OnnxOp {
        public static final String NAME = "GlobalLpPool";
        
        public enum Attribute implements OnnxAttribute {
            p(Integer.class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<bfloat16>, tensor<float16>, tensor<float>, tensor<double>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public GlobalLpPool(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        GlobalLpPool(GlobalLpPool that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public GlobalLpPool transform(CopyContext cc, OpTransformer ot) {
            return new GlobalLpPool(this, cc);
        }
        
        GlobalLpPool(TypeElement resultType, Value X, java.util.Optional<Integer> p) {
            super(SCHEMA, resultType, Set.of(), List.of(X), List.of(p));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X()));
        }
        
        public Value X() {
            return operands().get(0);
        }
        
        public java.util.Optional<Integer> p() {
            Integer p = Attribute.p.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(p);
        }
        
    }
    
    public static GlobalLpPool GlobalLpPool(TypeElement resultType, Value X, java.util.Optional<Integer> p) {
        return new GlobalLpPool(resultType, X, p);
    }

    @OpFactory.OpDeclaration(GlobalMaxPool.NAME)
    public static final class GlobalMaxPool extends OnnxOp {
        public static final String NAME = "GlobalMaxPool";
        
        public enum Attribute implements OnnxAttribute.None { }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<bfloat16>, tensor<float16>, tensor<float>, tensor<double>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public GlobalMaxPool(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        GlobalMaxPool(GlobalMaxPool that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public GlobalMaxPool transform(CopyContext cc, OpTransformer ot) {
            return new GlobalMaxPool(this, cc);
        }
        
        GlobalMaxPool(TypeElement resultType, Value X) {
            super(SCHEMA, resultType, Set.of(), List.of(X), List.of());
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X()));
        }
        
        public Value X() {
            return operands().get(0);
        }
        
    }
    
    public static GlobalMaxPool GlobalMaxPool(TypeElement resultType, Value X) {
        return new GlobalMaxPool(resultType, X);
    }

    @OpFactory.OpDeclaration(Gradient.NAME)
    public static final class Gradient extends OnnxOp {
        public static final String NAME = "Gradient";
        
        public enum Attribute implements OnnxAttribute {
            y(String.class, false, null),
            zs(String[].class, true, null),
            xs(String[].class, false, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T1(new OnnxType.TypeVariable("T1", List.of(/* @@@ [tensor<uint8>, tensor<uint16>, tensor<uint32>, tensor<uint64>, tensor<int8>, tensor<int16>, tensor<int32>, tensor<int64>, tensor<float16>, tensor<float>, tensor<double>, tensor<string>, tensor<bool>, tensor<complex64>, tensor<complex128>] */))),
            T2(new OnnxType.TypeVariable("T2", List.of(/* @@@ [tensor<float16>, tensor<float>, tensor<double>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            Inputs(TypeConstraint.T1.typeVariable(), Quantifier.VARIADIC),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            Outputs(TypeConstraint.T2.typeVariable(), Quantifier.VARIADIC),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public Gradient(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        Gradient(Gradient that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public Gradient transform(CopyContext cc, OpTransformer ot) {
            return new Gradient(this, cc);
        }
        
        Gradient(TypeElement resultType, List<Value> Inputs, String y, java.util.Optional<String[]> zs, String[] xs) {
            super(SCHEMA, resultType, Set.of(), List.of(Inputs), List.of(y, zs, xs));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(Inputs()));
        }
        
        public List<Value> Inputs() {
            return operands();
        }
        
        public String y() {
            String y = Attribute.y.access(String.class, onnxAttributes);
            return y;
        }
        
        public java.util.Optional<String[]> zs() {
            String[] zs = Attribute.zs.access(String[].class, onnxAttributes);
            return java.util.Optional.ofNullable(zs).map(String[]::clone);
        }
        
        public String[] xs() {
            String[] xs = Attribute.xs.access(String[].class, onnxAttributes);
            return xs.clone();
        }
        
    }
    
    public static Gradient Gradient(TypeElement resultType, List<Value> Inputs, String y, java.util.Optional<String[]> zs, String[] xs) {
        return new Gradient(resultType, Inputs, y, zs, xs);
    }

    @OpFactory.OpDeclaration(Greater.NAME)
    public static final class Greater extends OnnxOp {
        public static final String NAME = "Greater";
        
        public enum Attribute implements OnnxAttribute.None { }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<uint8>, tensor<uint16>, tensor<uint32>, tensor<uint64>, tensor<int8>, tensor<int16>, tensor<int32>, tensor<int64>, tensor<float16>, tensor<float>, tensor<double>, tensor<bfloat16>] */))),
            T1(new OnnxType.TypeVariable("T1", List.of(/* @@@ [tensor<bool>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            A(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            B(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            C(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public Greater(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        Greater(Greater that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public Greater transform(CopyContext cc, OpTransformer ot) {
            return new Greater(this, cc);
        }
        
        Greater(TypeElement resultType, Value A, Value B) {
            super(SCHEMA, resultType, Set.of(), List.of(A, B), List.of());
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(A(), B()));
        }
        
        public Value A() {
            return operands().get(0);
        }
        
        public Value B() {
            return operands().get(1);
        }
        
    }
    
    public static Greater Greater(TypeElement resultType, Value A, Value B) {
        return new Greater(resultType, A, B);
    }

    @OpFactory.OpDeclaration(GreaterOrEqual.NAME)
    public static final class GreaterOrEqual extends OnnxOp {
        public static final String NAME = "GreaterOrEqual";
        
        public enum Attribute implements OnnxAttribute.None { }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<uint8>, tensor<uint16>, tensor<uint32>, tensor<uint64>, tensor<int8>, tensor<int16>, tensor<int32>, tensor<int64>, tensor<float16>, tensor<float>, tensor<double>, tensor<bfloat16>] */))),
            T1(new OnnxType.TypeVariable("T1", List.of(/* @@@ [tensor<bool>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            A(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            B(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            C(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public GreaterOrEqual(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        GreaterOrEqual(GreaterOrEqual that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public GreaterOrEqual transform(CopyContext cc, OpTransformer ot) {
            return new GreaterOrEqual(this, cc);
        }
        
        GreaterOrEqual(TypeElement resultType, Value A, Value B) {
            super(SCHEMA, resultType, Set.of(), List.of(A, B), List.of());
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(A(), B()));
        }
        
        public Value A() {
            return operands().get(0);
        }
        
        public Value B() {
            return operands().get(1);
        }
        
    }
    
    public static GreaterOrEqual GreaterOrEqual(TypeElement resultType, Value A, Value B) {
        return new GreaterOrEqual(resultType, A, B);
    }

    @OpFactory.OpDeclaration(GridSample.NAME)
    public static final class GridSample extends OnnxOp {
        public static final String NAME = "GridSample";
        
        public enum Attribute implements OnnxAttribute {
            mode(String.class, true, null),
            align_corners(Integer.class, true, null),
            padding_mode(String.class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T1(new OnnxType.TypeVariable("T1", List.of(/* @@@ [tensor<uint8>, tensor<uint16>, tensor<uint32>, tensor<uint64>, tensor<int8>, tensor<int16>, tensor<int32>, tensor<int64>, tensor<bfloat16>, tensor<float16>, tensor<float>, tensor<double>, tensor<string>, tensor<bool>, tensor<complex64>, tensor<complex128>] */))),
            T2(new OnnxType.TypeVariable("T2", List.of(/* @@@ [tensor<bfloat16>, tensor<float16>, tensor<float>, tensor<double>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            grid(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public GridSample(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        GridSample(GridSample that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public GridSample transform(CopyContext cc, OpTransformer ot) {
            return new GridSample(this, cc);
        }
        
        GridSample(TypeElement resultType, Value X, Value grid, java.util.Optional<String> mode, java.util.Optional<Integer> align_corners, java.util.Optional<String> padding_mode) {
            super(SCHEMA, resultType, Set.of(), List.of(X, grid), List.of(mode, align_corners, padding_mode));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X(), grid()));
        }
        
        public Value X() {
            return operands().get(0);
        }
        
        public Value grid() {
            return operands().get(1);
        }
        
        public java.util.Optional<String> mode() {
            String mode = Attribute.mode.access(String.class, onnxAttributes);
            return java.util.Optional.ofNullable(mode);
        }
        
        public java.util.Optional<Integer> align_corners() {
            Integer align_corners = Attribute.align_corners.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(align_corners);
        }
        
        public java.util.Optional<String> padding_mode() {
            String padding_mode = Attribute.padding_mode.access(String.class, onnxAttributes);
            return java.util.Optional.ofNullable(padding_mode);
        }
        
    }
    
    public static GridSample GridSample(TypeElement resultType, Value X, Value grid, java.util.Optional<String> mode, java.util.Optional<Integer> align_corners, java.util.Optional<String> padding_mode) {
        return new GridSample(resultType, X, grid, mode, align_corners, padding_mode);
    }

    @OpFactory.OpDeclaration(GroupNormalization.NAME)
    public static final class GroupNormalization extends OnnxOp {
        public static final String NAME = "GroupNormalization";
        
        public enum Attribute implements OnnxAttribute {
            epsilon(Float.class, true, null),
            stash_type(Integer.class, true, null),
            num_groups(Integer.class, false, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<bfloat16>, tensor<float16>, tensor<float>, tensor<double>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            scale(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            bias(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public GroupNormalization(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        GroupNormalization(GroupNormalization that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public GroupNormalization transform(CopyContext cc, OpTransformer ot) {
            return new GroupNormalization(this, cc);
        }
        
        GroupNormalization(TypeElement resultType, Value X, Value scale, Value bias, java.util.Optional<Float> epsilon, java.util.Optional<Integer> stash_type, int num_groups) {
            super(SCHEMA, resultType, Set.of(), List.of(X, scale, bias), List.of(epsilon, stash_type, num_groups));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X(), scale(), bias()));
        }
        
        public Value X() {
            return operands().get(0);
        }
        
        public Value scale() {
            return operands().get(1);
        }
        
        public Value bias() {
            return operands().get(2);
        }
        
        public java.util.Optional<Float> epsilon() {
            Float epsilon = Attribute.epsilon.access(Float.class, onnxAttributes);
            return java.util.Optional.ofNullable(epsilon);
        }
        
        public java.util.Optional<Integer> stash_type() {
            Integer stash_type = Attribute.stash_type.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(stash_type);
        }
        
        public int num_groups() {
            int num_groups = Attribute.num_groups.access(int.class, onnxAttributes);
            return num_groups;
        }
        
    }
    
    public static GroupNormalization GroupNormalization(TypeElement resultType, Value X, Value scale, Value bias, java.util.Optional<Float> epsilon, java.util.Optional<Integer> stash_type, int num_groups) {
        return new GroupNormalization(resultType, X, scale, bias, epsilon, stash_type, num_groups);
    }

    @OpFactory.OpDeclaration(HammingWindow.NAME)
    public static final class HammingWindow extends OnnxOp {
        public static final String NAME = "HammingWindow";
        
        public enum Attribute implements OnnxAttribute {
            periodic(Integer.class, true, null),
            output_datatype(Integer.class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T1(new OnnxType.TypeVariable("T1", List.of(/* @@@ [tensor<int32>, tensor<int64>] */))),
            T2(new OnnxType.TypeVariable("T2", List.of(/* @@@ [tensor<uint8>, tensor<uint16>, tensor<uint32>, tensor<uint64>, tensor<int8>, tensor<int16>, tensor<int32>, tensor<int64>, tensor<float16>, tensor<float>, tensor<double>, tensor<bfloat16>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            size(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public HammingWindow(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        HammingWindow(HammingWindow that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public HammingWindow transform(CopyContext cc, OpTransformer ot) {
            return new HammingWindow(this, cc);
        }
        
        HammingWindow(TypeElement resultType, Value size, java.util.Optional<Integer> periodic, java.util.Optional<Integer> output_datatype) {
            super(SCHEMA, resultType, Set.of(), List.of(size), List.of(periodic, output_datatype));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(size()));
        }
        
        public Value size() {
            return operands().get(0);
        }
        
        public java.util.Optional<Integer> periodic() {
            Integer periodic = Attribute.periodic.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(periodic);
        }
        
        public java.util.Optional<Integer> output_datatype() {
            Integer output_datatype = Attribute.output_datatype.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(output_datatype);
        }
        
    }
    
    public static HammingWindow HammingWindow(TypeElement resultType, Value size, java.util.Optional<Integer> periodic, java.util.Optional<Integer> output_datatype) {
        return new HammingWindow(resultType, size, periodic, output_datatype);
    }

    @OpFactory.OpDeclaration(HannWindow.NAME)
    public static final class HannWindow extends OnnxOp {
        public static final String NAME = "HannWindow";
        
        public enum Attribute implements OnnxAttribute {
            periodic(Integer.class, true, null),
            output_datatype(Integer.class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T1(new OnnxType.TypeVariable("T1", List.of(/* @@@ [tensor<int32>, tensor<int64>] */))),
            T2(new OnnxType.TypeVariable("T2", List.of(/* @@@ [tensor<uint8>, tensor<uint16>, tensor<uint32>, tensor<uint64>, tensor<int8>, tensor<int16>, tensor<int32>, tensor<int64>, tensor<float16>, tensor<float>, tensor<double>, tensor<bfloat16>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            size(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public HannWindow(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        HannWindow(HannWindow that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public HannWindow transform(CopyContext cc, OpTransformer ot) {
            return new HannWindow(this, cc);
        }
        
        HannWindow(TypeElement resultType, Value size, java.util.Optional<Integer> periodic, java.util.Optional<Integer> output_datatype) {
            super(SCHEMA, resultType, Set.of(), List.of(size), List.of(periodic, output_datatype));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(size()));
        }
        
        public Value size() {
            return operands().get(0);
        }
        
        public java.util.Optional<Integer> periodic() {
            Integer periodic = Attribute.periodic.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(periodic);
        }
        
        public java.util.Optional<Integer> output_datatype() {
            Integer output_datatype = Attribute.output_datatype.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(output_datatype);
        }
        
    }
    
    public static HannWindow HannWindow(TypeElement resultType, Value size, java.util.Optional<Integer> periodic, java.util.Optional<Integer> output_datatype) {
        return new HannWindow(resultType, size, periodic, output_datatype);
    }

    @OpFactory.OpDeclaration(HardSigmoid.NAME)
    public static final class HardSigmoid extends OnnxOp {
        public static final String NAME = "HardSigmoid";
        
        public enum Attribute implements OnnxAttribute {
            alpha(Float.class, true, null),
            beta(Float.class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<bfloat16>, tensor<float16>, tensor<float>, tensor<double>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public HardSigmoid(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        HardSigmoid(HardSigmoid that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public HardSigmoid transform(CopyContext cc, OpTransformer ot) {
            return new HardSigmoid(this, cc);
        }
        
        HardSigmoid(TypeElement resultType, Value X, java.util.Optional<Float> alpha, java.util.Optional<Float> beta) {
            super(SCHEMA, resultType, Set.of(), List.of(X), List.of(alpha, beta));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X()));
        }
        
        public Value X() {
            return operands().get(0);
        }
        
        public java.util.Optional<Float> alpha() {
            Float alpha = Attribute.alpha.access(Float.class, onnxAttributes);
            return java.util.Optional.ofNullable(alpha);
        }
        
        public java.util.Optional<Float> beta() {
            Float beta = Attribute.beta.access(Float.class, onnxAttributes);
            return java.util.Optional.ofNullable(beta);
        }
        
    }
    
    public static HardSigmoid HardSigmoid(TypeElement resultType, Value X, java.util.Optional<Float> alpha, java.util.Optional<Float> beta) {
        return new HardSigmoid(resultType, X, alpha, beta);
    }

    @OpFactory.OpDeclaration(HardSwish.NAME)
    public static final class HardSwish extends OnnxOp {
        public static final String NAME = "HardSwish";
        
        public enum Attribute implements OnnxAttribute.None { }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<bfloat16>, tensor<float16>, tensor<float>, tensor<double>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public HardSwish(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        HardSwish(HardSwish that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public HardSwish transform(CopyContext cc, OpTransformer ot) {
            return new HardSwish(this, cc);
        }
        
        HardSwish(TypeElement resultType, Value X) {
            super(SCHEMA, resultType, Set.of(), List.of(X), List.of());
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X()));
        }
        
        public Value X() {
            return operands().get(0);
        }
        
    }
    
    public static HardSwish HardSwish(TypeElement resultType, Value X) {
        return new HardSwish(resultType, X);
    }

    @OpFactory.OpDeclaration(Hardmax.NAME)
    public static final class Hardmax extends OnnxOp {
        public static final String NAME = "Hardmax";
        
        public enum Attribute implements OnnxAttribute {
            axis(Integer.class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<float16>, tensor<float>, tensor<double>, tensor<bfloat16>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            input(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public Hardmax(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        Hardmax(Hardmax that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public Hardmax transform(CopyContext cc, OpTransformer ot) {
            return new Hardmax(this, cc);
        }
        
        Hardmax(TypeElement resultType, Value input, java.util.Optional<Integer> axis) {
            super(SCHEMA, resultType, Set.of(), List.of(input), List.of(axis));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(input()));
        }
        
        public Value input() {
            return operands().get(0);
        }
        
        public java.util.Optional<Integer> axis() {
            Integer axis = Attribute.axis.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(axis);
        }
        
    }
    
    public static Hardmax Hardmax(TypeElement resultType, Value input, java.util.Optional<Integer> axis) {
        return new Hardmax(resultType, input, axis);
    }

    @OpFactory.OpDeclaration(Identity.NAME)
    public static final class Identity extends OnnxOp {
        public static final String NAME = "Identity";
        
        public enum Attribute implements OnnxAttribute.None { }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            V(new OnnxType.TypeVariable("V", List.of(/* @@@ [tensor<uint8>, tensor<uint16>, tensor<uint32>, tensor<uint64>, tensor<int8>, tensor<int16>, tensor<int32>, tensor<int64>, tensor<bfloat16>, tensor<float16>, tensor<float>, tensor<double>, tensor<string>, tensor<bool>, tensor<complex64>, tensor<complex128>, tensor<float8e4m3fn>, tensor<float8e4m3fnuz>, tensor<float8e5m2>, tensor<float8e5m2fnuz>, tensor<uint4>, tensor<int4>, tensor<float4e2m1>, seq<tensor<uint8>>, seq<tensor<uint16>>, seq<tensor<uint32>>, seq<tensor<uint64>>, seq<tensor<int8>>, seq<tensor<int16>>, seq<tensor<int32>>, seq<tensor<int64>>, seq<tensor<float16>>, seq<tensor<float>>, seq<tensor<double>>, seq<tensor<string>>, seq<tensor<bool>>, seq<tensor<complex64>>, seq<tensor<complex128>>, optional<seq<tensor<uint8>>>, optional<seq<tensor<uint16>>>, optional<seq<tensor<uint32>>>, optional<seq<tensor<uint64>>>, optional<seq<tensor<int8>>>, optional<seq<tensor<int16>>>, optional<seq<tensor<int32>>>, optional<seq<tensor<int64>>>, optional<seq<tensor<float16>>>, optional<seq<tensor<float>>>, optional<seq<tensor<double>>>, optional<seq<tensor<string>>>, optional<seq<tensor<bool>>>, optional<seq<tensor<complex64>>>, optional<seq<tensor<complex128>>>, optional<tensor<uint8>>, optional<tensor<uint16>>, optional<tensor<uint32>>, optional<tensor<uint64>>, optional<tensor<int8>>, optional<tensor<int16>>, optional<tensor<int32>>, optional<tensor<int64>>, optional<tensor<float16>>, optional<tensor<float>>, optional<tensor<double>>, optional<tensor<string>>, optional<tensor<bool>>, optional<tensor<complex64>>, optional<tensor<complex128>>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            input(TypeConstraint.V.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.V.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public Identity(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        Identity(Identity that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public Identity transform(CopyContext cc, OpTransformer ot) {
            return new Identity(this, cc);
        }
        
        Identity(TypeElement resultType, Value input) {
            super(SCHEMA, resultType, Set.of(), List.of(input), List.of());
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(input()));
        }
        
        public Value input() {
            return operands().get(0);
        }
        
    }
    
    public static Identity Identity(TypeElement resultType, Value input) {
        return new Identity(resultType, input);
    }

    @OpFactory.OpDeclaration(ImageDecoder.NAME)
    public static final class ImageDecoder extends OnnxOp {
        public static final String NAME = "ImageDecoder";
        
        public enum Attribute implements OnnxAttribute {
            pixel_format(String.class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T1(new OnnxType.TypeVariable("T1", List.of(/* @@@ [tensor<uint8>] */))),
            T2(new OnnxType.TypeVariable("T2", List.of(/* @@@ [tensor<uint8>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            encoded_stream(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            image(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public ImageDecoder(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        ImageDecoder(ImageDecoder that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public ImageDecoder transform(CopyContext cc, OpTransformer ot) {
            return new ImageDecoder(this, cc);
        }
        
        ImageDecoder(TypeElement resultType, Value encoded_stream, java.util.Optional<String> pixel_format) {
            super(SCHEMA, resultType, Set.of(), List.of(encoded_stream), List.of(pixel_format));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(encoded_stream()));
        }
        
        public Value encoded_stream() {
            return operands().get(0);
        }
        
        public java.util.Optional<String> pixel_format() {
            String pixel_format = Attribute.pixel_format.access(String.class, onnxAttributes);
            return java.util.Optional.ofNullable(pixel_format);
        }
        
    }
    
    public static ImageDecoder ImageDecoder(TypeElement resultType, Value encoded_stream, java.util.Optional<String> pixel_format) {
        return new ImageDecoder(resultType, encoded_stream, pixel_format);
    }

    @OpFactory.OpDeclaration(Imputer.NAME)
    public static final class Imputer extends OnnxOp {
        public static final String NAME = "Imputer";
        
        public enum Attribute implements OnnxAttribute {
            replaced_value_int64(Integer.class, true, null),
            replaced_value_float(Float.class, true, null),
            imputed_value_int64s(int[].class, true, null),
            imputed_value_floats(float[].class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<float>, tensor<double>, tensor<int64>, tensor<int32>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public Imputer(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        Imputer(Imputer that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public Imputer transform(CopyContext cc, OpTransformer ot) {
            return new Imputer(this, cc);
        }
        
        Imputer(TypeElement resultType, Value X, java.util.Optional<Integer> replaced_value_int64, java.util.Optional<Float> replaced_value_float, java.util.Optional<int[]> imputed_value_int64s, java.util.Optional<float[]> imputed_value_floats) {
            super(SCHEMA, resultType, Set.of(), List.of(X), List.of(replaced_value_int64, replaced_value_float, imputed_value_int64s, imputed_value_floats));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X()));
        }
        
        public Value X() {
            return operands().get(0);
        }
        
        public java.util.Optional<Integer> replaced_value_int64() {
            Integer replaced_value_int64 = Attribute.replaced_value_int64.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(replaced_value_int64);
        }
        
        public java.util.Optional<Float> replaced_value_float() {
            Float replaced_value_float = Attribute.replaced_value_float.access(Float.class, onnxAttributes);
            return java.util.Optional.ofNullable(replaced_value_float);
        }
        
        public java.util.Optional<int[]> imputed_value_int64s() {
            int[] imputed_value_int64s = Attribute.imputed_value_int64s.access(int[].class, onnxAttributes);
            return java.util.Optional.ofNullable(imputed_value_int64s).map(int[]::clone);
        }
        
        public java.util.Optional<float[]> imputed_value_floats() {
            float[] imputed_value_floats = Attribute.imputed_value_floats.access(float[].class, onnxAttributes);
            return java.util.Optional.ofNullable(imputed_value_floats).map(float[]::clone);
        }
        
    }
    
    public static Imputer Imputer(TypeElement resultType, Value X, java.util.Optional<Integer> replaced_value_int64, java.util.Optional<Float> replaced_value_float, java.util.Optional<int[]> imputed_value_int64s, java.util.Optional<float[]> imputed_value_floats) {
        return new Imputer(resultType, X, replaced_value_int64, replaced_value_float, imputed_value_int64s, imputed_value_floats);
    }

    @OpFactory.OpDeclaration(InstanceNormalization.NAME)
    public static final class InstanceNormalization extends OnnxOp {
        public static final String NAME = "InstanceNormalization";
        
        public enum Attribute implements OnnxAttribute {
            epsilon(Float.class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<bfloat16>, tensor<float16>, tensor<float>, tensor<double>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            input(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            scale(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            B(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public InstanceNormalization(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        InstanceNormalization(InstanceNormalization that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public InstanceNormalization transform(CopyContext cc, OpTransformer ot) {
            return new InstanceNormalization(this, cc);
        }
        
        InstanceNormalization(TypeElement resultType, Value input, Value scale, Value B, java.util.Optional<Float> epsilon) {
            super(SCHEMA, resultType, Set.of(), List.of(input, scale, B), List.of(epsilon));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(input(), scale(), B()));
        }
        
        public Value input() {
            return operands().get(0);
        }
        
        public Value scale() {
            return operands().get(1);
        }
        
        public Value B() {
            return operands().get(2);
        }
        
        public java.util.Optional<Float> epsilon() {
            Float epsilon = Attribute.epsilon.access(Float.class, onnxAttributes);
            return java.util.Optional.ofNullable(epsilon);
        }
        
    }
    
    public static InstanceNormalization InstanceNormalization(TypeElement resultType, Value input, Value scale, Value B, java.util.Optional<Float> epsilon) {
        return new InstanceNormalization(resultType, input, scale, B, epsilon);
    }

    @OpFactory.OpDeclaration(IsInf.NAME)
    public static final class IsInf extends OnnxOp {
        public static final String NAME = "IsInf";
        
        public enum Attribute implements OnnxAttribute {
            detect_negative(Integer.class, true, null),
            detect_positive(Integer.class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T1(new OnnxType.TypeVariable("T1", List.of(/* @@@ [tensor<bfloat16>, tensor<float16>, tensor<float>, tensor<double>, tensor<float8e4m3fn>, tensor<float8e4m3fnuz>, tensor<float8e5m2>, tensor<float8e5m2fnuz>] */))),
            T2(new OnnxType.TypeVariable("T2", List.of(/* @@@ [tensor<bool>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public IsInf(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        IsInf(IsInf that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public IsInf transform(CopyContext cc, OpTransformer ot) {
            return new IsInf(this, cc);
        }
        
        IsInf(TypeElement resultType, Value X, java.util.Optional<Integer> detect_negative, java.util.Optional<Integer> detect_positive) {
            super(SCHEMA, resultType, Set.of(), List.of(X), List.of(detect_negative, detect_positive));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X()));
        }
        
        public Value X() {
            return operands().get(0);
        }
        
        public java.util.Optional<Integer> detect_negative() {
            Integer detect_negative = Attribute.detect_negative.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(detect_negative);
        }
        
        public java.util.Optional<Integer> detect_positive() {
            Integer detect_positive = Attribute.detect_positive.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(detect_positive);
        }
        
    }
    
    public static IsInf IsInf(TypeElement resultType, Value X, java.util.Optional<Integer> detect_negative, java.util.Optional<Integer> detect_positive) {
        return new IsInf(resultType, X, detect_negative, detect_positive);
    }

    @OpFactory.OpDeclaration(IsNaN.NAME)
    public static final class IsNaN extends OnnxOp {
        public static final String NAME = "IsNaN";
        
        public enum Attribute implements OnnxAttribute.None { }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T1(new OnnxType.TypeVariable("T1", List.of(/* @@@ [tensor<bfloat16>, tensor<float16>, tensor<float>, tensor<double>, tensor<float8e4m3fn>, tensor<float8e4m3fnuz>, tensor<float8e5m2>, tensor<float8e5m2fnuz>] */))),
            T2(new OnnxType.TypeVariable("T2", List.of(/* @@@ [tensor<bool>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public IsNaN(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        IsNaN(IsNaN that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public IsNaN transform(CopyContext cc, OpTransformer ot) {
            return new IsNaN(this, cc);
        }
        
        IsNaN(TypeElement resultType, Value X) {
            super(SCHEMA, resultType, Set.of(), List.of(X), List.of());
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X()));
        }
        
        public Value X() {
            return operands().get(0);
        }
        
    }
    
    public static IsNaN IsNaN(TypeElement resultType, Value X) {
        return new IsNaN(resultType, X);
    }

    @OpFactory.OpDeclaration(LRN.NAME)
    public static final class LRN extends OnnxOp {
        public static final String NAME = "LRN";
        
        public enum Attribute implements OnnxAttribute {
            size(Integer.class, false, null),
            alpha(Float.class, true, null),
            bias(Float.class, true, null),
            beta(Float.class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<float16>, tensor<float>, tensor<double>, tensor<bfloat16>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public LRN(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        LRN(LRN that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public LRN transform(CopyContext cc, OpTransformer ot) {
            return new LRN(this, cc);
        }
        
        LRN(TypeElement resultType, Value X, int size, java.util.Optional<Float> alpha, java.util.Optional<Float> bias, java.util.Optional<Float> beta) {
            super(SCHEMA, resultType, Set.of(), List.of(X), List.of(size, alpha, bias, beta));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X()));
        }
        
        public Value X() {
            return operands().get(0);
        }
        
        public int size() {
            int size = Attribute.size.access(int.class, onnxAttributes);
            return size;
        }
        
        public java.util.Optional<Float> alpha() {
            Float alpha = Attribute.alpha.access(Float.class, onnxAttributes);
            return java.util.Optional.ofNullable(alpha);
        }
        
        public java.util.Optional<Float> bias() {
            Float bias = Attribute.bias.access(Float.class, onnxAttributes);
            return java.util.Optional.ofNullable(bias);
        }
        
        public java.util.Optional<Float> beta() {
            Float beta = Attribute.beta.access(Float.class, onnxAttributes);
            return java.util.Optional.ofNullable(beta);
        }
        
    }
    
    public static LRN LRN(TypeElement resultType, Value X, int size, java.util.Optional<Float> alpha, java.util.Optional<Float> bias, java.util.Optional<Float> beta) {
        return new LRN(resultType, X, size, alpha, bias, beta);
    }

    @OpFactory.OpDeclaration(LSTM.NAME)
    public static final class LSTM extends OnnxOp {
        public static final String NAME = "LSTM";
        
        public enum Attribute implements OnnxAttribute {
            layout(Integer.class, true, null),
            input_forget(Integer.class, true, null),
            activation_alpha(float[].class, true, null),
            hidden_size(Integer.class, true, null),
            activation_beta(float[].class, true, null),
            activations(String[].class, true, null),
            clip(Float.class, true, null),
            direction(String.class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<bfloat16>, tensor<float16>, tensor<float>, tensor<double>] */))),
            T1(new OnnxType.TypeVariable("T1", List.of(/* @@@ [tensor<int32>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            W(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            R(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            B(TypeConstraint.T.typeVariable(), Quantifier.OPTIONAL),
            sequence_lens(TypeConstraint.T1.typeVariable(), Quantifier.OPTIONAL),
            initial_h(TypeConstraint.T.typeVariable(), Quantifier.OPTIONAL),
            initial_c(TypeConstraint.T.typeVariable(), Quantifier.OPTIONAL),
            P(TypeConstraint.T.typeVariable(), Quantifier.OPTIONAL),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T.typeVariable(), Quantifier.OPTIONAL),
            Y_h(TypeConstraint.T.typeVariable(), Quantifier.OPTIONAL),
            Y_c(TypeConstraint.T.typeVariable(), Quantifier.OPTIONAL),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public LSTM(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        LSTM(LSTM that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public LSTM transform(CopyContext cc, OpTransformer ot) {
            return new LSTM(this, cc);
        }
        
        LSTM(TypeElement resultType, Value X, Value W, Value R, java.util.Optional<Value> B, java.util.Optional<Value> sequence_lens, java.util.Optional<Value> initial_h, java.util.Optional<Value> initial_c, java.util.Optional<Value> P, java.util.Optional<Integer> layout, java.util.Optional<Integer> input_forget, java.util.Optional<float[]> activation_alpha, java.util.Optional<Integer> hidden_size, java.util.Optional<float[]> activation_beta, java.util.Optional<String[]> activations, java.util.Optional<Float> clip, java.util.Optional<String> direction) {
            super(SCHEMA, resultType, Set.of(), List.of(X, W, R, B, sequence_lens, initial_h, initial_c, P), List.of(layout, input_forget, activation_alpha, hidden_size, activation_beta, activations, clip, direction));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X(), W(), R(), B(), sequence_lens(), initial_h(), initial_c(), P()));
        }
        
        public Value X() {
            return operands().get(0);
        }
        
        public Value W() {
            return operands().get(1);
        }
        
        public Value R() {
            return operands().get(2);
        }
        
        public java.util.Optional<Value> B() {
            int i = optionalInputArguments.indexOf(InputParameter.B);
            return i != -1 ? java.util.Optional.of(operands().get(3 + i)) : java.util.Optional.empty();
        }
        
        public java.util.Optional<Value> sequence_lens() {
            int i = optionalInputArguments.indexOf(InputParameter.sequence_lens);
            return i != -1 ? java.util.Optional.of(operands().get(3 + i)) : java.util.Optional.empty();
        }
        
        public java.util.Optional<Value> initial_h() {
            int i = optionalInputArguments.indexOf(InputParameter.initial_h);
            return i != -1 ? java.util.Optional.of(operands().get(3 + i)) : java.util.Optional.empty();
        }
        
        public java.util.Optional<Value> initial_c() {
            int i = optionalInputArguments.indexOf(InputParameter.initial_c);
            return i != -1 ? java.util.Optional.of(operands().get(3 + i)) : java.util.Optional.empty();
        }
        
        public java.util.Optional<Value> P() {
            int i = optionalInputArguments.indexOf(InputParameter.P);
            return i != -1 ? java.util.Optional.of(operands().get(3 + i)) : java.util.Optional.empty();
        }
        
        public java.util.Optional<Integer> layout() {
            Integer layout = Attribute.layout.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(layout);
        }
        
        public java.util.Optional<Integer> input_forget() {
            Integer input_forget = Attribute.input_forget.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(input_forget);
        }
        
        public java.util.Optional<float[]> activation_alpha() {
            float[] activation_alpha = Attribute.activation_alpha.access(float[].class, onnxAttributes);
            return java.util.Optional.ofNullable(activation_alpha).map(float[]::clone);
        }
        
        public java.util.Optional<Integer> hidden_size() {
            Integer hidden_size = Attribute.hidden_size.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(hidden_size);
        }
        
        public java.util.Optional<float[]> activation_beta() {
            float[] activation_beta = Attribute.activation_beta.access(float[].class, onnxAttributes);
            return java.util.Optional.ofNullable(activation_beta).map(float[]::clone);
        }
        
        public java.util.Optional<String[]> activations() {
            String[] activations = Attribute.activations.access(String[].class, onnxAttributes);
            return java.util.Optional.ofNullable(activations).map(String[]::clone);
        }
        
        public java.util.Optional<Float> clip() {
            Float clip = Attribute.clip.access(Float.class, onnxAttributes);
            return java.util.Optional.ofNullable(clip);
        }
        
        public java.util.Optional<String> direction() {
            String direction = Attribute.direction.access(String.class, onnxAttributes);
            return java.util.Optional.ofNullable(direction);
        }
        
    }
    
    public static LSTM LSTM(TypeElement resultType, Value X, Value W, Value R, java.util.Optional<Value> B, java.util.Optional<Value> sequence_lens, java.util.Optional<Value> initial_h, java.util.Optional<Value> initial_c, java.util.Optional<Value> P, java.util.Optional<Integer> layout, java.util.Optional<Integer> input_forget, java.util.Optional<float[]> activation_alpha, java.util.Optional<Integer> hidden_size, java.util.Optional<float[]> activation_beta, java.util.Optional<String[]> activations, java.util.Optional<Float> clip, java.util.Optional<String> direction) {
        return new LSTM(resultType, X, W, R, B, sequence_lens, initial_h, initial_c, P, layout, input_forget, activation_alpha, hidden_size, activation_beta, activations, clip, direction);
    }

    @OpFactory.OpDeclaration(LabelEncoder.NAME)
    public static final class LabelEncoder extends OnnxOp {
        public static final String NAME = "LabelEncoder";
        
        public enum Attribute implements OnnxAttribute {
            values_strings(String[].class, true, null),
            keys_int64s(int[].class, true, null),
            keys_tensor(Tensor.class, true, null),
            keys_strings(String[].class, true, null),
            default_float(Float.class, true, null),
            keys_floats(float[].class, true, null),
            default_tensor(Tensor.class, true, null),
            default_int64(Integer.class, true, null),
            values_tensor(Tensor.class, true, null),
            values_int64s(int[].class, true, null),
            default_string(String.class, true, null),
            values_floats(float[].class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T1(new OnnxType.TypeVariable("T1", List.of(/* @@@ [tensor<string>, tensor<int64>, tensor<float>, tensor<int32>, tensor<int16>, tensor<double>] */))),
            T2(new OnnxType.TypeVariable("T2", List.of(/* @@@ [tensor<string>, tensor<int64>, tensor<float>, tensor<int32>, tensor<int16>, tensor<double>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public LabelEncoder(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        LabelEncoder(LabelEncoder that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public LabelEncoder transform(CopyContext cc, OpTransformer ot) {
            return new LabelEncoder(this, cc);
        }
        
        LabelEncoder(TypeElement resultType, Value X, java.util.Optional<String[]> values_strings, java.util.Optional<int[]> keys_int64s, java.util.Optional<Tensor<?>> keys_tensor, java.util.Optional<String[]> keys_strings, java.util.Optional<Float> default_float, java.util.Optional<float[]> keys_floats, java.util.Optional<Tensor<?>> default_tensor, java.util.Optional<Integer> default_int64, java.util.Optional<Tensor<?>> values_tensor, java.util.Optional<int[]> values_int64s, java.util.Optional<String> default_string, java.util.Optional<float[]> values_floats) {
            super(SCHEMA, resultType, Set.of(), List.of(X), List.of(values_strings, keys_int64s, keys_tensor, keys_strings, default_float, keys_floats, default_tensor, default_int64, values_tensor, values_int64s, default_string, values_floats));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X()));
        }
        
        public Value X() {
            return operands().get(0);
        }
        
        public java.util.Optional<String[]> values_strings() {
            String[] values_strings = Attribute.values_strings.access(String[].class, onnxAttributes);
            return java.util.Optional.ofNullable(values_strings).map(String[]::clone);
        }
        
        public java.util.Optional<int[]> keys_int64s() {
            int[] keys_int64s = Attribute.keys_int64s.access(int[].class, onnxAttributes);
            return java.util.Optional.ofNullable(keys_int64s).map(int[]::clone);
        }
        
        public java.util.Optional<Tensor<?>> keys_tensor() {
            Tensor<?> keys_tensor = Attribute.keys_tensor.access(Tensor.class, onnxAttributes);
            return java.util.Optional.ofNullable(keys_tensor);
        }
        
        public java.util.Optional<String[]> keys_strings() {
            String[] keys_strings = Attribute.keys_strings.access(String[].class, onnxAttributes);
            return java.util.Optional.ofNullable(keys_strings).map(String[]::clone);
        }
        
        public java.util.Optional<Float> default_float() {
            Float default_float = Attribute.default_float.access(Float.class, onnxAttributes);
            return java.util.Optional.ofNullable(default_float);
        }
        
        public java.util.Optional<float[]> keys_floats() {
            float[] keys_floats = Attribute.keys_floats.access(float[].class, onnxAttributes);
            return java.util.Optional.ofNullable(keys_floats).map(float[]::clone);
        }
        
        public java.util.Optional<Tensor<?>> default_tensor() {
            Tensor<?> default_tensor = Attribute.default_tensor.access(Tensor.class, onnxAttributes);
            return java.util.Optional.ofNullable(default_tensor);
        }
        
        public java.util.Optional<Integer> default_int64() {
            Integer default_int64 = Attribute.default_int64.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(default_int64);
        }
        
        public java.util.Optional<Tensor<?>> values_tensor() {
            Tensor<?> values_tensor = Attribute.values_tensor.access(Tensor.class, onnxAttributes);
            return java.util.Optional.ofNullable(values_tensor);
        }
        
        public java.util.Optional<int[]> values_int64s() {
            int[] values_int64s = Attribute.values_int64s.access(int[].class, onnxAttributes);
            return java.util.Optional.ofNullable(values_int64s).map(int[]::clone);
        }
        
        public java.util.Optional<String> default_string() {
            String default_string = Attribute.default_string.access(String.class, onnxAttributes);
            return java.util.Optional.ofNullable(default_string);
        }
        
        public java.util.Optional<float[]> values_floats() {
            float[] values_floats = Attribute.values_floats.access(float[].class, onnxAttributes);
            return java.util.Optional.ofNullable(values_floats).map(float[]::clone);
        }
        
    }
    
    public static LabelEncoder LabelEncoder(TypeElement resultType, Value X, java.util.Optional<String[]> values_strings, java.util.Optional<int[]> keys_int64s, java.util.Optional<Tensor<?>> keys_tensor, java.util.Optional<String[]> keys_strings, java.util.Optional<Float> default_float, java.util.Optional<float[]> keys_floats, java.util.Optional<Tensor<?>> default_tensor, java.util.Optional<Integer> default_int64, java.util.Optional<Tensor<?>> values_tensor, java.util.Optional<int[]> values_int64s, java.util.Optional<String> default_string, java.util.Optional<float[]> values_floats) {
        return new LabelEncoder(resultType, X, values_strings, keys_int64s, keys_tensor, keys_strings, default_float, keys_floats, default_tensor, default_int64, values_tensor, values_int64s, default_string, values_floats);
    }

    @OpFactory.OpDeclaration(LayerNormalization.NAME)
    public static final class LayerNormalization extends OnnxOp {
        public static final String NAME = "LayerNormalization";
        
        public enum Attribute implements OnnxAttribute {
            epsilon(Float.class, true, null),
            stash_type(Integer.class, true, null),
            axis(Integer.class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<float16>, tensor<float>, tensor<double>, tensor<bfloat16>] */))),
            U(new OnnxType.TypeVariable("U", List.of(/* @@@ [tensor<float>, tensor<bfloat16>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            Scale(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            B(TypeConstraint.T.typeVariable(), Quantifier.OPTIONAL),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            Mean(TypeConstraint.U.typeVariable(), Quantifier.OPTIONAL),
            InvStdDev(TypeConstraint.U.typeVariable(), Quantifier.OPTIONAL),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public LayerNormalization(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        LayerNormalization(LayerNormalization that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public LayerNormalization transform(CopyContext cc, OpTransformer ot) {
            return new LayerNormalization(this, cc);
        }
        
        LayerNormalization(TypeElement resultType, Value X, Value Scale, java.util.Optional<Value> B, java.util.Optional<Float> epsilon, java.util.Optional<Integer> stash_type, java.util.Optional<Integer> axis) {
            super(SCHEMA, resultType, Set.of(), List.of(X, Scale, B), List.of(epsilon, stash_type, axis));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X(), Scale(), B()));
        }
        
        public Value X() {
            return operands().get(0);
        }
        
        public Value Scale() {
            return operands().get(1);
        }
        
        public java.util.Optional<Value> B() {
            int i = optionalInputArguments.indexOf(InputParameter.B);
            return i != -1 ? java.util.Optional.of(operands().get(2 + i)) : java.util.Optional.empty();
        }
        
        public java.util.Optional<Float> epsilon() {
            Float epsilon = Attribute.epsilon.access(Float.class, onnxAttributes);
            return java.util.Optional.ofNullable(epsilon);
        }
        
        public java.util.Optional<Integer> stash_type() {
            Integer stash_type = Attribute.stash_type.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(stash_type);
        }
        
        public java.util.Optional<Integer> axis() {
            Integer axis = Attribute.axis.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(axis);
        }
        
    }
    
    public static LayerNormalization LayerNormalization(TypeElement resultType, Value X, Value Scale, java.util.Optional<Value> B, java.util.Optional<Float> epsilon, java.util.Optional<Integer> stash_type, java.util.Optional<Integer> axis) {
        return new LayerNormalization(resultType, X, Scale, B, epsilon, stash_type, axis);
    }

    @OpFactory.OpDeclaration(LeakyRelu.NAME)
    public static final class LeakyRelu extends OnnxOp {
        public static final String NAME = "LeakyRelu";
        
        public enum Attribute implements OnnxAttribute {
            alpha(Float.class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<bfloat16>, tensor<float16>, tensor<float>, tensor<double>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public LeakyRelu(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        LeakyRelu(LeakyRelu that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public LeakyRelu transform(CopyContext cc, OpTransformer ot) {
            return new LeakyRelu(this, cc);
        }
        
        LeakyRelu(TypeElement resultType, Value X, java.util.Optional<Float> alpha) {
            super(SCHEMA, resultType, Set.of(), List.of(X), List.of(alpha));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X()));
        }
        
        public Value X() {
            return operands().get(0);
        }
        
        public java.util.Optional<Float> alpha() {
            Float alpha = Attribute.alpha.access(Float.class, onnxAttributes);
            return java.util.Optional.ofNullable(alpha);
        }
        
    }
    
    public static LeakyRelu LeakyRelu(TypeElement resultType, Value X, java.util.Optional<Float> alpha) {
        return new LeakyRelu(resultType, X, alpha);
    }

    @OpFactory.OpDeclaration(Less.NAME)
    public static final class Less extends OnnxOp {
        public static final String NAME = "Less";
        
        public enum Attribute implements OnnxAttribute.None { }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<uint8>, tensor<uint16>, tensor<uint32>, tensor<uint64>, tensor<int8>, tensor<int16>, tensor<int32>, tensor<int64>, tensor<float16>, tensor<float>, tensor<double>, tensor<bfloat16>] */))),
            T1(new OnnxType.TypeVariable("T1", List.of(/* @@@ [tensor<bool>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            A(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            B(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            C(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public Less(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        Less(Less that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public Less transform(CopyContext cc, OpTransformer ot) {
            return new Less(this, cc);
        }
        
        Less(TypeElement resultType, Value A, Value B) {
            super(SCHEMA, resultType, Set.of(), List.of(A, B), List.of());
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(A(), B()));
        }
        
        public Value A() {
            return operands().get(0);
        }
        
        public Value B() {
            return operands().get(1);
        }
        
    }
    
    public static Less Less(TypeElement resultType, Value A, Value B) {
        return new Less(resultType, A, B);
    }

    @OpFactory.OpDeclaration(LessOrEqual.NAME)
    public static final class LessOrEqual extends OnnxOp {
        public static final String NAME = "LessOrEqual";
        
        public enum Attribute implements OnnxAttribute.None { }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<uint8>, tensor<uint16>, tensor<uint32>, tensor<uint64>, tensor<int8>, tensor<int16>, tensor<int32>, tensor<int64>, tensor<float16>, tensor<float>, tensor<double>, tensor<bfloat16>] */))),
            T1(new OnnxType.TypeVariable("T1", List.of(/* @@@ [tensor<bool>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            A(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            B(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            C(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public LessOrEqual(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        LessOrEqual(LessOrEqual that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public LessOrEqual transform(CopyContext cc, OpTransformer ot) {
            return new LessOrEqual(this, cc);
        }
        
        LessOrEqual(TypeElement resultType, Value A, Value B) {
            super(SCHEMA, resultType, Set.of(), List.of(A, B), List.of());
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(A(), B()));
        }
        
        public Value A() {
            return operands().get(0);
        }
        
        public Value B() {
            return operands().get(1);
        }
        
    }
    
    public static LessOrEqual LessOrEqual(TypeElement resultType, Value A, Value B) {
        return new LessOrEqual(resultType, A, B);
    }

    @OpFactory.OpDeclaration(LinearClassifier.NAME)
    public static final class LinearClassifier extends OnnxOp {
        public static final String NAME = "LinearClassifier";
        
        public enum Attribute implements OnnxAttribute {
            classlabels_ints(int[].class, true, null),
            post_transform(String.class, true, null),
            coefficients(float[].class, false, null),
            multi_class(Integer.class, true, null),
            intercepts(float[].class, true, null),
            classlabels_strings(String[].class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T1(new OnnxType.TypeVariable("T1", List.of(/* @@@ [tensor<float>, tensor<double>, tensor<int64>, tensor<int32>] */))),
            T2(new OnnxType.TypeVariable("T2", List.of(/* @@@ [tensor<string>, tensor<int64>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),
            Z(null /* @@@ tensor<float> */, Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public LinearClassifier(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        LinearClassifier(LinearClassifier that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public LinearClassifier transform(CopyContext cc, OpTransformer ot) {
            return new LinearClassifier(this, cc);
        }
        
        LinearClassifier(TypeElement resultType, Value X, java.util.Optional<int[]> classlabels_ints, java.util.Optional<String> post_transform, float[] coefficients, java.util.Optional<Integer> multi_class, java.util.Optional<float[]> intercepts, java.util.Optional<String[]> classlabels_strings) {
            super(SCHEMA, resultType, Set.of(), List.of(X), List.of(classlabels_ints, post_transform, coefficients, multi_class, intercepts, classlabels_strings));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X()));
        }
        
        public Value X() {
            return operands().get(0);
        }
        
        public java.util.Optional<int[]> classlabels_ints() {
            int[] classlabels_ints = Attribute.classlabels_ints.access(int[].class, onnxAttributes);
            return java.util.Optional.ofNullable(classlabels_ints).map(int[]::clone);
        }
        
        public java.util.Optional<String> post_transform() {
            String post_transform = Attribute.post_transform.access(String.class, onnxAttributes);
            return java.util.Optional.ofNullable(post_transform);
        }
        
        public float[] coefficients() {
            float[] coefficients = Attribute.coefficients.access(float[].class, onnxAttributes);
            return coefficients.clone();
        }
        
        public java.util.Optional<Integer> multi_class() {
            Integer multi_class = Attribute.multi_class.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(multi_class);
        }
        
        public java.util.Optional<float[]> intercepts() {
            float[] intercepts = Attribute.intercepts.access(float[].class, onnxAttributes);
            return java.util.Optional.ofNullable(intercepts).map(float[]::clone);
        }
        
        public java.util.Optional<String[]> classlabels_strings() {
            String[] classlabels_strings = Attribute.classlabels_strings.access(String[].class, onnxAttributes);
            return java.util.Optional.ofNullable(classlabels_strings).map(String[]::clone);
        }
        
    }
    
    public static LinearClassifier LinearClassifier(TypeElement resultType, Value X, java.util.Optional<int[]> classlabels_ints, java.util.Optional<String> post_transform, float[] coefficients, java.util.Optional<Integer> multi_class, java.util.Optional<float[]> intercepts, java.util.Optional<String[]> classlabels_strings) {
        return new LinearClassifier(resultType, X, classlabels_ints, post_transform, coefficients, multi_class, intercepts, classlabels_strings);
    }

    @OpFactory.OpDeclaration(LinearRegressor.NAME)
    public static final class LinearRegressor extends OnnxOp {
        public static final String NAME = "LinearRegressor";
        
        public enum Attribute implements OnnxAttribute {
            post_transform(String.class, true, null),
            coefficients(float[].class, true, null),
            targets(Integer.class, true, null),
            intercepts(float[].class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<float>, tensor<double>, tensor<int64>, tensor<int32>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            Y(null /* @@@ tensor<float> */, Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public LinearRegressor(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        LinearRegressor(LinearRegressor that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public LinearRegressor transform(CopyContext cc, OpTransformer ot) {
            return new LinearRegressor(this, cc);
        }
        
        LinearRegressor(TypeElement resultType, Value X, java.util.Optional<String> post_transform, java.util.Optional<float[]> coefficients, java.util.Optional<Integer> targets, java.util.Optional<float[]> intercepts) {
            super(SCHEMA, resultType, Set.of(), List.of(X), List.of(post_transform, coefficients, targets, intercepts));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X()));
        }
        
        public Value X() {
            return operands().get(0);
        }
        
        public java.util.Optional<String> post_transform() {
            String post_transform = Attribute.post_transform.access(String.class, onnxAttributes);
            return java.util.Optional.ofNullable(post_transform);
        }
        
        public java.util.Optional<float[]> coefficients() {
            float[] coefficients = Attribute.coefficients.access(float[].class, onnxAttributes);
            return java.util.Optional.ofNullable(coefficients).map(float[]::clone);
        }
        
        public java.util.Optional<Integer> targets() {
            Integer targets = Attribute.targets.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(targets);
        }
        
        public java.util.Optional<float[]> intercepts() {
            float[] intercepts = Attribute.intercepts.access(float[].class, onnxAttributes);
            return java.util.Optional.ofNullable(intercepts).map(float[]::clone);
        }
        
    }
    
    public static LinearRegressor LinearRegressor(TypeElement resultType, Value X, java.util.Optional<String> post_transform, java.util.Optional<float[]> coefficients, java.util.Optional<Integer> targets, java.util.Optional<float[]> intercepts) {
        return new LinearRegressor(resultType, X, post_transform, coefficients, targets, intercepts);
    }

    @OpFactory.OpDeclaration(Log.NAME)
    public static final class Log extends OnnxOp {
        public static final String NAME = "Log";
        
        public enum Attribute implements OnnxAttribute.None { }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<float16>, tensor<float>, tensor<double>, tensor<bfloat16>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            input(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public Log(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        Log(Log that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public Log transform(CopyContext cc, OpTransformer ot) {
            return new Log(this, cc);
        }
        
        Log(TypeElement resultType, Value input) {
            super(SCHEMA, resultType, Set.of(), List.of(input), List.of());
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(input()));
        }
        
        public Value input() {
            return operands().get(0);
        }
        
    }
    
    public static Log Log(TypeElement resultType, Value input) {
        return new Log(resultType, input);
    }

    @OpFactory.OpDeclaration(LogSoftmax.NAME)
    public static final class LogSoftmax extends OnnxOp {
        public static final String NAME = "LogSoftmax";
        
        public enum Attribute implements OnnxAttribute {
            axis(Integer.class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<float16>, tensor<float>, tensor<double>, tensor<bfloat16>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            input(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public LogSoftmax(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        LogSoftmax(LogSoftmax that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public LogSoftmax transform(CopyContext cc, OpTransformer ot) {
            return new LogSoftmax(this, cc);
        }
        
        LogSoftmax(TypeElement resultType, Value input, java.util.Optional<Integer> axis) {
            super(SCHEMA, resultType, Set.of(), List.of(input), List.of(axis));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(input()));
        }
        
        public Value input() {
            return operands().get(0);
        }
        
        public java.util.Optional<Integer> axis() {
            Integer axis = Attribute.axis.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(axis);
        }
        
    }
    
    public static LogSoftmax LogSoftmax(TypeElement resultType, Value input, java.util.Optional<Integer> axis) {
        return new LogSoftmax(resultType, input, axis);
    }

    @OpFactory.OpDeclaration(LpNormalization.NAME)
    public static final class LpNormalization extends OnnxOp {
        public static final String NAME = "LpNormalization";
        
        public enum Attribute implements OnnxAttribute {
            p(Integer.class, true, null),
            axis(Integer.class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<bfloat16>, tensor<float16>, tensor<float>, tensor<double>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            input(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public LpNormalization(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        LpNormalization(LpNormalization that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public LpNormalization transform(CopyContext cc, OpTransformer ot) {
            return new LpNormalization(this, cc);
        }
        
        LpNormalization(TypeElement resultType, Value input, java.util.Optional<Integer> p, java.util.Optional<Integer> axis) {
            super(SCHEMA, resultType, Set.of(), List.of(input), List.of(p, axis));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(input()));
        }
        
        public Value input() {
            return operands().get(0);
        }
        
        public java.util.Optional<Integer> p() {
            Integer p = Attribute.p.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(p);
        }
        
        public java.util.Optional<Integer> axis() {
            Integer axis = Attribute.axis.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(axis);
        }
        
    }
    
    public static LpNormalization LpNormalization(TypeElement resultType, Value input, java.util.Optional<Integer> p, java.util.Optional<Integer> axis) {
        return new LpNormalization(resultType, input, p, axis);
    }

    @OpFactory.OpDeclaration(LpPool.NAME)
    public static final class LpPool extends OnnxOp {
        public static final String NAME = "LpPool";
        
        public enum Attribute implements OnnxAttribute {
            p(Integer.class, true, null),
            pads(int[].class, true, null),
            dilations(int[].class, true, null),
            auto_pad(String.class, true, null),
            ceil_mode(Integer.class, true, null),
            strides(int[].class, true, null),
            kernel_shape(int[].class, false, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<bfloat16>, tensor<float16>, tensor<float>, tensor<double>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public LpPool(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        LpPool(LpPool that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public LpPool transform(CopyContext cc, OpTransformer ot) {
            return new LpPool(this, cc);
        }
        
        LpPool(TypeElement resultType, Value X, java.util.Optional<Integer> p, java.util.Optional<int[]> pads, java.util.Optional<int[]> dilations, java.util.Optional<String> auto_pad, java.util.Optional<Integer> ceil_mode, java.util.Optional<int[]> strides, int[] kernel_shape) {
            super(SCHEMA, resultType, Set.of(), List.of(X), List.of(p, pads, dilations, auto_pad, ceil_mode, strides, kernel_shape));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X()));
        }
        
        public Value X() {
            return operands().get(0);
        }
        
        public java.util.Optional<Integer> p() {
            Integer p = Attribute.p.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(p);
        }
        
        public java.util.Optional<int[]> pads() {
            int[] pads = Attribute.pads.access(int[].class, onnxAttributes);
            return java.util.Optional.ofNullable(pads).map(int[]::clone);
        }
        
        public java.util.Optional<int[]> dilations() {
            int[] dilations = Attribute.dilations.access(int[].class, onnxAttributes);
            return java.util.Optional.ofNullable(dilations).map(int[]::clone);
        }
        
        public java.util.Optional<String> auto_pad() {
            String auto_pad = Attribute.auto_pad.access(String.class, onnxAttributes);
            return java.util.Optional.ofNullable(auto_pad);
        }
        
        public java.util.Optional<Integer> ceil_mode() {
            Integer ceil_mode = Attribute.ceil_mode.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(ceil_mode);
        }
        
        public java.util.Optional<int[]> strides() {
            int[] strides = Attribute.strides.access(int[].class, onnxAttributes);
            return java.util.Optional.ofNullable(strides).map(int[]::clone);
        }
        
        public int[] kernel_shape() {
            int[] kernel_shape = Attribute.kernel_shape.access(int[].class, onnxAttributes);
            return kernel_shape.clone();
        }
        
    }
    
    public static LpPool LpPool(TypeElement resultType, Value X, java.util.Optional<Integer> p, java.util.Optional<int[]> pads, java.util.Optional<int[]> dilations, java.util.Optional<String> auto_pad, java.util.Optional<Integer> ceil_mode, java.util.Optional<int[]> strides, int[] kernel_shape) {
        return new LpPool(resultType, X, p, pads, dilations, auto_pad, ceil_mode, strides, kernel_shape);
    }

    @OpFactory.OpDeclaration(MatMul.NAME)
    public static final class MatMul extends OnnxOp {
        public static final String NAME = "MatMul";
        
        public enum Attribute implements OnnxAttribute.None { }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<float16>, tensor<float>, tensor<double>, tensor<uint32>, tensor<uint64>, tensor<int32>, tensor<int64>, tensor<bfloat16>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            A(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            B(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public MatMul(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        MatMul(MatMul that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public MatMul transform(CopyContext cc, OpTransformer ot) {
            return new MatMul(this, cc);
        }
        
        MatMul(TypeElement resultType, Value A, Value B) {
            super(SCHEMA, resultType, Set.of(), List.of(A, B), List.of());
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(A(), B()));
        }
        
        public Value A() {
            return operands().get(0);
        }
        
        public Value B() {
            return operands().get(1);
        }
        
    }
    
    public static MatMul MatMul(TypeElement resultType, Value A, Value B) {
        return new MatMul(resultType, A, B);
    }

    @OpFactory.OpDeclaration(MatMulInteger.NAME)
    public static final class MatMulInteger extends OnnxOp {
        public static final String NAME = "MatMulInteger";
        
        public enum Attribute implements OnnxAttribute.None { }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T1(new OnnxType.TypeVariable("T1", List.of(/* @@@ [tensor<int8>, tensor<uint8>] */))),
            T2(new OnnxType.TypeVariable("T2", List.of(/* @@@ [tensor<int8>, tensor<uint8>] */))),
            T3(new OnnxType.TypeVariable("T3", List.of(/* @@@ [tensor<int32>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            A(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            B(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),
            a_zero_point(TypeConstraint.T1.typeVariable(), Quantifier.OPTIONAL),
            b_zero_point(TypeConstraint.T2.typeVariable(), Quantifier.OPTIONAL),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T3.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public MatMulInteger(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        MatMulInteger(MatMulInteger that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public MatMulInteger transform(CopyContext cc, OpTransformer ot) {
            return new MatMulInteger(this, cc);
        }
        
        MatMulInteger(TypeElement resultType, Value A, Value B, java.util.Optional<Value> a_zero_point, java.util.Optional<Value> b_zero_point) {
            super(SCHEMA, resultType, Set.of(), List.of(A, B, a_zero_point, b_zero_point), List.of());
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(A(), B(), a_zero_point(), b_zero_point()));
        }
        
        public Value A() {
            return operands().get(0);
        }
        
        public Value B() {
            return operands().get(1);
        }
        
        public java.util.Optional<Value> a_zero_point() {
            int i = optionalInputArguments.indexOf(InputParameter.a_zero_point);
            return i != -1 ? java.util.Optional.of(operands().get(2 + i)) : java.util.Optional.empty();
        }
        
        public java.util.Optional<Value> b_zero_point() {
            int i = optionalInputArguments.indexOf(InputParameter.b_zero_point);
            return i != -1 ? java.util.Optional.of(operands().get(2 + i)) : java.util.Optional.empty();
        }
        
    }
    
    public static MatMulInteger MatMulInteger(TypeElement resultType, Value A, Value B, java.util.Optional<Value> a_zero_point, java.util.Optional<Value> b_zero_point) {
        return new MatMulInteger(resultType, A, B, a_zero_point, b_zero_point);
    }

    @OpFactory.OpDeclaration(Max.NAME)
    public static final class Max extends OnnxOp {
        public static final String NAME = "Max";
        
        public enum Attribute implements OnnxAttribute.None { }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<uint8>, tensor<uint16>, tensor<uint32>, tensor<uint64>, tensor<int8>, tensor<int16>, tensor<int32>, tensor<int64>, tensor<float16>, tensor<float>, tensor<double>, tensor<bfloat16>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            data_0(TypeConstraint.T.typeVariable(), Quantifier.VARIADIC),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            max(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public Max(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        Max(Max that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public Max transform(CopyContext cc, OpTransformer ot) {
            return new Max(this, cc);
        }
        
        Max(TypeElement resultType, List<Value> data_0) {
            super(SCHEMA, resultType, Set.of(), List.of(data_0), List.of());
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(data_0()));
        }
        
        public List<Value> data_0() {
            return operands();
        }
        
    }
    
    public static Max Max(TypeElement resultType, List<Value> data_0) {
        return new Max(resultType, data_0);
    }

    @OpFactory.OpDeclaration(MaxPool.NAME)
    public static final class MaxPool extends OnnxOp {
        public static final String NAME = "MaxPool";
        
        public enum Attribute implements OnnxAttribute {
            pads(int[].class, true, null),
            dilations(int[].class, true, null),
            auto_pad(String.class, true, null),
            ceil_mode(Integer.class, true, null),
            storage_order(Integer.class, true, null),
            strides(int[].class, true, null),
            kernel_shape(int[].class, false, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<bfloat16>, tensor<float16>, tensor<float>, tensor<double>, tensor<int8>, tensor<uint8>] */))),
            I(new OnnxType.TypeVariable("I", List.of(/* @@@ [tensor<int64>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            Indices(TypeConstraint.I.typeVariable(), Quantifier.OPTIONAL),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public MaxPool(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        MaxPool(MaxPool that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public MaxPool transform(CopyContext cc, OpTransformer ot) {
            return new MaxPool(this, cc);
        }
        
        MaxPool(TypeElement resultType, Value X, java.util.Optional<int[]> pads, java.util.Optional<int[]> dilations, java.util.Optional<String> auto_pad, java.util.Optional<Integer> ceil_mode, java.util.Optional<Integer> storage_order, java.util.Optional<int[]> strides, int[] kernel_shape) {
            super(SCHEMA, resultType, Set.of(), List.of(X), List.of(pads, dilations, auto_pad, ceil_mode, storage_order, strides, kernel_shape));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X()));
        }
        
        public Value X() {
            return operands().get(0);
        }
        
        public java.util.Optional<int[]> pads() {
            int[] pads = Attribute.pads.access(int[].class, onnxAttributes);
            return java.util.Optional.ofNullable(pads).map(int[]::clone);
        }
        
        public java.util.Optional<int[]> dilations() {
            int[] dilations = Attribute.dilations.access(int[].class, onnxAttributes);
            return java.util.Optional.ofNullable(dilations).map(int[]::clone);
        }
        
        public java.util.Optional<String> auto_pad() {
            String auto_pad = Attribute.auto_pad.access(String.class, onnxAttributes);
            return java.util.Optional.ofNullable(auto_pad);
        }
        
        public java.util.Optional<Integer> ceil_mode() {
            Integer ceil_mode = Attribute.ceil_mode.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(ceil_mode);
        }
        
        public java.util.Optional<Integer> storage_order() {
            Integer storage_order = Attribute.storage_order.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(storage_order);
        }
        
        public java.util.Optional<int[]> strides() {
            int[] strides = Attribute.strides.access(int[].class, onnxAttributes);
            return java.util.Optional.ofNullable(strides).map(int[]::clone);
        }
        
        public int[] kernel_shape() {
            int[] kernel_shape = Attribute.kernel_shape.access(int[].class, onnxAttributes);
            return kernel_shape.clone();
        }
        
    }
    
    public static MaxPool MaxPool(TypeElement resultType, Value X, java.util.Optional<int[]> pads, java.util.Optional<int[]> dilations, java.util.Optional<String> auto_pad, java.util.Optional<Integer> ceil_mode, java.util.Optional<Integer> storage_order, java.util.Optional<int[]> strides, int[] kernel_shape) {
        return new MaxPool(resultType, X, pads, dilations, auto_pad, ceil_mode, storage_order, strides, kernel_shape);
    }

    @OpFactory.OpDeclaration(MaxRoiPool.NAME)
    public static final class MaxRoiPool extends OnnxOp {
        public static final String NAME = "MaxRoiPool";
        
        public enum Attribute implements OnnxAttribute {
            spatial_scale(Float.class, true, null),
            pooled_shape(int[].class, false, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<bfloat16>, tensor<float16>, tensor<float>, tensor<double>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            rois(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public MaxRoiPool(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        MaxRoiPool(MaxRoiPool that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public MaxRoiPool transform(CopyContext cc, OpTransformer ot) {
            return new MaxRoiPool(this, cc);
        }
        
        MaxRoiPool(TypeElement resultType, Value X, Value rois, java.util.Optional<Float> spatial_scale, int[] pooled_shape) {
            super(SCHEMA, resultType, Set.of(), List.of(X, rois), List.of(spatial_scale, pooled_shape));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X(), rois()));
        }
        
        public Value X() {
            return operands().get(0);
        }
        
        public Value rois() {
            return operands().get(1);
        }
        
        public java.util.Optional<Float> spatial_scale() {
            Float spatial_scale = Attribute.spatial_scale.access(Float.class, onnxAttributes);
            return java.util.Optional.ofNullable(spatial_scale);
        }
        
        public int[] pooled_shape() {
            int[] pooled_shape = Attribute.pooled_shape.access(int[].class, onnxAttributes);
            return pooled_shape.clone();
        }
        
    }
    
    public static MaxRoiPool MaxRoiPool(TypeElement resultType, Value X, Value rois, java.util.Optional<Float> spatial_scale, int[] pooled_shape) {
        return new MaxRoiPool(resultType, X, rois, spatial_scale, pooled_shape);
    }

    @OpFactory.OpDeclaration(MaxUnpool.NAME)
    public static final class MaxUnpool extends OnnxOp {
        public static final String NAME = "MaxUnpool";
        
        public enum Attribute implements OnnxAttribute {
            pads(int[].class, true, null),
            strides(int[].class, true, null),
            kernel_shape(int[].class, false, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T1(new OnnxType.TypeVariable("T1", List.of(/* @@@ [tensor<bfloat16>, tensor<float16>, tensor<float>, tensor<double>] */))),
            T2(new OnnxType.TypeVariable("T2", List.of(/* @@@ [tensor<int64>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            I(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),
            output_shape(TypeConstraint.T2.typeVariable(), Quantifier.OPTIONAL),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public MaxUnpool(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        MaxUnpool(MaxUnpool that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public MaxUnpool transform(CopyContext cc, OpTransformer ot) {
            return new MaxUnpool(this, cc);
        }
        
        MaxUnpool(TypeElement resultType, Value X, Value I, java.util.Optional<Value> output_shape, java.util.Optional<int[]> pads, java.util.Optional<int[]> strides, int[] kernel_shape) {
            super(SCHEMA, resultType, Set.of(), List.of(X, I, output_shape), List.of(pads, strides, kernel_shape));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X(), I(), output_shape()));
        }
        
        public Value X() {
            return operands().get(0);
        }
        
        public Value I() {
            return operands().get(1);
        }
        
        public java.util.Optional<Value> output_shape() {
            int i = optionalInputArguments.indexOf(InputParameter.output_shape);
            return i != -1 ? java.util.Optional.of(operands().get(2 + i)) : java.util.Optional.empty();
        }
        
        public java.util.Optional<int[]> pads() {
            int[] pads = Attribute.pads.access(int[].class, onnxAttributes);
            return java.util.Optional.ofNullable(pads).map(int[]::clone);
        }
        
        public java.util.Optional<int[]> strides() {
            int[] strides = Attribute.strides.access(int[].class, onnxAttributes);
            return java.util.Optional.ofNullable(strides).map(int[]::clone);
        }
        
        public int[] kernel_shape() {
            int[] kernel_shape = Attribute.kernel_shape.access(int[].class, onnxAttributes);
            return kernel_shape.clone();
        }
        
    }
    
    public static MaxUnpool MaxUnpool(TypeElement resultType, Value X, Value I, java.util.Optional<Value> output_shape, java.util.Optional<int[]> pads, java.util.Optional<int[]> strides, int[] kernel_shape) {
        return new MaxUnpool(resultType, X, I, output_shape, pads, strides, kernel_shape);
    }

    @OpFactory.OpDeclaration(Mean.NAME)
    public static final class Mean extends OnnxOp {
        public static final String NAME = "Mean";
        
        public enum Attribute implements OnnxAttribute.None { }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<float16>, tensor<float>, tensor<double>, tensor<bfloat16>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            data_0(TypeConstraint.T.typeVariable(), Quantifier.VARIADIC),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            mean(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public Mean(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        Mean(Mean that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public Mean transform(CopyContext cc, OpTransformer ot) {
            return new Mean(this, cc);
        }
        
        Mean(TypeElement resultType, List<Value> data_0) {
            super(SCHEMA, resultType, Set.of(), List.of(data_0), List.of());
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(data_0()));
        }
        
        public List<Value> data_0() {
            return operands();
        }
        
    }
    
    public static Mean Mean(TypeElement resultType, List<Value> data_0) {
        return new Mean(resultType, data_0);
    }

    @OpFactory.OpDeclaration(MeanVarianceNormalization.NAME)
    public static final class MeanVarianceNormalization extends OnnxOp {
        public static final String NAME = "MeanVarianceNormalization";
        
        public enum Attribute implements OnnxAttribute {
            axes(int[].class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<float16>, tensor<float>, tensor<double>, tensor<bfloat16>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public MeanVarianceNormalization(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        MeanVarianceNormalization(MeanVarianceNormalization that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public MeanVarianceNormalization transform(CopyContext cc, OpTransformer ot) {
            return new MeanVarianceNormalization(this, cc);
        }
        
        MeanVarianceNormalization(TypeElement resultType, Value X, java.util.Optional<int[]> axes) {
            super(SCHEMA, resultType, Set.of(), List.of(X), List.of(axes));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X()));
        }
        
        public Value X() {
            return operands().get(0);
        }
        
        public java.util.Optional<int[]> axes() {
            int[] axes = Attribute.axes.access(int[].class, onnxAttributes);
            return java.util.Optional.ofNullable(axes).map(int[]::clone);
        }
        
    }
    
    public static MeanVarianceNormalization MeanVarianceNormalization(TypeElement resultType, Value X, java.util.Optional<int[]> axes) {
        return new MeanVarianceNormalization(resultType, X, axes);
    }

    @OpFactory.OpDeclaration(MelWeightMatrix.NAME)
    public static final class MelWeightMatrix extends OnnxOp {
        public static final String NAME = "MelWeightMatrix";
        
        public enum Attribute implements OnnxAttribute {
            output_datatype(Integer.class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T1(new OnnxType.TypeVariable("T1", List.of(/* @@@ [tensor<int32>, tensor<int64>] */))),
            T2(new OnnxType.TypeVariable("T2", List.of(/* @@@ [tensor<float>, tensor<float16>, tensor<double>, tensor<bfloat16>] */))),
            T3(new OnnxType.TypeVariable("T3", List.of(/* @@@ [tensor<uint8>, tensor<uint16>, tensor<uint32>, tensor<uint64>, tensor<int8>, tensor<int16>, tensor<int32>, tensor<int64>, tensor<float16>, tensor<float>, tensor<double>, tensor<bfloat16>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            num_mel_bins(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            dft_length(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            sample_rate(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            lower_edge_hertz(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),
            upper_edge_hertz(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T3.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public MelWeightMatrix(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        MelWeightMatrix(MelWeightMatrix that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public MelWeightMatrix transform(CopyContext cc, OpTransformer ot) {
            return new MelWeightMatrix(this, cc);
        }
        
        MelWeightMatrix(TypeElement resultType, Value num_mel_bins, Value dft_length, Value sample_rate, Value lower_edge_hertz, Value upper_edge_hertz, java.util.Optional<Integer> output_datatype) {
            super(SCHEMA, resultType, Set.of(), List.of(num_mel_bins, dft_length, sample_rate, lower_edge_hertz, upper_edge_hertz), List.of(output_datatype));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(num_mel_bins(), dft_length(), sample_rate(), lower_edge_hertz(), upper_edge_hertz()));
        }
        
        public Value num_mel_bins() {
            return operands().get(0);
        }
        
        public Value dft_length() {
            return operands().get(1);
        }
        
        public Value sample_rate() {
            return operands().get(2);
        }
        
        public Value lower_edge_hertz() {
            return operands().get(3);
        }
        
        public Value upper_edge_hertz() {
            return operands().get(4);
        }
        
        public java.util.Optional<Integer> output_datatype() {
            Integer output_datatype = Attribute.output_datatype.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(output_datatype);
        }
        
    }
    
    public static MelWeightMatrix MelWeightMatrix(TypeElement resultType, Value num_mel_bins, Value dft_length, Value sample_rate, Value lower_edge_hertz, Value upper_edge_hertz, java.util.Optional<Integer> output_datatype) {
        return new MelWeightMatrix(resultType, num_mel_bins, dft_length, sample_rate, lower_edge_hertz, upper_edge_hertz, output_datatype);
    }

    @OpFactory.OpDeclaration(Min.NAME)
    public static final class Min extends OnnxOp {
        public static final String NAME = "Min";
        
        public enum Attribute implements OnnxAttribute.None { }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<uint8>, tensor<uint16>, tensor<uint32>, tensor<uint64>, tensor<int8>, tensor<int16>, tensor<int32>, tensor<int64>, tensor<float16>, tensor<float>, tensor<double>, tensor<bfloat16>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            data_0(TypeConstraint.T.typeVariable(), Quantifier.VARIADIC),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            min(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public Min(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        Min(Min that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public Min transform(CopyContext cc, OpTransformer ot) {
            return new Min(this, cc);
        }
        
        Min(TypeElement resultType, List<Value> data_0) {
            super(SCHEMA, resultType, Set.of(), List.of(data_0), List.of());
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(data_0()));
        }
        
        public List<Value> data_0() {
            return operands();
        }
        
    }
    
    public static Min Min(TypeElement resultType, List<Value> data_0) {
        return new Min(resultType, data_0);
    }

    @OpFactory.OpDeclaration(Mish.NAME)
    public static final class Mish extends OnnxOp {
        public static final String NAME = "Mish";
        
        public enum Attribute implements OnnxAttribute.None { }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<bfloat16>, tensor<float16>, tensor<float>, tensor<double>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public Mish(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        Mish(Mish that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public Mish transform(CopyContext cc, OpTransformer ot) {
            return new Mish(this, cc);
        }
        
        Mish(TypeElement resultType, Value X) {
            super(SCHEMA, resultType, Set.of(), List.of(X), List.of());
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X()));
        }
        
        public Value X() {
            return operands().get(0);
        }
        
    }
    
    public static Mish Mish(TypeElement resultType, Value X) {
        return new Mish(resultType, X);
    }

    @OpFactory.OpDeclaration(Mod.NAME)
    public static final class Mod extends OnnxOp {
        public static final String NAME = "Mod";
        
        public enum Attribute implements OnnxAttribute {
            fmod(Integer.class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<uint8>, tensor<uint16>, tensor<uint32>, tensor<uint64>, tensor<int8>, tensor<int16>, tensor<int32>, tensor<int64>, tensor<float16>, tensor<float>, tensor<double>, tensor<bfloat16>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            A(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            B(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            C(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public Mod(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        Mod(Mod that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public Mod transform(CopyContext cc, OpTransformer ot) {
            return new Mod(this, cc);
        }
        
        Mod(TypeElement resultType, Value A, Value B, java.util.Optional<Integer> fmod) {
            super(SCHEMA, resultType, Set.of(), List.of(A, B), List.of(fmod));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(A(), B()));
        }
        
        public Value A() {
            return operands().get(0);
        }
        
        public Value B() {
            return operands().get(1);
        }
        
        public java.util.Optional<Integer> fmod() {
            Integer fmod = Attribute.fmod.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(fmod);
        }
        
    }
    
    public static Mod Mod(TypeElement resultType, Value A, Value B, java.util.Optional<Integer> fmod) {
        return new Mod(resultType, A, B, fmod);
    }

    @OpFactory.OpDeclaration(Momentum.NAME)
    public static final class Momentum extends OnnxOp {
        public static final String NAME = "Momentum";
        
        public enum Attribute implements OnnxAttribute {
            mode(String.class, false, null),
            norm_coefficient(Float.class, false, null),
            alpha(Float.class, false, null),
            beta(Float.class, false, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T1(new OnnxType.TypeVariable("T1", List.of(/* @@@ [tensor<float>, tensor<double>] */))),
            T2(new OnnxType.TypeVariable("T2", List.of(/* @@@ [tensor<int64>] */))),
            T3(new OnnxType.TypeVariable("T3", List.of(/* @@@ [tensor<float>, tensor<double>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            R(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            T(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),
            inputs(TypeConstraint.T3.typeVariable(), Quantifier.VARIADIC),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            outputs(TypeConstraint.T3.typeVariable(), Quantifier.VARIADIC),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public Momentum(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        Momentum(Momentum that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public Momentum transform(CopyContext cc, OpTransformer ot) {
            return new Momentum(this, cc);
        }
        
        Momentum(TypeElement resultType, Value R, Value T, List<Value> inputs, String mode, float norm_coefficient, float alpha, float beta) {
            super(SCHEMA, resultType, Set.of(), List.of(R, T, inputs), List.of(mode, norm_coefficient, alpha, beta));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(R(), T(), inputs()));
        }
        
        public Value R() {
            return operands().get(0);
        }
        
        public Value T() {
            return operands().get(1);
        }
        
        public List<Value> inputs() {
            return operands().subList(2, operands().size());
        }
        
        public String mode() {
            String mode = Attribute.mode.access(String.class, onnxAttributes);
            return mode;
        }
        
        public float norm_coefficient() {
            float norm_coefficient = Attribute.norm_coefficient.access(float.class, onnxAttributes);
            return norm_coefficient;
        }
        
        public float alpha() {
            float alpha = Attribute.alpha.access(float.class, onnxAttributes);
            return alpha;
        }
        
        public float beta() {
            float beta = Attribute.beta.access(float.class, onnxAttributes);
            return beta;
        }
        
    }
    
    public static Momentum Momentum(TypeElement resultType, Value R, Value T, List<Value> inputs, String mode, float norm_coefficient, float alpha, float beta) {
        return new Momentum(resultType, R, T, inputs, mode, norm_coefficient, alpha, beta);
    }

    @OpFactory.OpDeclaration(Mul.NAME)
    public static final class Mul extends OnnxOp {
        public static final String NAME = "Mul";
        
        public enum Attribute implements OnnxAttribute.None { }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<uint8>, tensor<uint16>, tensor<uint32>, tensor<uint64>, tensor<int8>, tensor<int16>, tensor<int32>, tensor<int64>, tensor<float16>, tensor<float>, tensor<double>, tensor<bfloat16>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            A(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            B(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            C(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public Mul(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        Mul(Mul that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public Mul transform(CopyContext cc, OpTransformer ot) {
            return new Mul(this, cc);
        }
        
        Mul(TypeElement resultType, Value A, Value B) {
            super(SCHEMA, resultType, Set.of(), List.of(A, B), List.of());
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(A(), B()));
        }
        
        public Value A() {
            return operands().get(0);
        }
        
        public Value B() {
            return operands().get(1);
        }
        
    }
    
    public static Mul Mul(TypeElement resultType, Value A, Value B) {
        return new Mul(resultType, A, B);
    }

    @OpFactory.OpDeclaration(Multinomial.NAME)
    public static final class Multinomial extends OnnxOp {
        public static final String NAME = "Multinomial";
        
        public enum Attribute implements OnnxAttribute {
            seed(Float.class, true, null),
            sample_size(Integer.class, true, null),
            dtype(Integer.class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T1(new OnnxType.TypeVariable("T1", List.of(/* @@@ [tensor<bfloat16>, tensor<float16>, tensor<float>, tensor<double>] */))),
            T2(new OnnxType.TypeVariable("T2", List.of(/* @@@ [tensor<int32>, tensor<int64>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            input(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public Multinomial(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        Multinomial(Multinomial that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public Multinomial transform(CopyContext cc, OpTransformer ot) {
            return new Multinomial(this, cc);
        }
        
        Multinomial(TypeElement resultType, Value input, java.util.Optional<Float> seed, java.util.Optional<Integer> sample_size, java.util.Optional<Integer> dtype) {
            super(SCHEMA, resultType, Set.of(), List.of(input), List.of(seed, sample_size, dtype));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(input()));
        }
        
        public Value input() {
            return operands().get(0);
        }
        
        public java.util.Optional<Float> seed() {
            Float seed = Attribute.seed.access(Float.class, onnxAttributes);
            return java.util.Optional.ofNullable(seed);
        }
        
        public java.util.Optional<Integer> sample_size() {
            Integer sample_size = Attribute.sample_size.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(sample_size);
        }
        
        public java.util.Optional<Integer> dtype() {
            Integer dtype = Attribute.dtype.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(dtype);
        }
        
    }
    
    public static Multinomial Multinomial(TypeElement resultType, Value input, java.util.Optional<Float> seed, java.util.Optional<Integer> sample_size, java.util.Optional<Integer> dtype) {
        return new Multinomial(resultType, input, seed, sample_size, dtype);
    }

    @OpFactory.OpDeclaration(Neg.NAME)
    public static final class Neg extends OnnxOp {
        public static final String NAME = "Neg";
        
        public enum Attribute implements OnnxAttribute.None { }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<float>, tensor<int32>, tensor<int8>, tensor<int16>, tensor<int64>, tensor<float16>, tensor<double>, tensor<bfloat16>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public Neg(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        Neg(Neg that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public Neg transform(CopyContext cc, OpTransformer ot) {
            return new Neg(this, cc);
        }
        
        Neg(TypeElement resultType, Value X) {
            super(SCHEMA, resultType, Set.of(), List.of(X), List.of());
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X()));
        }
        
        public Value X() {
            return operands().get(0);
        }
        
    }
    
    public static Neg Neg(TypeElement resultType, Value X) {
        return new Neg(resultType, X);
    }

    @OpFactory.OpDeclaration(NegativeLogLikelihoodLoss.NAME)
    public static final class NegativeLogLikelihoodLoss extends OnnxOp {
        public static final String NAME = "NegativeLogLikelihoodLoss";
        
        public enum Attribute implements OnnxAttribute {
            ignore_index(Integer.class, true, null),
            reduction(String.class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<bfloat16>, tensor<float16>, tensor<float>, tensor<double>] */))),
            Tind(new OnnxType.TypeVariable("Tind", List.of(/* @@@ [tensor<int32>, tensor<int64>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            input(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            target(TypeConstraint.Tind.typeVariable(), Quantifier.REQUIRED),
            weight(TypeConstraint.T.typeVariable(), Quantifier.OPTIONAL),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            loss(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public NegativeLogLikelihoodLoss(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        NegativeLogLikelihoodLoss(NegativeLogLikelihoodLoss that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public NegativeLogLikelihoodLoss transform(CopyContext cc, OpTransformer ot) {
            return new NegativeLogLikelihoodLoss(this, cc);
        }
        
        NegativeLogLikelihoodLoss(TypeElement resultType, Value input, Value target, java.util.Optional<Value> weight, java.util.Optional<Integer> ignore_index, java.util.Optional<String> reduction) {
            super(SCHEMA, resultType, Set.of(), List.of(input, target, weight), List.of(ignore_index, reduction));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(input(), target(), weight()));
        }
        
        public Value input() {
            return operands().get(0);
        }
        
        public Value target() {
            return operands().get(1);
        }
        
        public java.util.Optional<Value> weight() {
            int i = optionalInputArguments.indexOf(InputParameter.weight);
            return i != -1 ? java.util.Optional.of(operands().get(2 + i)) : java.util.Optional.empty();
        }
        
        public java.util.Optional<Integer> ignore_index() {
            Integer ignore_index = Attribute.ignore_index.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(ignore_index);
        }
        
        public java.util.Optional<String> reduction() {
            String reduction = Attribute.reduction.access(String.class, onnxAttributes);
            return java.util.Optional.ofNullable(reduction);
        }
        
    }
    
    public static NegativeLogLikelihoodLoss NegativeLogLikelihoodLoss(TypeElement resultType, Value input, Value target, java.util.Optional<Value> weight, java.util.Optional<Integer> ignore_index, java.util.Optional<String> reduction) {
        return new NegativeLogLikelihoodLoss(resultType, input, target, weight, ignore_index, reduction);
    }

    @OpFactory.OpDeclaration(NonMaxSuppression.NAME)
    public static final class NonMaxSuppression extends OnnxOp {
        public static final String NAME = "NonMaxSuppression";
        
        public enum Attribute implements OnnxAttribute {
            center_point_box(Integer.class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint.None { }
        
        public enum InputParameter implements OnnxParameter {
            boxes(null /* @@@ tensor<float> */, Quantifier.REQUIRED),
            scores(null /* @@@ tensor<float> */, Quantifier.REQUIRED),
            max_output_boxes_per_class(null /* @@@ tensor<int64> */, Quantifier.OPTIONAL),
            iou_threshold(null /* @@@ tensor<float> */, Quantifier.OPTIONAL),
            score_threshold(null /* @@@ tensor<float> */, Quantifier.OPTIONAL),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            selected_indices(null /* @@@ tensor<int64> */, Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public NonMaxSuppression(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        NonMaxSuppression(NonMaxSuppression that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public NonMaxSuppression transform(CopyContext cc, OpTransformer ot) {
            return new NonMaxSuppression(this, cc);
        }
        
        NonMaxSuppression(TypeElement resultType, Value boxes, Value scores, java.util.Optional<Value> max_output_boxes_per_class, java.util.Optional<Value> iou_threshold, java.util.Optional<Value> score_threshold, java.util.Optional<Integer> center_point_box) {
            super(SCHEMA, resultType, Set.of(), List.of(boxes, scores, max_output_boxes_per_class, iou_threshold, score_threshold), List.of(center_point_box));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(boxes(), scores(), max_output_boxes_per_class(), iou_threshold(), score_threshold()));
        }
        
        public Value boxes() {
            return operands().get(0);
        }
        
        public Value scores() {
            return operands().get(1);
        }
        
        public java.util.Optional<Value> max_output_boxes_per_class() {
            int i = optionalInputArguments.indexOf(InputParameter.max_output_boxes_per_class);
            return i != -1 ? java.util.Optional.of(operands().get(2 + i)) : java.util.Optional.empty();
        }
        
        public java.util.Optional<Value> iou_threshold() {
            int i = optionalInputArguments.indexOf(InputParameter.iou_threshold);
            return i != -1 ? java.util.Optional.of(operands().get(2 + i)) : java.util.Optional.empty();
        }
        
        public java.util.Optional<Value> score_threshold() {
            int i = optionalInputArguments.indexOf(InputParameter.score_threshold);
            return i != -1 ? java.util.Optional.of(operands().get(2 + i)) : java.util.Optional.empty();
        }
        
        public java.util.Optional<Integer> center_point_box() {
            Integer center_point_box = Attribute.center_point_box.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(center_point_box);
        }
        
    }
    
    public static NonMaxSuppression NonMaxSuppression(TypeElement resultType, Value boxes, Value scores, java.util.Optional<Value> max_output_boxes_per_class, java.util.Optional<Value> iou_threshold, java.util.Optional<Value> score_threshold, java.util.Optional<Integer> center_point_box) {
        return new NonMaxSuppression(resultType, boxes, scores, max_output_boxes_per_class, iou_threshold, score_threshold, center_point_box);
    }

    @OpFactory.OpDeclaration(NonZero.NAME)
    public static final class NonZero extends OnnxOp {
        public static final String NAME = "NonZero";
        
        public enum Attribute implements OnnxAttribute.None { }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<uint8>, tensor<uint16>, tensor<uint32>, tensor<uint64>, tensor<int8>, tensor<int16>, tensor<int32>, tensor<int64>, tensor<bfloat16>, tensor<float16>, tensor<float>, tensor<double>, tensor<string>, tensor<bool>, tensor<complex64>, tensor<complex128>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            Y(null /* @@@ tensor<int64> */, Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public NonZero(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        NonZero(NonZero that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public NonZero transform(CopyContext cc, OpTransformer ot) {
            return new NonZero(this, cc);
        }
        
        NonZero(TypeElement resultType, Value X) {
            super(SCHEMA, resultType, Set.of(), List.of(X), List.of());
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X()));
        }
        
        public Value X() {
            return operands().get(0);
        }
        
    }
    
    public static NonZero NonZero(TypeElement resultType, Value X) {
        return new NonZero(resultType, X);
    }

    @OpFactory.OpDeclaration(Normalizer.NAME)
    public static final class Normalizer extends OnnxOp {
        public static final String NAME = "Normalizer";
        
        public enum Attribute implements OnnxAttribute {
            norm(String.class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<float>, tensor<double>, tensor<int64>, tensor<int32>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            Y(null /* @@@ tensor<float> */, Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public Normalizer(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        Normalizer(Normalizer that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public Normalizer transform(CopyContext cc, OpTransformer ot) {
            return new Normalizer(this, cc);
        }
        
        Normalizer(TypeElement resultType, Value X, java.util.Optional<String> norm) {
            super(SCHEMA, resultType, Set.of(), List.of(X), List.of(norm));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X()));
        }
        
        public Value X() {
            return operands().get(0);
        }
        
        public java.util.Optional<String> norm() {
            String norm = Attribute.norm.access(String.class, onnxAttributes);
            return java.util.Optional.ofNullable(norm);
        }
        
    }
    
    public static Normalizer Normalizer(TypeElement resultType, Value X, java.util.Optional<String> norm) {
        return new Normalizer(resultType, X, norm);
    }

    @OpFactory.OpDeclaration(Not.NAME)
    public static final class Not extends OnnxOp {
        public static final String NAME = "Not";
        
        public enum Attribute implements OnnxAttribute.None { }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<bool>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public Not(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        Not(Not that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public Not transform(CopyContext cc, OpTransformer ot) {
            return new Not(this, cc);
        }
        
        Not(TypeElement resultType, Value X) {
            super(SCHEMA, resultType, Set.of(), List.of(X), List.of());
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X()));
        }
        
        public Value X() {
            return operands().get(0);
        }
        
    }
    
    public static Not Not(TypeElement resultType, Value X) {
        return new Not(resultType, X);
    }

    @OpFactory.OpDeclaration(OneHot.NAME)
    public static final class OneHot extends OnnxOp {
        public static final String NAME = "OneHot";
        
        public enum Attribute implements OnnxAttribute {
            axis(Integer.class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T1(new OnnxType.TypeVariable("T1", List.of(/* @@@ [tensor<uint8>, tensor<uint16>, tensor<uint32>, tensor<uint64>, tensor<int8>, tensor<int16>, tensor<int32>, tensor<int64>, tensor<float16>, tensor<float>, tensor<double>] */))),
            T2(new OnnxType.TypeVariable("T2", List.of(/* @@@ [tensor<uint8>, tensor<uint16>, tensor<uint32>, tensor<uint64>, tensor<int8>, tensor<int16>, tensor<int32>, tensor<int64>, tensor<float16>, tensor<float>, tensor<double>] */))),
            T3(new OnnxType.TypeVariable("T3", List.of(/* @@@ [tensor<uint8>, tensor<uint16>, tensor<uint32>, tensor<uint64>, tensor<int8>, tensor<int16>, tensor<int32>, tensor<int64>, tensor<float16>, tensor<float>, tensor<double>, tensor<string>, tensor<bool>, tensor<complex64>, tensor<complex128>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            indices(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            depth(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),
            values(TypeConstraint.T3.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T3.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public OneHot(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        OneHot(OneHot that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public OneHot transform(CopyContext cc, OpTransformer ot) {
            return new OneHot(this, cc);
        }
        
        OneHot(TypeElement resultType, Value indices, Value depth, Value values, java.util.Optional<Integer> axis) {
            super(SCHEMA, resultType, Set.of(), List.of(indices, depth, values), List.of(axis));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(indices(), depth(), values()));
        }
        
        public Value indices() {
            return operands().get(0);
        }
        
        public Value depth() {
            return operands().get(1);
        }
        
        public Value values() {
            return operands().get(2);
        }
        
        public java.util.Optional<Integer> axis() {
            Integer axis = Attribute.axis.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(axis);
        }
        
    }
    
    public static OneHot OneHot(TypeElement resultType, Value indices, Value depth, Value values, java.util.Optional<Integer> axis) {
        return new OneHot(resultType, indices, depth, values, axis);
    }

    @OpFactory.OpDeclaration(OneHotEncoder.NAME)
    public static final class OneHotEncoder extends OnnxOp {
        public static final String NAME = "OneHotEncoder";
        
        public enum Attribute implements OnnxAttribute {
            cats_strings(String[].class, true, null),
            cats_int64s(int[].class, true, null),
            zeros(Integer.class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<string>, tensor<int64>, tensor<int32>, tensor<float>, tensor<double>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            Y(null /* @@@ tensor<float> */, Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public OneHotEncoder(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        OneHotEncoder(OneHotEncoder that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public OneHotEncoder transform(CopyContext cc, OpTransformer ot) {
            return new OneHotEncoder(this, cc);
        }
        
        OneHotEncoder(TypeElement resultType, Value X, java.util.Optional<String[]> cats_strings, java.util.Optional<int[]> cats_int64s, java.util.Optional<Integer> zeros) {
            super(SCHEMA, resultType, Set.of(), List.of(X), List.of(cats_strings, cats_int64s, zeros));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X()));
        }
        
        public Value X() {
            return operands().get(0);
        }
        
        public java.util.Optional<String[]> cats_strings() {
            String[] cats_strings = Attribute.cats_strings.access(String[].class, onnxAttributes);
            return java.util.Optional.ofNullable(cats_strings).map(String[]::clone);
        }
        
        public java.util.Optional<int[]> cats_int64s() {
            int[] cats_int64s = Attribute.cats_int64s.access(int[].class, onnxAttributes);
            return java.util.Optional.ofNullable(cats_int64s).map(int[]::clone);
        }
        
        public java.util.Optional<Integer> zeros() {
            Integer zeros = Attribute.zeros.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(zeros);
        }
        
    }
    
    public static OneHotEncoder OneHotEncoder(TypeElement resultType, Value X, java.util.Optional<String[]> cats_strings, java.util.Optional<int[]> cats_int64s, java.util.Optional<Integer> zeros) {
        return new OneHotEncoder(resultType, X, cats_strings, cats_int64s, zeros);
    }

    @OpFactory.OpDeclaration(Optional.NAME)
    public static final class Optional extends OnnxOp {
        public static final String NAME = "Optional";
        
        public enum Attribute implements OnnxAttribute {
            type(byte[].class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            V(new OnnxType.TypeVariable("V", List.of(/* @@@ [tensor<uint8>, tensor<uint16>, tensor<uint32>, tensor<uint64>, tensor<int8>, tensor<int16>, tensor<int32>, tensor<int64>, tensor<float16>, tensor<float>, tensor<double>, tensor<string>, tensor<bool>, tensor<complex64>, tensor<complex128>, seq<tensor<uint8>>, seq<tensor<uint16>>, seq<tensor<uint32>>, seq<tensor<uint64>>, seq<tensor<int8>>, seq<tensor<int16>>, seq<tensor<int32>>, seq<tensor<int64>>, seq<tensor<float16>>, seq<tensor<float>>, seq<tensor<double>>, seq<tensor<string>>, seq<tensor<bool>>, seq<tensor<complex64>>, seq<tensor<complex128>>] */))),
            O(new OnnxType.TypeVariable("O", List.of(/* @@@ [optional<seq<tensor<uint8>>>, optional<seq<tensor<uint16>>>, optional<seq<tensor<uint32>>>, optional<seq<tensor<uint64>>>, optional<seq<tensor<int8>>>, optional<seq<tensor<int16>>>, optional<seq<tensor<int32>>>, optional<seq<tensor<int64>>>, optional<seq<tensor<float16>>>, optional<seq<tensor<float>>>, optional<seq<tensor<double>>>, optional<seq<tensor<string>>>, optional<seq<tensor<bool>>>, optional<seq<tensor<complex64>>>, optional<seq<tensor<complex128>>>, optional<tensor<uint8>>, optional<tensor<uint16>>, optional<tensor<uint32>>, optional<tensor<uint64>>, optional<tensor<int8>>, optional<tensor<int16>>, optional<tensor<int32>>, optional<tensor<int64>>, optional<tensor<float16>>, optional<tensor<float>>, optional<tensor<double>>, optional<tensor<string>>, optional<tensor<bool>>, optional<tensor<complex64>>, optional<tensor<complex128>>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            input(TypeConstraint.V.typeVariable(), Quantifier.OPTIONAL),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.O.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public Optional(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        Optional(Optional that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public Optional transform(CopyContext cc, OpTransformer ot) {
            return new Optional(this, cc);
        }
        
        Optional(TypeElement resultType, java.util.Optional<Value> input, java.util.Optional<byte[]> type) {
            super(SCHEMA, resultType, Set.of(), List.of(input), List.of(type));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(input()));
        }
        
        public java.util.Optional<Value> input() {
            int i = optionalInputArguments.indexOf(InputParameter.input);
            return i != -1 ? java.util.Optional.of(operands().get(0 + i)) : java.util.Optional.empty();
        }
        
        public java.util.Optional<byte[]> type() {
            byte[] type = Attribute.type.access(byte[].class, onnxAttributes);
            return java.util.Optional.ofNullable(type).map(byte[]::clone);
        }
        
    }
    
    public static Optional Optional(TypeElement resultType, java.util.Optional<Value> input, java.util.Optional<byte[]> type) {
        return new Optional(resultType, input, type);
    }

    @OpFactory.OpDeclaration(OptionalGetElement.NAME)
    public static final class OptionalGetElement extends OnnxOp {
        public static final String NAME = "OptionalGetElement";
        
        public enum Attribute implements OnnxAttribute.None { }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            O(new OnnxType.TypeVariable("O", List.of(/* @@@ [optional<seq<tensor<uint8>>>, optional<seq<tensor<uint16>>>, optional<seq<tensor<uint32>>>, optional<seq<tensor<uint64>>>, optional<seq<tensor<int8>>>, optional<seq<tensor<int16>>>, optional<seq<tensor<int32>>>, optional<seq<tensor<int64>>>, optional<seq<tensor<float16>>>, optional<seq<tensor<float>>>, optional<seq<tensor<double>>>, optional<seq<tensor<string>>>, optional<seq<tensor<bool>>>, optional<seq<tensor<complex64>>>, optional<seq<tensor<complex128>>>, optional<tensor<uint8>>, optional<tensor<uint16>>, optional<tensor<uint32>>, optional<tensor<uint64>>, optional<tensor<int8>>, optional<tensor<int16>>, optional<tensor<int32>>, optional<tensor<int64>>, optional<tensor<float16>>, optional<tensor<float>>, optional<tensor<double>>, optional<tensor<string>>, optional<tensor<bool>>, optional<tensor<complex64>>, optional<tensor<complex128>>, tensor<uint8>, tensor<uint16>, tensor<uint32>, tensor<uint64>, tensor<int8>, tensor<int16>, tensor<int32>, tensor<int64>, tensor<float16>, tensor<float>, tensor<double>, tensor<string>, tensor<bool>, tensor<complex64>, tensor<complex128>, seq<tensor<uint8>>, seq<tensor<uint16>>, seq<tensor<uint32>>, seq<tensor<uint64>>, seq<tensor<int8>>, seq<tensor<int16>>, seq<tensor<int32>>, seq<tensor<int64>>, seq<tensor<float16>>, seq<tensor<float>>, seq<tensor<double>>, seq<tensor<string>>, seq<tensor<bool>>, seq<tensor<complex64>>, seq<tensor<complex128>>] */))),
            V(new OnnxType.TypeVariable("V", List.of(/* @@@ [tensor<uint8>, tensor<uint16>, tensor<uint32>, tensor<uint64>, tensor<int8>, tensor<int16>, tensor<int32>, tensor<int64>, tensor<float16>, tensor<float>, tensor<double>, tensor<string>, tensor<bool>, tensor<complex64>, tensor<complex128>, seq<tensor<uint8>>, seq<tensor<uint16>>, seq<tensor<uint32>>, seq<tensor<uint64>>, seq<tensor<int8>>, seq<tensor<int16>>, seq<tensor<int32>>, seq<tensor<int64>>, seq<tensor<float16>>, seq<tensor<float>>, seq<tensor<double>>, seq<tensor<string>>, seq<tensor<bool>>, seq<tensor<complex64>>, seq<tensor<complex128>>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            input(TypeConstraint.O.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.V.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public OptionalGetElement(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        OptionalGetElement(OptionalGetElement that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public OptionalGetElement transform(CopyContext cc, OpTransformer ot) {
            return new OptionalGetElement(this, cc);
        }
        
        OptionalGetElement(TypeElement resultType, Value input) {
            super(SCHEMA, resultType, Set.of(), List.of(input), List.of());
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(input()));
        }
        
        public Value input() {
            return operands().get(0);
        }
        
    }
    
    public static OptionalGetElement OptionalGetElement(TypeElement resultType, Value input) {
        return new OptionalGetElement(resultType, input);
    }

    @OpFactory.OpDeclaration(OptionalHasElement.NAME)
    public static final class OptionalHasElement extends OnnxOp {
        public static final String NAME = "OptionalHasElement";
        
        public enum Attribute implements OnnxAttribute.None { }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            O(new OnnxType.TypeVariable("O", List.of(/* @@@ [optional<seq<tensor<uint8>>>, optional<seq<tensor<uint16>>>, optional<seq<tensor<uint32>>>, optional<seq<tensor<uint64>>>, optional<seq<tensor<int8>>>, optional<seq<tensor<int16>>>, optional<seq<tensor<int32>>>, optional<seq<tensor<int64>>>, optional<seq<tensor<float16>>>, optional<seq<tensor<float>>>, optional<seq<tensor<double>>>, optional<seq<tensor<string>>>, optional<seq<tensor<bool>>>, optional<seq<tensor<complex64>>>, optional<seq<tensor<complex128>>>, optional<tensor<uint8>>, optional<tensor<uint16>>, optional<tensor<uint32>>, optional<tensor<uint64>>, optional<tensor<int8>>, optional<tensor<int16>>, optional<tensor<int32>>, optional<tensor<int64>>, optional<tensor<float16>>, optional<tensor<float>>, optional<tensor<double>>, optional<tensor<string>>, optional<tensor<bool>>, optional<tensor<complex64>>, optional<tensor<complex128>>, tensor<uint8>, tensor<uint16>, tensor<uint32>, tensor<uint64>, tensor<int8>, tensor<int16>, tensor<int32>, tensor<int64>, tensor<float16>, tensor<float>, tensor<double>, tensor<string>, tensor<bool>, tensor<complex64>, tensor<complex128>, seq<tensor<uint8>>, seq<tensor<uint16>>, seq<tensor<uint32>>, seq<tensor<uint64>>, seq<tensor<int8>>, seq<tensor<int16>>, seq<tensor<int32>>, seq<tensor<int64>>, seq<tensor<float16>>, seq<tensor<float>>, seq<tensor<double>>, seq<tensor<string>>, seq<tensor<bool>>, seq<tensor<complex64>>, seq<tensor<complex128>>] */))),
            B(new OnnxType.TypeVariable("B", List.of(/* @@@ [tensor<bool>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            input(TypeConstraint.O.typeVariable(), Quantifier.OPTIONAL),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.B.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public OptionalHasElement(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        OptionalHasElement(OptionalHasElement that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public OptionalHasElement transform(CopyContext cc, OpTransformer ot) {
            return new OptionalHasElement(this, cc);
        }
        
        OptionalHasElement(TypeElement resultType, java.util.Optional<Value> input) {
            super(SCHEMA, resultType, Set.of(), List.of(input), List.of());
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(input()));
        }
        
        public java.util.Optional<Value> input() {
            int i = optionalInputArguments.indexOf(InputParameter.input);
            return i != -1 ? java.util.Optional.of(operands().get(0 + i)) : java.util.Optional.empty();
        }
        
    }
    
    public static OptionalHasElement OptionalHasElement(TypeElement resultType, java.util.Optional<Value> input) {
        return new OptionalHasElement(resultType, input);
    }

    @OpFactory.OpDeclaration(Or.NAME)
    public static final class Or extends OnnxOp {
        public static final String NAME = "Or";
        
        public enum Attribute implements OnnxAttribute.None { }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<bool>] */))),
            T1(new OnnxType.TypeVariable("T1", List.of(/* @@@ [tensor<bool>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            A(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            B(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            C(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public Or(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        Or(Or that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public Or transform(CopyContext cc, OpTransformer ot) {
            return new Or(this, cc);
        }
        
        Or(TypeElement resultType, Value A, Value B) {
            super(SCHEMA, resultType, Set.of(), List.of(A, B), List.of());
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(A(), B()));
        }
        
        public Value A() {
            return operands().get(0);
        }
        
        public Value B() {
            return operands().get(1);
        }
        
    }
    
    public static Or Or(TypeElement resultType, Value A, Value B) {
        return new Or(resultType, A, B);
    }

    @OpFactory.OpDeclaration(PRelu.NAME)
    public static final class PRelu extends OnnxOp {
        public static final String NAME = "PRelu";
        
        public enum Attribute implements OnnxAttribute.None { }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<bfloat16>, tensor<float16>, tensor<float>, tensor<double>, tensor<uint32>, tensor<uint64>, tensor<int32>, tensor<int64>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            slope(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public PRelu(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        PRelu(PRelu that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public PRelu transform(CopyContext cc, OpTransformer ot) {
            return new PRelu(this, cc);
        }
        
        PRelu(TypeElement resultType, Value X, Value slope) {
            super(SCHEMA, resultType, Set.of(), List.of(X, slope), List.of());
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X(), slope()));
        }
        
        public Value X() {
            return operands().get(0);
        }
        
        public Value slope() {
            return operands().get(1);
        }
        
    }
    
    public static PRelu PRelu(TypeElement resultType, Value X, Value slope) {
        return new PRelu(resultType, X, slope);
    }

    @OpFactory.OpDeclaration(Pad.NAME)
    public static final class Pad extends OnnxOp {
        public static final String NAME = "Pad";
        
        public enum Attribute implements OnnxAttribute {
            mode(String.class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<uint8>, tensor<uint16>, tensor<uint32>, tensor<uint64>, tensor<int8>, tensor<int16>, tensor<int32>, tensor<int64>, tensor<bfloat16>, tensor<float16>, tensor<float>, tensor<double>, tensor<string>, tensor<bool>, tensor<complex64>, tensor<complex128>, tensor<float8e4m3fn>, tensor<float8e4m3fnuz>, tensor<float8e5m2>, tensor<float8e5m2fnuz>, tensor<uint4>, tensor<int4>, tensor<float4e2m1>] */))),
            Tind(new OnnxType.TypeVariable("Tind", List.of(/* @@@ [tensor<int32>, tensor<int64>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            data(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            pads(null /* @@@ tensor<int64> */, Quantifier.REQUIRED),
            constant_value(TypeConstraint.T.typeVariable(), Quantifier.OPTIONAL),
            axes(TypeConstraint.Tind.typeVariable(), Quantifier.OPTIONAL),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public Pad(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        Pad(Pad that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public Pad transform(CopyContext cc, OpTransformer ot) {
            return new Pad(this, cc);
        }
        
        Pad(TypeElement resultType, Value data, Value pads, java.util.Optional<Value> constant_value, java.util.Optional<Value> axes, java.util.Optional<String> mode) {
            super(SCHEMA, resultType, Set.of(), List.of(data, pads, constant_value, axes), List.of(mode));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(data(), pads(), constant_value(), axes()));
        }
        
        public Value data() {
            return operands().get(0);
        }
        
        public Value pads() {
            return operands().get(1);
        }
        
        public java.util.Optional<Value> constant_value() {
            int i = optionalInputArguments.indexOf(InputParameter.constant_value);
            return i != -1 ? java.util.Optional.of(operands().get(2 + i)) : java.util.Optional.empty();
        }
        
        public java.util.Optional<Value> axes() {
            int i = optionalInputArguments.indexOf(InputParameter.axes);
            return i != -1 ? java.util.Optional.of(operands().get(2 + i)) : java.util.Optional.empty();
        }
        
        public java.util.Optional<String> mode() {
            String mode = Attribute.mode.access(String.class, onnxAttributes);
            return java.util.Optional.ofNullable(mode);
        }
        
    }
    
    public static Pad Pad(TypeElement resultType, Value data, Value pads, java.util.Optional<Value> constant_value, java.util.Optional<Value> axes, java.util.Optional<String> mode) {
        return new Pad(resultType, data, pads, constant_value, axes, mode);
    }

    @OpFactory.OpDeclaration(Pow.NAME)
    public static final class Pow extends OnnxOp {
        public static final String NAME = "Pow";
        
        public enum Attribute implements OnnxAttribute.None { }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<int32>, tensor<int64>, tensor<float16>, tensor<float>, tensor<double>, tensor<bfloat16>] */))),
            T1(new OnnxType.TypeVariable("T1", List.of(/* @@@ [tensor<uint8>, tensor<uint16>, tensor<uint32>, tensor<uint64>, tensor<int8>, tensor<int16>, tensor<int32>, tensor<int64>, tensor<float16>, tensor<float>, tensor<double>, tensor<bfloat16>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            Y(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            Z(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public Pow(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        Pow(Pow that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public Pow transform(CopyContext cc, OpTransformer ot) {
            return new Pow(this, cc);
        }
        
        Pow(TypeElement resultType, Value X, Value Y) {
            super(SCHEMA, resultType, Set.of(), List.of(X, Y), List.of());
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X(), Y()));
        }
        
        public Value X() {
            return operands().get(0);
        }
        
        public Value Y() {
            return operands().get(1);
        }
        
    }
    
    public static Pow Pow(TypeElement resultType, Value X, Value Y) {
        return new Pow(resultType, X, Y);
    }

    @OpFactory.OpDeclaration(QLinearConv.NAME)
    public static final class QLinearConv extends OnnxOp {
        public static final String NAME = "QLinearConv";
        
        public enum Attribute implements OnnxAttribute {
            pads(int[].class, true, null),
            dilations(int[].class, true, null),
            auto_pad(String.class, true, null),
            strides(int[].class, true, null),
            group(Integer.class, true, null),
            kernel_shape(int[].class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T1(new OnnxType.TypeVariable("T1", List.of(/* @@@ [tensor<int8>, tensor<uint8>] */))),
            T2(new OnnxType.TypeVariable("T2", List.of(/* @@@ [tensor<int8>, tensor<uint8>] */))),
            T3(new OnnxType.TypeVariable("T3", List.of(/* @@@ [tensor<int8>, tensor<uint8>] */))),
            T4(new OnnxType.TypeVariable("T4", List.of(/* @@@ [tensor<int32>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            x(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            x_scale(null /* @@@ tensor<float> */, Quantifier.REQUIRED),
            x_zero_point(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            w(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),
            w_scale(null /* @@@ tensor<float> */, Quantifier.REQUIRED),
            w_zero_point(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),
            y_scale(null /* @@@ tensor<float> */, Quantifier.REQUIRED),
            y_zero_point(TypeConstraint.T3.typeVariable(), Quantifier.REQUIRED),
            B(TypeConstraint.T4.typeVariable(), Quantifier.OPTIONAL),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            y(TypeConstraint.T3.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public QLinearConv(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        QLinearConv(QLinearConv that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public QLinearConv transform(CopyContext cc, OpTransformer ot) {
            return new QLinearConv(this, cc);
        }
        
        QLinearConv(TypeElement resultType, Value x, Value x_scale, Value x_zero_point, Value w, Value w_scale, Value w_zero_point, Value y_scale, Value y_zero_point, java.util.Optional<Value> B, java.util.Optional<int[]> pads, java.util.Optional<int[]> dilations, java.util.Optional<String> auto_pad, java.util.Optional<int[]> strides, java.util.Optional<Integer> group, java.util.Optional<int[]> kernel_shape) {
            super(SCHEMA, resultType, Set.of(), List.of(x, x_scale, x_zero_point, w, w_scale, w_zero_point, y_scale, y_zero_point, B), List.of(pads, dilations, auto_pad, strides, group, kernel_shape));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(x(), x_scale(), x_zero_point(), w(), w_scale(), w_zero_point(), y_scale(), y_zero_point(), B()));
        }
        
        public Value x() {
            return operands().get(0);
        }
        
        public Value x_scale() {
            return operands().get(1);
        }
        
        public Value x_zero_point() {
            return operands().get(2);
        }
        
        public Value w() {
            return operands().get(3);
        }
        
        public Value w_scale() {
            return operands().get(4);
        }
        
        public Value w_zero_point() {
            return operands().get(5);
        }
        
        public Value y_scale() {
            return operands().get(6);
        }
        
        public Value y_zero_point() {
            return operands().get(7);
        }
        
        public java.util.Optional<Value> B() {
            int i = optionalInputArguments.indexOf(InputParameter.B);
            return i != -1 ? java.util.Optional.of(operands().get(8 + i)) : java.util.Optional.empty();
        }
        
        public java.util.Optional<int[]> pads() {
            int[] pads = Attribute.pads.access(int[].class, onnxAttributes);
            return java.util.Optional.ofNullable(pads).map(int[]::clone);
        }
        
        public java.util.Optional<int[]> dilations() {
            int[] dilations = Attribute.dilations.access(int[].class, onnxAttributes);
            return java.util.Optional.ofNullable(dilations).map(int[]::clone);
        }
        
        public java.util.Optional<String> auto_pad() {
            String auto_pad = Attribute.auto_pad.access(String.class, onnxAttributes);
            return java.util.Optional.ofNullable(auto_pad);
        }
        
        public java.util.Optional<int[]> strides() {
            int[] strides = Attribute.strides.access(int[].class, onnxAttributes);
            return java.util.Optional.ofNullable(strides).map(int[]::clone);
        }
        
        public java.util.Optional<Integer> group() {
            Integer group = Attribute.group.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(group);
        }
        
        public java.util.Optional<int[]> kernel_shape() {
            int[] kernel_shape = Attribute.kernel_shape.access(int[].class, onnxAttributes);
            return java.util.Optional.ofNullable(kernel_shape).map(int[]::clone);
        }
        
    }
    
    public static QLinearConv QLinearConv(TypeElement resultType, Value x, Value x_scale, Value x_zero_point, Value w, Value w_scale, Value w_zero_point, Value y_scale, Value y_zero_point, java.util.Optional<Value> B, java.util.Optional<int[]> pads, java.util.Optional<int[]> dilations, java.util.Optional<String> auto_pad, java.util.Optional<int[]> strides, java.util.Optional<Integer> group, java.util.Optional<int[]> kernel_shape) {
        return new QLinearConv(resultType, x, x_scale, x_zero_point, w, w_scale, w_zero_point, y_scale, y_zero_point, B, pads, dilations, auto_pad, strides, group, kernel_shape);
    }

    @OpFactory.OpDeclaration(QLinearMatMul.NAME)
    public static final class QLinearMatMul extends OnnxOp {
        public static final String NAME = "QLinearMatMul";
        
        public enum Attribute implements OnnxAttribute.None { }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            TS(new OnnxType.TypeVariable("TS", List.of(/* @@@ [tensor<float>, tensor<float16>, tensor<bfloat16>] */))),
            T1(new OnnxType.TypeVariable("T1", List.of(/* @@@ [tensor<int8>, tensor<uint8>, tensor<float8e4m3fn>, tensor<float8e4m3fnuz>, tensor<float8e5m2>, tensor<float8e5m2fnuz>] */))),
            T2(new OnnxType.TypeVariable("T2", List.of(/* @@@ [tensor<int8>, tensor<uint8>, tensor<float8e4m3fn>, tensor<float8e4m3fnuz>, tensor<float8e5m2>, tensor<float8e5m2fnuz>] */))),
            T3(new OnnxType.TypeVariable("T3", List.of(/* @@@ [tensor<int8>, tensor<uint8>, tensor<float8e4m3fn>, tensor<float8e4m3fnuz>, tensor<float8e5m2>, tensor<float8e5m2fnuz>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            a(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            a_scale(TypeConstraint.TS.typeVariable(), Quantifier.REQUIRED),
            a_zero_point(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            b(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),
            b_scale(TypeConstraint.TS.typeVariable(), Quantifier.REQUIRED),
            b_zero_point(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),
            y_scale(TypeConstraint.TS.typeVariable(), Quantifier.REQUIRED),
            y_zero_point(TypeConstraint.T3.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            y(TypeConstraint.T3.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public QLinearMatMul(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        QLinearMatMul(QLinearMatMul that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public QLinearMatMul transform(CopyContext cc, OpTransformer ot) {
            return new QLinearMatMul(this, cc);
        }
        
        QLinearMatMul(TypeElement resultType, Value a, Value a_scale, Value a_zero_point, Value b, Value b_scale, Value b_zero_point, Value y_scale, Value y_zero_point) {
            super(SCHEMA, resultType, Set.of(), List.of(a, a_scale, a_zero_point, b, b_scale, b_zero_point, y_scale, y_zero_point), List.of());
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(a(), a_scale(), a_zero_point(), b(), b_scale(), b_zero_point(), y_scale(), y_zero_point()));
        }
        
        public Value a() {
            return operands().get(0);
        }
        
        public Value a_scale() {
            return operands().get(1);
        }
        
        public Value a_zero_point() {
            return operands().get(2);
        }
        
        public Value b() {
            return operands().get(3);
        }
        
        public Value b_scale() {
            return operands().get(4);
        }
        
        public Value b_zero_point() {
            return operands().get(5);
        }
        
        public Value y_scale() {
            return operands().get(6);
        }
        
        public Value y_zero_point() {
            return operands().get(7);
        }
        
    }
    
    public static QLinearMatMul QLinearMatMul(TypeElement resultType, Value a, Value a_scale, Value a_zero_point, Value b, Value b_scale, Value b_zero_point, Value y_scale, Value y_zero_point) {
        return new QLinearMatMul(resultType, a, a_scale, a_zero_point, b, b_scale, b_zero_point, y_scale, y_zero_point);
    }

    @OpFactory.OpDeclaration(QuantizeLinear.NAME)
    public static final class QuantizeLinear extends OnnxOp {
        public static final String NAME = "QuantizeLinear";
        
        public enum Attribute implements OnnxAttribute {
            output_dtype(Integer.class, true, null),
            saturate(Integer.class, true, null),
            axis(Integer.class, true, null),
            block_size(Integer.class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T1(new OnnxType.TypeVariable("T1", List.of(/* @@@ [tensor<float>, tensor<float16>, tensor<bfloat16>, tensor<int32>] */))),
            T2(new OnnxType.TypeVariable("T2", List.of(/* @@@ [tensor<int8>, tensor<uint8>, tensor<int16>, tensor<uint16>, tensor<float8e4m3fn>, tensor<float8e4m3fnuz>, tensor<float8e5m2>, tensor<float8e5m2fnuz>, tensor<uint4>, tensor<int4>, tensor<float4e2m1>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            x(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            y_scale(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            y_zero_point(TypeConstraint.T2.typeVariable(), Quantifier.OPTIONAL),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            y(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public QuantizeLinear(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        QuantizeLinear(QuantizeLinear that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public QuantizeLinear transform(CopyContext cc, OpTransformer ot) {
            return new QuantizeLinear(this, cc);
        }
        
        QuantizeLinear(TypeElement resultType, Value x, Value y_scale, java.util.Optional<Value> y_zero_point, java.util.Optional<Integer> output_dtype, java.util.Optional<Integer> saturate, java.util.Optional<Integer> axis, java.util.Optional<Integer> block_size) {
            super(SCHEMA, resultType, Set.of(), List.of(x, y_scale, y_zero_point), List.of(output_dtype, saturate, axis, block_size));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(x(), y_scale(), y_zero_point()));
        }
        
        public Value x() {
            return operands().get(0);
        }
        
        public Value y_scale() {
            return operands().get(1);
        }
        
        public java.util.Optional<Value> y_zero_point() {
            int i = optionalInputArguments.indexOf(InputParameter.y_zero_point);
            return i != -1 ? java.util.Optional.of(operands().get(2 + i)) : java.util.Optional.empty();
        }
        
        public java.util.Optional<Integer> output_dtype() {
            Integer output_dtype = Attribute.output_dtype.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(output_dtype);
        }
        
        public java.util.Optional<Integer> saturate() {
            Integer saturate = Attribute.saturate.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(saturate);
        }
        
        public java.util.Optional<Integer> axis() {
            Integer axis = Attribute.axis.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(axis);
        }
        
        public java.util.Optional<Integer> block_size() {
            Integer block_size = Attribute.block_size.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(block_size);
        }
        
    }
    
    public static QuantizeLinear QuantizeLinear(TypeElement resultType, Value x, Value y_scale, java.util.Optional<Value> y_zero_point, java.util.Optional<Integer> output_dtype, java.util.Optional<Integer> saturate, java.util.Optional<Integer> axis, java.util.Optional<Integer> block_size) {
        return new QuantizeLinear(resultType, x, y_scale, y_zero_point, output_dtype, saturate, axis, block_size);
    }

    @OpFactory.OpDeclaration(RNN.NAME)
    public static final class RNN extends OnnxOp {
        public static final String NAME = "RNN";
        
        public enum Attribute implements OnnxAttribute {
            layout(Integer.class, true, null),
            activation_alpha(float[].class, true, null),
            hidden_size(Integer.class, true, null),
            activation_beta(float[].class, true, null),
            activations(String[].class, true, null),
            clip(Float.class, true, null),
            direction(String.class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<bfloat16>, tensor<float16>, tensor<float>, tensor<double>] */))),
            T1(new OnnxType.TypeVariable("T1", List.of(/* @@@ [tensor<int32>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            W(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            R(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            B(TypeConstraint.T.typeVariable(), Quantifier.OPTIONAL),
            sequence_lens(TypeConstraint.T1.typeVariable(), Quantifier.OPTIONAL),
            initial_h(TypeConstraint.T.typeVariable(), Quantifier.OPTIONAL),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T.typeVariable(), Quantifier.OPTIONAL),
            Y_h(TypeConstraint.T.typeVariable(), Quantifier.OPTIONAL),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public RNN(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        RNN(RNN that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public RNN transform(CopyContext cc, OpTransformer ot) {
            return new RNN(this, cc);
        }
        
        RNN(TypeElement resultType, Value X, Value W, Value R, java.util.Optional<Value> B, java.util.Optional<Value> sequence_lens, java.util.Optional<Value> initial_h, java.util.Optional<Integer> layout, java.util.Optional<float[]> activation_alpha, java.util.Optional<Integer> hidden_size, java.util.Optional<float[]> activation_beta, java.util.Optional<String[]> activations, java.util.Optional<Float> clip, java.util.Optional<String> direction) {
            super(SCHEMA, resultType, Set.of(), List.of(X, W, R, B, sequence_lens, initial_h), List.of(layout, activation_alpha, hidden_size, activation_beta, activations, clip, direction));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X(), W(), R(), B(), sequence_lens(), initial_h()));
        }
        
        public Value X() {
            return operands().get(0);
        }
        
        public Value W() {
            return operands().get(1);
        }
        
        public Value R() {
            return operands().get(2);
        }
        
        public java.util.Optional<Value> B() {
            int i = optionalInputArguments.indexOf(InputParameter.B);
            return i != -1 ? java.util.Optional.of(operands().get(3 + i)) : java.util.Optional.empty();
        }
        
        public java.util.Optional<Value> sequence_lens() {
            int i = optionalInputArguments.indexOf(InputParameter.sequence_lens);
            return i != -1 ? java.util.Optional.of(operands().get(3 + i)) : java.util.Optional.empty();
        }
        
        public java.util.Optional<Value> initial_h() {
            int i = optionalInputArguments.indexOf(InputParameter.initial_h);
            return i != -1 ? java.util.Optional.of(operands().get(3 + i)) : java.util.Optional.empty();
        }
        
        public java.util.Optional<Integer> layout() {
            Integer layout = Attribute.layout.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(layout);
        }
        
        public java.util.Optional<float[]> activation_alpha() {
            float[] activation_alpha = Attribute.activation_alpha.access(float[].class, onnxAttributes);
            return java.util.Optional.ofNullable(activation_alpha).map(float[]::clone);
        }
        
        public java.util.Optional<Integer> hidden_size() {
            Integer hidden_size = Attribute.hidden_size.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(hidden_size);
        }
        
        public java.util.Optional<float[]> activation_beta() {
            float[] activation_beta = Attribute.activation_beta.access(float[].class, onnxAttributes);
            return java.util.Optional.ofNullable(activation_beta).map(float[]::clone);
        }
        
        public java.util.Optional<String[]> activations() {
            String[] activations = Attribute.activations.access(String[].class, onnxAttributes);
            return java.util.Optional.ofNullable(activations).map(String[]::clone);
        }
        
        public java.util.Optional<Float> clip() {
            Float clip = Attribute.clip.access(Float.class, onnxAttributes);
            return java.util.Optional.ofNullable(clip);
        }
        
        public java.util.Optional<String> direction() {
            String direction = Attribute.direction.access(String.class, onnxAttributes);
            return java.util.Optional.ofNullable(direction);
        }
        
    }
    
    public static RNN RNN(TypeElement resultType, Value X, Value W, Value R, java.util.Optional<Value> B, java.util.Optional<Value> sequence_lens, java.util.Optional<Value> initial_h, java.util.Optional<Integer> layout, java.util.Optional<float[]> activation_alpha, java.util.Optional<Integer> hidden_size, java.util.Optional<float[]> activation_beta, java.util.Optional<String[]> activations, java.util.Optional<Float> clip, java.util.Optional<String> direction) {
        return new RNN(resultType, X, W, R, B, sequence_lens, initial_h, layout, activation_alpha, hidden_size, activation_beta, activations, clip, direction);
    }

    @OpFactory.OpDeclaration(RandomNormal.NAME)
    public static final class RandomNormal extends OnnxOp {
        public static final String NAME = "RandomNormal";
        
        public enum Attribute implements OnnxAttribute {
            shape(int[].class, false, null),
            seed(Float.class, true, null),
            mean(Float.class, true, null),
            scale(Float.class, true, null),
            dtype(Integer.class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<bfloat16>, tensor<float16>, tensor<float>, tensor<double>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter.None { }
        
        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public RandomNormal(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        RandomNormal(RandomNormal that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public RandomNormal transform(CopyContext cc, OpTransformer ot) {
            return new RandomNormal(this, cc);
        }
        
        RandomNormal(TypeElement resultType, int[] shape, java.util.Optional<Float> seed, java.util.Optional<Float> mean, java.util.Optional<Float> scale, java.util.Optional<Integer> dtype) {
            super(SCHEMA, resultType, Set.of(), List.of(), List.of(shape, seed, mean, scale, dtype));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of());
        }
        
        public int[] shape() {
            int[] shape = Attribute.shape.access(int[].class, onnxAttributes);
            return shape.clone();
        }
        
        public java.util.Optional<Float> seed() {
            Float seed = Attribute.seed.access(Float.class, onnxAttributes);
            return java.util.Optional.ofNullable(seed);
        }
        
        public java.util.Optional<Float> mean() {
            Float mean = Attribute.mean.access(Float.class, onnxAttributes);
            return java.util.Optional.ofNullable(mean);
        }
        
        public java.util.Optional<Float> scale() {
            Float scale = Attribute.scale.access(Float.class, onnxAttributes);
            return java.util.Optional.ofNullable(scale);
        }
        
        public java.util.Optional<Integer> dtype() {
            Integer dtype = Attribute.dtype.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(dtype);
        }
        
    }
    
    public static RandomNormal RandomNormal(TypeElement resultType, int[] shape, java.util.Optional<Float> seed, java.util.Optional<Float> mean, java.util.Optional<Float> scale, java.util.Optional<Integer> dtype) {
        return new RandomNormal(resultType, shape, seed, mean, scale, dtype);
    }

    @OpFactory.OpDeclaration(RandomNormalLike.NAME)
    public static final class RandomNormalLike extends OnnxOp {
        public static final String NAME = "RandomNormalLike";
        
        public enum Attribute implements OnnxAttribute {
            seed(Float.class, true, null),
            mean(Float.class, true, null),
            scale(Float.class, true, null),
            dtype(Integer.class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T1(new OnnxType.TypeVariable("T1", List.of(/* @@@ [tensor<uint8>, tensor<uint16>, tensor<uint32>, tensor<uint64>, tensor<int8>, tensor<int16>, tensor<int32>, tensor<int64>, tensor<bfloat16>, tensor<float16>, tensor<float>, tensor<double>, tensor<string>, tensor<bool>, tensor<complex64>, tensor<complex128>] */))),
            T2(new OnnxType.TypeVariable("T2", List.of(/* @@@ [tensor<bfloat16>, tensor<float16>, tensor<float>, tensor<double>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            input(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public RandomNormalLike(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        RandomNormalLike(RandomNormalLike that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public RandomNormalLike transform(CopyContext cc, OpTransformer ot) {
            return new RandomNormalLike(this, cc);
        }
        
        RandomNormalLike(TypeElement resultType, Value input, java.util.Optional<Float> seed, java.util.Optional<Float> mean, java.util.Optional<Float> scale, java.util.Optional<Integer> dtype) {
            super(SCHEMA, resultType, Set.of(), List.of(input), List.of(seed, mean, scale, dtype));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(input()));
        }
        
        public Value input() {
            return operands().get(0);
        }
        
        public java.util.Optional<Float> seed() {
            Float seed = Attribute.seed.access(Float.class, onnxAttributes);
            return java.util.Optional.ofNullable(seed);
        }
        
        public java.util.Optional<Float> mean() {
            Float mean = Attribute.mean.access(Float.class, onnxAttributes);
            return java.util.Optional.ofNullable(mean);
        }
        
        public java.util.Optional<Float> scale() {
            Float scale = Attribute.scale.access(Float.class, onnxAttributes);
            return java.util.Optional.ofNullable(scale);
        }
        
        public java.util.Optional<Integer> dtype() {
            Integer dtype = Attribute.dtype.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(dtype);
        }
        
    }
    
    public static RandomNormalLike RandomNormalLike(TypeElement resultType, Value input, java.util.Optional<Float> seed, java.util.Optional<Float> mean, java.util.Optional<Float> scale, java.util.Optional<Integer> dtype) {
        return new RandomNormalLike(resultType, input, seed, mean, scale, dtype);
    }

    @OpFactory.OpDeclaration(RandomUniform.NAME)
    public static final class RandomUniform extends OnnxOp {
        public static final String NAME = "RandomUniform";
        
        public enum Attribute implements OnnxAttribute {
            high(Float.class, true, null),
            shape(int[].class, false, null),
            seed(Float.class, true, null),
            low(Float.class, true, null),
            dtype(Integer.class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<bfloat16>, tensor<float16>, tensor<float>, tensor<double>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter.None { }
        
        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public RandomUniform(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        RandomUniform(RandomUniform that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public RandomUniform transform(CopyContext cc, OpTransformer ot) {
            return new RandomUniform(this, cc);
        }
        
        RandomUniform(TypeElement resultType, java.util.Optional<Float> high, int[] shape, java.util.Optional<Float> seed, java.util.Optional<Float> low, java.util.Optional<Integer> dtype) {
            super(SCHEMA, resultType, Set.of(), List.of(), List.of(high, shape, seed, low, dtype));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of());
        }
        
        public java.util.Optional<Float> high() {
            Float high = Attribute.high.access(Float.class, onnxAttributes);
            return java.util.Optional.ofNullable(high);
        }
        
        public int[] shape() {
            int[] shape = Attribute.shape.access(int[].class, onnxAttributes);
            return shape.clone();
        }
        
        public java.util.Optional<Float> seed() {
            Float seed = Attribute.seed.access(Float.class, onnxAttributes);
            return java.util.Optional.ofNullable(seed);
        }
        
        public java.util.Optional<Float> low() {
            Float low = Attribute.low.access(Float.class, onnxAttributes);
            return java.util.Optional.ofNullable(low);
        }
        
        public java.util.Optional<Integer> dtype() {
            Integer dtype = Attribute.dtype.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(dtype);
        }
        
    }
    
    public static RandomUniform RandomUniform(TypeElement resultType, java.util.Optional<Float> high, int[] shape, java.util.Optional<Float> seed, java.util.Optional<Float> low, java.util.Optional<Integer> dtype) {
        return new RandomUniform(resultType, high, shape, seed, low, dtype);
    }

    @OpFactory.OpDeclaration(RandomUniformLike.NAME)
    public static final class RandomUniformLike extends OnnxOp {
        public static final String NAME = "RandomUniformLike";
        
        public enum Attribute implements OnnxAttribute {
            high(Float.class, true, null),
            seed(Float.class, true, null),
            low(Float.class, true, null),
            dtype(Integer.class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T1(new OnnxType.TypeVariable("T1", List.of(/* @@@ [tensor<uint8>, tensor<uint16>, tensor<uint32>, tensor<uint64>, tensor<int8>, tensor<int16>, tensor<int32>, tensor<int64>, tensor<bfloat16>, tensor<float16>, tensor<float>, tensor<double>, tensor<string>, tensor<bool>, tensor<complex64>, tensor<complex128>] */))),
            T2(new OnnxType.TypeVariable("T2", List.of(/* @@@ [tensor<bfloat16>, tensor<float16>, tensor<float>, tensor<double>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            input(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public RandomUniformLike(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        RandomUniformLike(RandomUniformLike that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public RandomUniformLike transform(CopyContext cc, OpTransformer ot) {
            return new RandomUniformLike(this, cc);
        }
        
        RandomUniformLike(TypeElement resultType, Value input, java.util.Optional<Float> high, java.util.Optional<Float> seed, java.util.Optional<Float> low, java.util.Optional<Integer> dtype) {
            super(SCHEMA, resultType, Set.of(), List.of(input), List.of(high, seed, low, dtype));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(input()));
        }
        
        public Value input() {
            return operands().get(0);
        }
        
        public java.util.Optional<Float> high() {
            Float high = Attribute.high.access(Float.class, onnxAttributes);
            return java.util.Optional.ofNullable(high);
        }
        
        public java.util.Optional<Float> seed() {
            Float seed = Attribute.seed.access(Float.class, onnxAttributes);
            return java.util.Optional.ofNullable(seed);
        }
        
        public java.util.Optional<Float> low() {
            Float low = Attribute.low.access(Float.class, onnxAttributes);
            return java.util.Optional.ofNullable(low);
        }
        
        public java.util.Optional<Integer> dtype() {
            Integer dtype = Attribute.dtype.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(dtype);
        }
        
    }
    
    public static RandomUniformLike RandomUniformLike(TypeElement resultType, Value input, java.util.Optional<Float> high, java.util.Optional<Float> seed, java.util.Optional<Float> low, java.util.Optional<Integer> dtype) {
        return new RandomUniformLike(resultType, input, high, seed, low, dtype);
    }

    @OpFactory.OpDeclaration(Range.NAME)
    public static final class Range extends OnnxOp {
        public static final String NAME = "Range";
        
        public enum Attribute implements OnnxAttribute.None { }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<float>, tensor<double>, tensor<int16>, tensor<int32>, tensor<int64>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            start(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            limit(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            delta(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public Range(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        Range(Range that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public Range transform(CopyContext cc, OpTransformer ot) {
            return new Range(this, cc);
        }
        
        Range(TypeElement resultType, Value start, Value limit, Value delta) {
            super(SCHEMA, resultType, Set.of(), List.of(start, limit, delta), List.of());
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(start(), limit(), delta()));
        }
        
        public Value start() {
            return operands().get(0);
        }
        
        public Value limit() {
            return operands().get(1);
        }
        
        public Value delta() {
            return operands().get(2);
        }
        
    }
    
    public static Range Range(TypeElement resultType, Value start, Value limit, Value delta) {
        return new Range(resultType, start, limit, delta);
    }

    @OpFactory.OpDeclaration(Reciprocal.NAME)
    public static final class Reciprocal extends OnnxOp {
        public static final String NAME = "Reciprocal";
        
        public enum Attribute implements OnnxAttribute.None { }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<float16>, tensor<float>, tensor<double>, tensor<bfloat16>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public Reciprocal(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        Reciprocal(Reciprocal that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public Reciprocal transform(CopyContext cc, OpTransformer ot) {
            return new Reciprocal(this, cc);
        }
        
        Reciprocal(TypeElement resultType, Value X) {
            super(SCHEMA, resultType, Set.of(), List.of(X), List.of());
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X()));
        }
        
        public Value X() {
            return operands().get(0);
        }
        
    }
    
    public static Reciprocal Reciprocal(TypeElement resultType, Value X) {
        return new Reciprocal(resultType, X);
    }

    @OpFactory.OpDeclaration(ReduceL1.NAME)
    public static final class ReduceL1 extends OnnxOp {
        public static final String NAME = "ReduceL1";
        
        public enum Attribute implements OnnxAttribute {
            noop_with_empty_axes(Integer.class, true, null),
            keepdims(Integer.class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<uint32>, tensor<uint64>, tensor<int32>, tensor<int64>, tensor<float16>, tensor<float>, tensor<double>, tensor<bfloat16>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            data(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            axes(null /* @@@ tensor<int64> */, Quantifier.OPTIONAL),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            reduced(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public ReduceL1(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        ReduceL1(ReduceL1 that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public ReduceL1 transform(CopyContext cc, OpTransformer ot) {
            return new ReduceL1(this, cc);
        }
        
        ReduceL1(TypeElement resultType, Value data, java.util.Optional<Value> axes, java.util.Optional<Integer> noop_with_empty_axes, java.util.Optional<Integer> keepdims) {
            super(SCHEMA, resultType, Set.of(), List.of(data, axes), List.of(noop_with_empty_axes, keepdims));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(data(), axes()));
        }
        
        public Value data() {
            return operands().get(0);
        }
        
        public java.util.Optional<Value> axes() {
            int i = optionalInputArguments.indexOf(InputParameter.axes);
            return i != -1 ? java.util.Optional.of(operands().get(1 + i)) : java.util.Optional.empty();
        }
        
        public java.util.Optional<Integer> noop_with_empty_axes() {
            Integer noop_with_empty_axes = Attribute.noop_with_empty_axes.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(noop_with_empty_axes);
        }
        
        public java.util.Optional<Integer> keepdims() {
            Integer keepdims = Attribute.keepdims.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(keepdims);
        }
        
    }
    
    public static ReduceL1 ReduceL1(TypeElement resultType, Value data, java.util.Optional<Value> axes, java.util.Optional<Integer> noop_with_empty_axes, java.util.Optional<Integer> keepdims) {
        return new ReduceL1(resultType, data, axes, noop_with_empty_axes, keepdims);
    }

    @OpFactory.OpDeclaration(ReduceL2.NAME)
    public static final class ReduceL2 extends OnnxOp {
        public static final String NAME = "ReduceL2";
        
        public enum Attribute implements OnnxAttribute {
            noop_with_empty_axes(Integer.class, true, null),
            keepdims(Integer.class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<uint32>, tensor<uint64>, tensor<int32>, tensor<int64>, tensor<float16>, tensor<float>, tensor<double>, tensor<bfloat16>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            data(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            axes(null /* @@@ tensor<int64> */, Quantifier.OPTIONAL),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            reduced(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public ReduceL2(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        ReduceL2(ReduceL2 that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public ReduceL2 transform(CopyContext cc, OpTransformer ot) {
            return new ReduceL2(this, cc);
        }
        
        ReduceL2(TypeElement resultType, Value data, java.util.Optional<Value> axes, java.util.Optional<Integer> noop_with_empty_axes, java.util.Optional<Integer> keepdims) {
            super(SCHEMA, resultType, Set.of(), List.of(data, axes), List.of(noop_with_empty_axes, keepdims));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(data(), axes()));
        }
        
        public Value data() {
            return operands().get(0);
        }
        
        public java.util.Optional<Value> axes() {
            int i = optionalInputArguments.indexOf(InputParameter.axes);
            return i != -1 ? java.util.Optional.of(operands().get(1 + i)) : java.util.Optional.empty();
        }
        
        public java.util.Optional<Integer> noop_with_empty_axes() {
            Integer noop_with_empty_axes = Attribute.noop_with_empty_axes.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(noop_with_empty_axes);
        }
        
        public java.util.Optional<Integer> keepdims() {
            Integer keepdims = Attribute.keepdims.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(keepdims);
        }
        
    }
    
    public static ReduceL2 ReduceL2(TypeElement resultType, Value data, java.util.Optional<Value> axes, java.util.Optional<Integer> noop_with_empty_axes, java.util.Optional<Integer> keepdims) {
        return new ReduceL2(resultType, data, axes, noop_with_empty_axes, keepdims);
    }

    @OpFactory.OpDeclaration(ReduceLogSum.NAME)
    public static final class ReduceLogSum extends OnnxOp {
        public static final String NAME = "ReduceLogSum";
        
        public enum Attribute implements OnnxAttribute {
            noop_with_empty_axes(Integer.class, true, null),
            keepdims(Integer.class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<uint32>, tensor<uint64>, tensor<int32>, tensor<int64>, tensor<float16>, tensor<float>, tensor<double>, tensor<bfloat16>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            data(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            axes(null /* @@@ tensor<int64> */, Quantifier.OPTIONAL),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            reduced(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public ReduceLogSum(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        ReduceLogSum(ReduceLogSum that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public ReduceLogSum transform(CopyContext cc, OpTransformer ot) {
            return new ReduceLogSum(this, cc);
        }
        
        ReduceLogSum(TypeElement resultType, Value data, java.util.Optional<Value> axes, java.util.Optional<Integer> noop_with_empty_axes, java.util.Optional<Integer> keepdims) {
            super(SCHEMA, resultType, Set.of(), List.of(data, axes), List.of(noop_with_empty_axes, keepdims));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(data(), axes()));
        }
        
        public Value data() {
            return operands().get(0);
        }
        
        public java.util.Optional<Value> axes() {
            int i = optionalInputArguments.indexOf(InputParameter.axes);
            return i != -1 ? java.util.Optional.of(operands().get(1 + i)) : java.util.Optional.empty();
        }
        
        public java.util.Optional<Integer> noop_with_empty_axes() {
            Integer noop_with_empty_axes = Attribute.noop_with_empty_axes.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(noop_with_empty_axes);
        }
        
        public java.util.Optional<Integer> keepdims() {
            Integer keepdims = Attribute.keepdims.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(keepdims);
        }
        
    }
    
    public static ReduceLogSum ReduceLogSum(TypeElement resultType, Value data, java.util.Optional<Value> axes, java.util.Optional<Integer> noop_with_empty_axes, java.util.Optional<Integer> keepdims) {
        return new ReduceLogSum(resultType, data, axes, noop_with_empty_axes, keepdims);
    }

    @OpFactory.OpDeclaration(ReduceLogSumExp.NAME)
    public static final class ReduceLogSumExp extends OnnxOp {
        public static final String NAME = "ReduceLogSumExp";
        
        public enum Attribute implements OnnxAttribute {
            noop_with_empty_axes(Integer.class, true, null),
            keepdims(Integer.class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<uint32>, tensor<uint64>, tensor<int32>, tensor<int64>, tensor<float16>, tensor<float>, tensor<double>, tensor<bfloat16>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            data(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            axes(null /* @@@ tensor<int64> */, Quantifier.OPTIONAL),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            reduced(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public ReduceLogSumExp(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        ReduceLogSumExp(ReduceLogSumExp that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public ReduceLogSumExp transform(CopyContext cc, OpTransformer ot) {
            return new ReduceLogSumExp(this, cc);
        }
        
        ReduceLogSumExp(TypeElement resultType, Value data, java.util.Optional<Value> axes, java.util.Optional<Integer> noop_with_empty_axes, java.util.Optional<Integer> keepdims) {
            super(SCHEMA, resultType, Set.of(), List.of(data, axes), List.of(noop_with_empty_axes, keepdims));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(data(), axes()));
        }
        
        public Value data() {
            return operands().get(0);
        }
        
        public java.util.Optional<Value> axes() {
            int i = optionalInputArguments.indexOf(InputParameter.axes);
            return i != -1 ? java.util.Optional.of(operands().get(1 + i)) : java.util.Optional.empty();
        }
        
        public java.util.Optional<Integer> noop_with_empty_axes() {
            Integer noop_with_empty_axes = Attribute.noop_with_empty_axes.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(noop_with_empty_axes);
        }
        
        public java.util.Optional<Integer> keepdims() {
            Integer keepdims = Attribute.keepdims.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(keepdims);
        }
        
    }
    
    public static ReduceLogSumExp ReduceLogSumExp(TypeElement resultType, Value data, java.util.Optional<Value> axes, java.util.Optional<Integer> noop_with_empty_axes, java.util.Optional<Integer> keepdims) {
        return new ReduceLogSumExp(resultType, data, axes, noop_with_empty_axes, keepdims);
    }

    @OpFactory.OpDeclaration(ReduceMax.NAME)
    public static final class ReduceMax extends OnnxOp {
        public static final String NAME = "ReduceMax";
        
        public enum Attribute implements OnnxAttribute {
            noop_with_empty_axes(Integer.class, true, null),
            keepdims(Integer.class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<uint32>, tensor<uint64>, tensor<int32>, tensor<int64>, tensor<float16>, tensor<float>, tensor<double>, tensor<bfloat16>, tensor<uint8>, tensor<int8>, tensor<bool>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            data(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            axes(null /* @@@ tensor<int64> */, Quantifier.OPTIONAL),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            reduced(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public ReduceMax(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        ReduceMax(ReduceMax that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public ReduceMax transform(CopyContext cc, OpTransformer ot) {
            return new ReduceMax(this, cc);
        }
        
        ReduceMax(TypeElement resultType, Value data, java.util.Optional<Value> axes, java.util.Optional<Integer> noop_with_empty_axes, java.util.Optional<Integer> keepdims) {
            super(SCHEMA, resultType, Set.of(), List.of(data, axes), List.of(noop_with_empty_axes, keepdims));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(data(), axes()));
        }
        
        public Value data() {
            return operands().get(0);
        }
        
        public java.util.Optional<Value> axes() {
            int i = optionalInputArguments.indexOf(InputParameter.axes);
            return i != -1 ? java.util.Optional.of(operands().get(1 + i)) : java.util.Optional.empty();
        }
        
        public java.util.Optional<Integer> noop_with_empty_axes() {
            Integer noop_with_empty_axes = Attribute.noop_with_empty_axes.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(noop_with_empty_axes);
        }
        
        public java.util.Optional<Integer> keepdims() {
            Integer keepdims = Attribute.keepdims.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(keepdims);
        }
        
    }
    
    public static ReduceMax ReduceMax(TypeElement resultType, Value data, java.util.Optional<Value> axes, java.util.Optional<Integer> noop_with_empty_axes, java.util.Optional<Integer> keepdims) {
        return new ReduceMax(resultType, data, axes, noop_with_empty_axes, keepdims);
    }

    @OpFactory.OpDeclaration(ReduceMean.NAME)
    public static final class ReduceMean extends OnnxOp {
        public static final String NAME = "ReduceMean";
        
        public enum Attribute implements OnnxAttribute {
            noop_with_empty_axes(Integer.class, true, null),
            keepdims(Integer.class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<uint32>, tensor<uint64>, tensor<int32>, tensor<int64>, tensor<float16>, tensor<float>, tensor<double>, tensor<bfloat16>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            data(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            axes(null /* @@@ tensor<int64> */, Quantifier.OPTIONAL),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            reduced(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public ReduceMean(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        ReduceMean(ReduceMean that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public ReduceMean transform(CopyContext cc, OpTransformer ot) {
            return new ReduceMean(this, cc);
        }
        
        ReduceMean(TypeElement resultType, Value data, java.util.Optional<Value> axes, java.util.Optional<Integer> noop_with_empty_axes, java.util.Optional<Integer> keepdims) {
            super(SCHEMA, resultType, Set.of(), List.of(data, axes), List.of(noop_with_empty_axes, keepdims));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(data(), axes()));
        }
        
        public Value data() {
            return operands().get(0);
        }
        
        public java.util.Optional<Value> axes() {
            int i = optionalInputArguments.indexOf(InputParameter.axes);
            return i != -1 ? java.util.Optional.of(operands().get(1 + i)) : java.util.Optional.empty();
        }
        
        public java.util.Optional<Integer> noop_with_empty_axes() {
            Integer noop_with_empty_axes = Attribute.noop_with_empty_axes.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(noop_with_empty_axes);
        }
        
        public java.util.Optional<Integer> keepdims() {
            Integer keepdims = Attribute.keepdims.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(keepdims);
        }
        
    }
    
    public static ReduceMean ReduceMean(TypeElement resultType, Value data, java.util.Optional<Value> axes, java.util.Optional<Integer> noop_with_empty_axes, java.util.Optional<Integer> keepdims) {
        return new ReduceMean(resultType, data, axes, noop_with_empty_axes, keepdims);
    }

    @OpFactory.OpDeclaration(ReduceMin.NAME)
    public static final class ReduceMin extends OnnxOp {
        public static final String NAME = "ReduceMin";
        
        public enum Attribute implements OnnxAttribute {
            noop_with_empty_axes(Integer.class, true, null),
            keepdims(Integer.class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<uint32>, tensor<uint64>, tensor<int32>, tensor<int64>, tensor<float16>, tensor<float>, tensor<double>, tensor<bfloat16>, tensor<uint8>, tensor<int8>, tensor<bool>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            data(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            axes(null /* @@@ tensor<int64> */, Quantifier.OPTIONAL),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            reduced(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public ReduceMin(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        ReduceMin(ReduceMin that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public ReduceMin transform(CopyContext cc, OpTransformer ot) {
            return new ReduceMin(this, cc);
        }
        
        ReduceMin(TypeElement resultType, Value data, java.util.Optional<Value> axes, java.util.Optional<Integer> noop_with_empty_axes, java.util.Optional<Integer> keepdims) {
            super(SCHEMA, resultType, Set.of(), List.of(data, axes), List.of(noop_with_empty_axes, keepdims));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(data(), axes()));
        }
        
        public Value data() {
            return operands().get(0);
        }
        
        public java.util.Optional<Value> axes() {
            int i = optionalInputArguments.indexOf(InputParameter.axes);
            return i != -1 ? java.util.Optional.of(operands().get(1 + i)) : java.util.Optional.empty();
        }
        
        public java.util.Optional<Integer> noop_with_empty_axes() {
            Integer noop_with_empty_axes = Attribute.noop_with_empty_axes.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(noop_with_empty_axes);
        }
        
        public java.util.Optional<Integer> keepdims() {
            Integer keepdims = Attribute.keepdims.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(keepdims);
        }
        
    }
    
    public static ReduceMin ReduceMin(TypeElement resultType, Value data, java.util.Optional<Value> axes, java.util.Optional<Integer> noop_with_empty_axes, java.util.Optional<Integer> keepdims) {
        return new ReduceMin(resultType, data, axes, noop_with_empty_axes, keepdims);
    }

    @OpFactory.OpDeclaration(ReduceProd.NAME)
    public static final class ReduceProd extends OnnxOp {
        public static final String NAME = "ReduceProd";
        
        public enum Attribute implements OnnxAttribute {
            noop_with_empty_axes(Integer.class, true, null),
            keepdims(Integer.class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<uint32>, tensor<uint64>, tensor<int32>, tensor<int64>, tensor<float16>, tensor<float>, tensor<double>, tensor<bfloat16>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            data(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            axes(null /* @@@ tensor<int64> */, Quantifier.OPTIONAL),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            reduced(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public ReduceProd(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        ReduceProd(ReduceProd that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public ReduceProd transform(CopyContext cc, OpTransformer ot) {
            return new ReduceProd(this, cc);
        }
        
        ReduceProd(TypeElement resultType, Value data, java.util.Optional<Value> axes, java.util.Optional<Integer> noop_with_empty_axes, java.util.Optional<Integer> keepdims) {
            super(SCHEMA, resultType, Set.of(), List.of(data, axes), List.of(noop_with_empty_axes, keepdims));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(data(), axes()));
        }
        
        public Value data() {
            return operands().get(0);
        }
        
        public java.util.Optional<Value> axes() {
            int i = optionalInputArguments.indexOf(InputParameter.axes);
            return i != -1 ? java.util.Optional.of(operands().get(1 + i)) : java.util.Optional.empty();
        }
        
        public java.util.Optional<Integer> noop_with_empty_axes() {
            Integer noop_with_empty_axes = Attribute.noop_with_empty_axes.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(noop_with_empty_axes);
        }
        
        public java.util.Optional<Integer> keepdims() {
            Integer keepdims = Attribute.keepdims.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(keepdims);
        }
        
    }
    
    public static ReduceProd ReduceProd(TypeElement resultType, Value data, java.util.Optional<Value> axes, java.util.Optional<Integer> noop_with_empty_axes, java.util.Optional<Integer> keepdims) {
        return new ReduceProd(resultType, data, axes, noop_with_empty_axes, keepdims);
    }

    @OpFactory.OpDeclaration(ReduceSum.NAME)
    public static final class ReduceSum extends OnnxOp {
        public static final String NAME = "ReduceSum";
        
        public enum Attribute implements OnnxAttribute {
            noop_with_empty_axes(Integer.class, true, null),
            keepdims(Integer.class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<uint32>, tensor<uint64>, tensor<int32>, tensor<int64>, tensor<float16>, tensor<float>, tensor<double>, tensor<bfloat16>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            data(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            axes(null /* @@@ tensor<int64> */, Quantifier.OPTIONAL),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            reduced(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public ReduceSum(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        ReduceSum(ReduceSum that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public ReduceSum transform(CopyContext cc, OpTransformer ot) {
            return new ReduceSum(this, cc);
        }
        
        ReduceSum(TypeElement resultType, Value data, java.util.Optional<Value> axes, java.util.Optional<Integer> noop_with_empty_axes, java.util.Optional<Integer> keepdims) {
            super(SCHEMA, resultType, Set.of(), List.of(data, axes), List.of(noop_with_empty_axes, keepdims));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(data(), axes()));
        }
        
        public Value data() {
            return operands().get(0);
        }
        
        public java.util.Optional<Value> axes() {
            int i = optionalInputArguments.indexOf(InputParameter.axes);
            return i != -1 ? java.util.Optional.of(operands().get(1 + i)) : java.util.Optional.empty();
        }
        
        public java.util.Optional<Integer> noop_with_empty_axes() {
            Integer noop_with_empty_axes = Attribute.noop_with_empty_axes.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(noop_with_empty_axes);
        }
        
        public java.util.Optional<Integer> keepdims() {
            Integer keepdims = Attribute.keepdims.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(keepdims);
        }
        
    }
    
    public static ReduceSum ReduceSum(TypeElement resultType, Value data, java.util.Optional<Value> axes, java.util.Optional<Integer> noop_with_empty_axes, java.util.Optional<Integer> keepdims) {
        return new ReduceSum(resultType, data, axes, noop_with_empty_axes, keepdims);
    }

    @OpFactory.OpDeclaration(ReduceSumSquare.NAME)
    public static final class ReduceSumSquare extends OnnxOp {
        public static final String NAME = "ReduceSumSquare";
        
        public enum Attribute implements OnnxAttribute {
            noop_with_empty_axes(Integer.class, true, null),
            keepdims(Integer.class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<uint32>, tensor<uint64>, tensor<int32>, tensor<int64>, tensor<float16>, tensor<float>, tensor<double>, tensor<bfloat16>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            data(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            axes(null /* @@@ tensor<int64> */, Quantifier.OPTIONAL),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            reduced(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public ReduceSumSquare(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        ReduceSumSquare(ReduceSumSquare that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public ReduceSumSquare transform(CopyContext cc, OpTransformer ot) {
            return new ReduceSumSquare(this, cc);
        }
        
        ReduceSumSquare(TypeElement resultType, Value data, java.util.Optional<Value> axes, java.util.Optional<Integer> noop_with_empty_axes, java.util.Optional<Integer> keepdims) {
            super(SCHEMA, resultType, Set.of(), List.of(data, axes), List.of(noop_with_empty_axes, keepdims));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(data(), axes()));
        }
        
        public Value data() {
            return operands().get(0);
        }
        
        public java.util.Optional<Value> axes() {
            int i = optionalInputArguments.indexOf(InputParameter.axes);
            return i != -1 ? java.util.Optional.of(operands().get(1 + i)) : java.util.Optional.empty();
        }
        
        public java.util.Optional<Integer> noop_with_empty_axes() {
            Integer noop_with_empty_axes = Attribute.noop_with_empty_axes.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(noop_with_empty_axes);
        }
        
        public java.util.Optional<Integer> keepdims() {
            Integer keepdims = Attribute.keepdims.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(keepdims);
        }
        
    }
    
    public static ReduceSumSquare ReduceSumSquare(TypeElement resultType, Value data, java.util.Optional<Value> axes, java.util.Optional<Integer> noop_with_empty_axes, java.util.Optional<Integer> keepdims) {
        return new ReduceSumSquare(resultType, data, axes, noop_with_empty_axes, keepdims);
    }

    @OpFactory.OpDeclaration(RegexFullMatch.NAME)
    public static final class RegexFullMatch extends OnnxOp {
        public static final String NAME = "RegexFullMatch";
        
        public enum Attribute implements OnnxAttribute {
            pattern(String.class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T1(new OnnxType.TypeVariable("T1", List.of(/* @@@ [tensor<string>] */))),
            T2(new OnnxType.TypeVariable("T2", List.of(/* @@@ [tensor<bool>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public RegexFullMatch(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        RegexFullMatch(RegexFullMatch that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public RegexFullMatch transform(CopyContext cc, OpTransformer ot) {
            return new RegexFullMatch(this, cc);
        }
        
        RegexFullMatch(TypeElement resultType, Value X, java.util.Optional<String> pattern) {
            super(SCHEMA, resultType, Set.of(), List.of(X), List.of(pattern));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X()));
        }
        
        public Value X() {
            return operands().get(0);
        }
        
        public java.util.Optional<String> pattern() {
            String pattern = Attribute.pattern.access(String.class, onnxAttributes);
            return java.util.Optional.ofNullable(pattern);
        }
        
    }
    
    public static RegexFullMatch RegexFullMatch(TypeElement resultType, Value X, java.util.Optional<String> pattern) {
        return new RegexFullMatch(resultType, X, pattern);
    }

    @OpFactory.OpDeclaration(Relu.NAME)
    public static final class Relu extends OnnxOp {
        public static final String NAME = "Relu";
        
        public enum Attribute implements OnnxAttribute.None { }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<float>, tensor<int32>, tensor<int8>, tensor<int16>, tensor<int64>, tensor<float16>, tensor<double>, tensor<bfloat16>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public Relu(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        Relu(Relu that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public Relu transform(CopyContext cc, OpTransformer ot) {
            return new Relu(this, cc);
        }
        
        Relu(TypeElement resultType, Value X) {
            super(SCHEMA, resultType, Set.of(), List.of(X), List.of());
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X()));
        }
        
        public Value X() {
            return operands().get(0);
        }
        
    }
    
    public static Relu Relu(TypeElement resultType, Value X) {
        return new Relu(resultType, X);
    }

    @OpFactory.OpDeclaration(Reshape.NAME)
    public static final class Reshape extends OnnxOp {
        public static final String NAME = "Reshape";
        
        public enum Attribute implements OnnxAttribute {
            allowzero(Integer.class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<uint8>, tensor<uint16>, tensor<uint32>, tensor<uint64>, tensor<int8>, tensor<int16>, tensor<int32>, tensor<int64>, tensor<bfloat16>, tensor<float16>, tensor<float>, tensor<double>, tensor<string>, tensor<bool>, tensor<complex64>, tensor<complex128>, tensor<float8e4m3fn>, tensor<float8e4m3fnuz>, tensor<float8e5m2>, tensor<float8e5m2fnuz>, tensor<uint4>, tensor<int4>, tensor<float4e2m1>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            data(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            shape(null /* @@@ tensor<int64> */, Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            reshaped(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public Reshape(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        Reshape(Reshape that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public Reshape transform(CopyContext cc, OpTransformer ot) {
            return new Reshape(this, cc);
        }
        
        Reshape(TypeElement resultType, Value data, Value shape, java.util.Optional<Integer> allowzero) {
            super(SCHEMA, resultType, Set.of(), List.of(data, shape), List.of(allowzero));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(data(), shape()));
        }
        
        public Value data() {
            return operands().get(0);
        }
        
        public Value shape() {
            return operands().get(1);
        }
        
        public java.util.Optional<Integer> allowzero() {
            Integer allowzero = Attribute.allowzero.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(allowzero);
        }
        
    }
    
    public static Reshape Reshape(TypeElement resultType, Value data, Value shape, java.util.Optional<Integer> allowzero) {
        return new Reshape(resultType, data, shape, allowzero);
    }

    @OpFactory.OpDeclaration(Resize.NAME)
    public static final class Resize extends OnnxOp {
        public static final String NAME = "Resize";
        
        public enum Attribute implements OnnxAttribute {
            mode(String.class, true, null),
            extrapolation_value(Float.class, true, null),
            nearest_mode(String.class, true, null),
            antialias(Integer.class, true, null),
            cubic_coeff_a(Float.class, true, null),
            axes(int[].class, true, null),
            coordinate_transformation_mode(String.class, true, null),
            keep_aspect_ratio_policy(String.class, true, null),
            exclude_outside(Integer.class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T1(new OnnxType.TypeVariable("T1", List.of(/* @@@ [tensor<uint8>, tensor<uint16>, tensor<uint32>, tensor<uint64>, tensor<int8>, tensor<int16>, tensor<int32>, tensor<int64>, tensor<bfloat16>, tensor<float16>, tensor<float>, tensor<double>, tensor<string>, tensor<bool>, tensor<complex64>, tensor<complex128>] */))),
            T2(new OnnxType.TypeVariable("T2", List.of(/* @@@ [tensor<float16>, tensor<float>, tensor<double>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            roi(TypeConstraint.T2.typeVariable(), Quantifier.OPTIONAL),
            scales(null /* @@@ tensor<float> */, Quantifier.OPTIONAL),
            sizes(null /* @@@ tensor<int64> */, Quantifier.OPTIONAL),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public Resize(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        Resize(Resize that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public Resize transform(CopyContext cc, OpTransformer ot) {
            return new Resize(this, cc);
        }
        
        Resize(TypeElement resultType, Value X, java.util.Optional<Value> roi, java.util.Optional<Value> scales, java.util.Optional<Value> sizes, java.util.Optional<String> mode, java.util.Optional<Float> extrapolation_value, java.util.Optional<String> nearest_mode, java.util.Optional<Integer> antialias, java.util.Optional<Float> cubic_coeff_a, java.util.Optional<int[]> axes, java.util.Optional<String> coordinate_transformation_mode, java.util.Optional<String> keep_aspect_ratio_policy, java.util.Optional<Integer> exclude_outside) {
            super(SCHEMA, resultType, Set.of(), List.of(X, roi, scales, sizes), List.of(mode, extrapolation_value, nearest_mode, antialias, cubic_coeff_a, axes, coordinate_transformation_mode, keep_aspect_ratio_policy, exclude_outside));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X(), roi(), scales(), sizes()));
        }
        
        public Value X() {
            return operands().get(0);
        }
        
        public java.util.Optional<Value> roi() {
            int i = optionalInputArguments.indexOf(InputParameter.roi);
            return i != -1 ? java.util.Optional.of(operands().get(1 + i)) : java.util.Optional.empty();
        }
        
        public java.util.Optional<Value> scales() {
            int i = optionalInputArguments.indexOf(InputParameter.scales);
            return i != -1 ? java.util.Optional.of(operands().get(1 + i)) : java.util.Optional.empty();
        }
        
        public java.util.Optional<Value> sizes() {
            int i = optionalInputArguments.indexOf(InputParameter.sizes);
            return i != -1 ? java.util.Optional.of(operands().get(1 + i)) : java.util.Optional.empty();
        }
        
        public java.util.Optional<String> mode() {
            String mode = Attribute.mode.access(String.class, onnxAttributes);
            return java.util.Optional.ofNullable(mode);
        }
        
        public java.util.Optional<Float> extrapolation_value() {
            Float extrapolation_value = Attribute.extrapolation_value.access(Float.class, onnxAttributes);
            return java.util.Optional.ofNullable(extrapolation_value);
        }
        
        public java.util.Optional<String> nearest_mode() {
            String nearest_mode = Attribute.nearest_mode.access(String.class, onnxAttributes);
            return java.util.Optional.ofNullable(nearest_mode);
        }
        
        public java.util.Optional<Integer> antialias() {
            Integer antialias = Attribute.antialias.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(antialias);
        }
        
        public java.util.Optional<Float> cubic_coeff_a() {
            Float cubic_coeff_a = Attribute.cubic_coeff_a.access(Float.class, onnxAttributes);
            return java.util.Optional.ofNullable(cubic_coeff_a);
        }
        
        public java.util.Optional<int[]> axes() {
            int[] axes = Attribute.axes.access(int[].class, onnxAttributes);
            return java.util.Optional.ofNullable(axes).map(int[]::clone);
        }
        
        public java.util.Optional<String> coordinate_transformation_mode() {
            String coordinate_transformation_mode = Attribute.coordinate_transformation_mode.access(String.class, onnxAttributes);
            return java.util.Optional.ofNullable(coordinate_transformation_mode);
        }
        
        public java.util.Optional<String> keep_aspect_ratio_policy() {
            String keep_aspect_ratio_policy = Attribute.keep_aspect_ratio_policy.access(String.class, onnxAttributes);
            return java.util.Optional.ofNullable(keep_aspect_ratio_policy);
        }
        
        public java.util.Optional<Integer> exclude_outside() {
            Integer exclude_outside = Attribute.exclude_outside.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(exclude_outside);
        }
        
    }
    
    public static Resize Resize(TypeElement resultType, Value X, java.util.Optional<Value> roi, java.util.Optional<Value> scales, java.util.Optional<Value> sizes, java.util.Optional<String> mode, java.util.Optional<Float> extrapolation_value, java.util.Optional<String> nearest_mode, java.util.Optional<Integer> antialias, java.util.Optional<Float> cubic_coeff_a, java.util.Optional<int[]> axes, java.util.Optional<String> coordinate_transformation_mode, java.util.Optional<String> keep_aspect_ratio_policy, java.util.Optional<Integer> exclude_outside) {
        return new Resize(resultType, X, roi, scales, sizes, mode, extrapolation_value, nearest_mode, antialias, cubic_coeff_a, axes, coordinate_transformation_mode, keep_aspect_ratio_policy, exclude_outside);
    }

    @OpFactory.OpDeclaration(ReverseSequence.NAME)
    public static final class ReverseSequence extends OnnxOp {
        public static final String NAME = "ReverseSequence";
        
        public enum Attribute implements OnnxAttribute {
            time_axis(Integer.class, true, null),
            batch_axis(Integer.class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<uint8>, tensor<uint16>, tensor<uint32>, tensor<uint64>, tensor<int8>, tensor<int16>, tensor<int32>, tensor<int64>, tensor<float16>, tensor<float>, tensor<double>, tensor<string>, tensor<bool>, tensor<complex64>, tensor<complex128>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            input(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            sequence_lens(null /* @@@ tensor<int64> */, Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public ReverseSequence(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        ReverseSequence(ReverseSequence that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public ReverseSequence transform(CopyContext cc, OpTransformer ot) {
            return new ReverseSequence(this, cc);
        }
        
        ReverseSequence(TypeElement resultType, Value input, Value sequence_lens, java.util.Optional<Integer> time_axis, java.util.Optional<Integer> batch_axis) {
            super(SCHEMA, resultType, Set.of(), List.of(input, sequence_lens), List.of(time_axis, batch_axis));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(input(), sequence_lens()));
        }
        
        public Value input() {
            return operands().get(0);
        }
        
        public Value sequence_lens() {
            return operands().get(1);
        }
        
        public java.util.Optional<Integer> time_axis() {
            Integer time_axis = Attribute.time_axis.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(time_axis);
        }
        
        public java.util.Optional<Integer> batch_axis() {
            Integer batch_axis = Attribute.batch_axis.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(batch_axis);
        }
        
    }
    
    public static ReverseSequence ReverseSequence(TypeElement resultType, Value input, Value sequence_lens, java.util.Optional<Integer> time_axis, java.util.Optional<Integer> batch_axis) {
        return new ReverseSequence(resultType, input, sequence_lens, time_axis, batch_axis);
    }

    @OpFactory.OpDeclaration(RoiAlign.NAME)
    public static final class RoiAlign extends OnnxOp {
        public static final String NAME = "RoiAlign";
        
        public enum Attribute implements OnnxAttribute {
            mode(String.class, true, null),
            output_width(Integer.class, true, null),
            spatial_scale(Float.class, true, null),
            coordinate_transformation_mode(String.class, true, null),
            sampling_ratio(Integer.class, true, null),
            output_height(Integer.class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T1(new OnnxType.TypeVariable("T1", List.of(/* @@@ [tensor<bfloat16>, tensor<float16>, tensor<float>, tensor<double>] */))),
            T2(new OnnxType.TypeVariable("T2", List.of(/* @@@ [tensor<int64>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            rois(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            batch_indices(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public RoiAlign(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        RoiAlign(RoiAlign that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public RoiAlign transform(CopyContext cc, OpTransformer ot) {
            return new RoiAlign(this, cc);
        }
        
        RoiAlign(TypeElement resultType, Value X, Value rois, Value batch_indices, java.util.Optional<String> mode, java.util.Optional<Integer> output_width, java.util.Optional<Float> spatial_scale, java.util.Optional<String> coordinate_transformation_mode, java.util.Optional<Integer> sampling_ratio, java.util.Optional<Integer> output_height) {
            super(SCHEMA, resultType, Set.of(), List.of(X, rois, batch_indices), List.of(mode, output_width, spatial_scale, coordinate_transformation_mode, sampling_ratio, output_height));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X(), rois(), batch_indices()));
        }
        
        public Value X() {
            return operands().get(0);
        }
        
        public Value rois() {
            return operands().get(1);
        }
        
        public Value batch_indices() {
            return operands().get(2);
        }
        
        public java.util.Optional<String> mode() {
            String mode = Attribute.mode.access(String.class, onnxAttributes);
            return java.util.Optional.ofNullable(mode);
        }
        
        public java.util.Optional<Integer> output_width() {
            Integer output_width = Attribute.output_width.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(output_width);
        }
        
        public java.util.Optional<Float> spatial_scale() {
            Float spatial_scale = Attribute.spatial_scale.access(Float.class, onnxAttributes);
            return java.util.Optional.ofNullable(spatial_scale);
        }
        
        public java.util.Optional<String> coordinate_transformation_mode() {
            String coordinate_transformation_mode = Attribute.coordinate_transformation_mode.access(String.class, onnxAttributes);
            return java.util.Optional.ofNullable(coordinate_transformation_mode);
        }
        
        public java.util.Optional<Integer> sampling_ratio() {
            Integer sampling_ratio = Attribute.sampling_ratio.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(sampling_ratio);
        }
        
        public java.util.Optional<Integer> output_height() {
            Integer output_height = Attribute.output_height.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(output_height);
        }
        
    }
    
    public static RoiAlign RoiAlign(TypeElement resultType, Value X, Value rois, Value batch_indices, java.util.Optional<String> mode, java.util.Optional<Integer> output_width, java.util.Optional<Float> spatial_scale, java.util.Optional<String> coordinate_transformation_mode, java.util.Optional<Integer> sampling_ratio, java.util.Optional<Integer> output_height) {
        return new RoiAlign(resultType, X, rois, batch_indices, mode, output_width, spatial_scale, coordinate_transformation_mode, sampling_ratio, output_height);
    }

    @OpFactory.OpDeclaration(Round.NAME)
    public static final class Round extends OnnxOp {
        public static final String NAME = "Round";
        
        public enum Attribute implements OnnxAttribute.None { }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<bfloat16>, tensor<float16>, tensor<float>, tensor<double>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public Round(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        Round(Round that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public Round transform(CopyContext cc, OpTransformer ot) {
            return new Round(this, cc);
        }
        
        Round(TypeElement resultType, Value X) {
            super(SCHEMA, resultType, Set.of(), List.of(X), List.of());
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X()));
        }
        
        public Value X() {
            return operands().get(0);
        }
        
    }
    
    public static Round Round(TypeElement resultType, Value X) {
        return new Round(resultType, X);
    }

    @OpFactory.OpDeclaration(STFT.NAME)
    public static final class STFT extends OnnxOp {
        public static final String NAME = "STFT";
        
        public enum Attribute implements OnnxAttribute {
            onesided(Integer.class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T1(new OnnxType.TypeVariable("T1", List.of(/* @@@ [tensor<float>, tensor<float16>, tensor<double>, tensor<bfloat16>] */))),
            T2(new OnnxType.TypeVariable("T2", List.of(/* @@@ [tensor<int32>, tensor<int64>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            signal(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            frame_step(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),
            window(TypeConstraint.T1.typeVariable(), Quantifier.OPTIONAL),
            frame_length(TypeConstraint.T2.typeVariable(), Quantifier.OPTIONAL),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public STFT(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        STFT(STFT that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public STFT transform(CopyContext cc, OpTransformer ot) {
            return new STFT(this, cc);
        }
        
        STFT(TypeElement resultType, Value signal, Value frame_step, java.util.Optional<Value> window, java.util.Optional<Value> frame_length, java.util.Optional<Integer> onesided) {
            super(SCHEMA, resultType, Set.of(), List.of(signal, frame_step, window, frame_length), List.of(onesided));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(signal(), frame_step(), window(), frame_length()));
        }
        
        public Value signal() {
            return operands().get(0);
        }
        
        public Value frame_step() {
            return operands().get(1);
        }
        
        public java.util.Optional<Value> window() {
            int i = optionalInputArguments.indexOf(InputParameter.window);
            return i != -1 ? java.util.Optional.of(operands().get(2 + i)) : java.util.Optional.empty();
        }
        
        public java.util.Optional<Value> frame_length() {
            int i = optionalInputArguments.indexOf(InputParameter.frame_length);
            return i != -1 ? java.util.Optional.of(operands().get(2 + i)) : java.util.Optional.empty();
        }
        
        public java.util.Optional<Integer> onesided() {
            Integer onesided = Attribute.onesided.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(onesided);
        }
        
    }
    
    public static STFT STFT(TypeElement resultType, Value signal, Value frame_step, java.util.Optional<Value> window, java.util.Optional<Value> frame_length, java.util.Optional<Integer> onesided) {
        return new STFT(resultType, signal, frame_step, window, frame_length, onesided);
    }

    @OpFactory.OpDeclaration(SVMClassifier.NAME)
    public static final class SVMClassifier extends OnnxOp {
        public static final String NAME = "SVMClassifier";
        
        public enum Attribute implements OnnxAttribute {
            prob_b(float[].class, true, null),
            kernel_params(float[].class, true, null),
            kernel_type(String.class, true, null),
            classlabels_ints(int[].class, true, null),
            post_transform(String.class, true, null),
            rho(float[].class, true, null),
            coefficients(float[].class, true, null),
            support_vectors(float[].class, true, null),
            vectors_per_class(int[].class, true, null),
            prob_a(float[].class, true, null),
            classlabels_strings(String[].class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T1(new OnnxType.TypeVariable("T1", List.of(/* @@@ [tensor<float>, tensor<double>, tensor<int64>, tensor<int32>] */))),
            T2(new OnnxType.TypeVariable("T2", List.of(/* @@@ [tensor<string>, tensor<int64>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),
            Z(null /* @@@ tensor<float> */, Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public SVMClassifier(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        SVMClassifier(SVMClassifier that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public SVMClassifier transform(CopyContext cc, OpTransformer ot) {
            return new SVMClassifier(this, cc);
        }
        
        SVMClassifier(TypeElement resultType, Value X, java.util.Optional<float[]> prob_b, java.util.Optional<float[]> kernel_params, java.util.Optional<String> kernel_type, java.util.Optional<int[]> classlabels_ints, java.util.Optional<String> post_transform, java.util.Optional<float[]> rho, java.util.Optional<float[]> coefficients, java.util.Optional<float[]> support_vectors, java.util.Optional<int[]> vectors_per_class, java.util.Optional<float[]> prob_a, java.util.Optional<String[]> classlabels_strings) {
            super(SCHEMA, resultType, Set.of(), List.of(X), List.of(prob_b, kernel_params, kernel_type, classlabels_ints, post_transform, rho, coefficients, support_vectors, vectors_per_class, prob_a, classlabels_strings));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X()));
        }
        
        public Value X() {
            return operands().get(0);
        }
        
        public java.util.Optional<float[]> prob_b() {
            float[] prob_b = Attribute.prob_b.access(float[].class, onnxAttributes);
            return java.util.Optional.ofNullable(prob_b).map(float[]::clone);
        }
        
        public java.util.Optional<float[]> kernel_params() {
            float[] kernel_params = Attribute.kernel_params.access(float[].class, onnxAttributes);
            return java.util.Optional.ofNullable(kernel_params).map(float[]::clone);
        }
        
        public java.util.Optional<String> kernel_type() {
            String kernel_type = Attribute.kernel_type.access(String.class, onnxAttributes);
            return java.util.Optional.ofNullable(kernel_type);
        }
        
        public java.util.Optional<int[]> classlabels_ints() {
            int[] classlabels_ints = Attribute.classlabels_ints.access(int[].class, onnxAttributes);
            return java.util.Optional.ofNullable(classlabels_ints).map(int[]::clone);
        }
        
        public java.util.Optional<String> post_transform() {
            String post_transform = Attribute.post_transform.access(String.class, onnxAttributes);
            return java.util.Optional.ofNullable(post_transform);
        }
        
        public java.util.Optional<float[]> rho() {
            float[] rho = Attribute.rho.access(float[].class, onnxAttributes);
            return java.util.Optional.ofNullable(rho).map(float[]::clone);
        }
        
        public java.util.Optional<float[]> coefficients() {
            float[] coefficients = Attribute.coefficients.access(float[].class, onnxAttributes);
            return java.util.Optional.ofNullable(coefficients).map(float[]::clone);
        }
        
        public java.util.Optional<float[]> support_vectors() {
            float[] support_vectors = Attribute.support_vectors.access(float[].class, onnxAttributes);
            return java.util.Optional.ofNullable(support_vectors).map(float[]::clone);
        }
        
        public java.util.Optional<int[]> vectors_per_class() {
            int[] vectors_per_class = Attribute.vectors_per_class.access(int[].class, onnxAttributes);
            return java.util.Optional.ofNullable(vectors_per_class).map(int[]::clone);
        }
        
        public java.util.Optional<float[]> prob_a() {
            float[] prob_a = Attribute.prob_a.access(float[].class, onnxAttributes);
            return java.util.Optional.ofNullable(prob_a).map(float[]::clone);
        }
        
        public java.util.Optional<String[]> classlabels_strings() {
            String[] classlabels_strings = Attribute.classlabels_strings.access(String[].class, onnxAttributes);
            return java.util.Optional.ofNullable(classlabels_strings).map(String[]::clone);
        }
        
    }
    
    public static SVMClassifier SVMClassifier(TypeElement resultType, Value X, java.util.Optional<float[]> prob_b, java.util.Optional<float[]> kernel_params, java.util.Optional<String> kernel_type, java.util.Optional<int[]> classlabels_ints, java.util.Optional<String> post_transform, java.util.Optional<float[]> rho, java.util.Optional<float[]> coefficients, java.util.Optional<float[]> support_vectors, java.util.Optional<int[]> vectors_per_class, java.util.Optional<float[]> prob_a, java.util.Optional<String[]> classlabels_strings) {
        return new SVMClassifier(resultType, X, prob_b, kernel_params, kernel_type, classlabels_ints, post_transform, rho, coefficients, support_vectors, vectors_per_class, prob_a, classlabels_strings);
    }

    @OpFactory.OpDeclaration(SVMRegressor.NAME)
    public static final class SVMRegressor extends OnnxOp {
        public static final String NAME = "SVMRegressor";
        
        public enum Attribute implements OnnxAttribute {
            kernel_type(String.class, true, null),
            kernel_params(float[].class, true, null),
            n_supports(Integer.class, true, null),
            rho(float[].class, true, null),
            post_transform(String.class, true, null),
            coefficients(float[].class, true, null),
            support_vectors(float[].class, true, null),
            one_class(Integer.class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<float>, tensor<double>, tensor<int64>, tensor<int32>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            Y(null /* @@@ tensor<float> */, Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public SVMRegressor(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        SVMRegressor(SVMRegressor that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public SVMRegressor transform(CopyContext cc, OpTransformer ot) {
            return new SVMRegressor(this, cc);
        }
        
        SVMRegressor(TypeElement resultType, Value X, java.util.Optional<String> kernel_type, java.util.Optional<float[]> kernel_params, java.util.Optional<Integer> n_supports, java.util.Optional<float[]> rho, java.util.Optional<String> post_transform, java.util.Optional<float[]> coefficients, java.util.Optional<float[]> support_vectors, java.util.Optional<Integer> one_class) {
            super(SCHEMA, resultType, Set.of(), List.of(X), List.of(kernel_type, kernel_params, n_supports, rho, post_transform, coefficients, support_vectors, one_class));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X()));
        }
        
        public Value X() {
            return operands().get(0);
        }
        
        public java.util.Optional<String> kernel_type() {
            String kernel_type = Attribute.kernel_type.access(String.class, onnxAttributes);
            return java.util.Optional.ofNullable(kernel_type);
        }
        
        public java.util.Optional<float[]> kernel_params() {
            float[] kernel_params = Attribute.kernel_params.access(float[].class, onnxAttributes);
            return java.util.Optional.ofNullable(kernel_params).map(float[]::clone);
        }
        
        public java.util.Optional<Integer> n_supports() {
            Integer n_supports = Attribute.n_supports.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(n_supports);
        }
        
        public java.util.Optional<float[]> rho() {
            float[] rho = Attribute.rho.access(float[].class, onnxAttributes);
            return java.util.Optional.ofNullable(rho).map(float[]::clone);
        }
        
        public java.util.Optional<String> post_transform() {
            String post_transform = Attribute.post_transform.access(String.class, onnxAttributes);
            return java.util.Optional.ofNullable(post_transform);
        }
        
        public java.util.Optional<float[]> coefficients() {
            float[] coefficients = Attribute.coefficients.access(float[].class, onnxAttributes);
            return java.util.Optional.ofNullable(coefficients).map(float[]::clone);
        }
        
        public java.util.Optional<float[]> support_vectors() {
            float[] support_vectors = Attribute.support_vectors.access(float[].class, onnxAttributes);
            return java.util.Optional.ofNullable(support_vectors).map(float[]::clone);
        }
        
        public java.util.Optional<Integer> one_class() {
            Integer one_class = Attribute.one_class.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(one_class);
        }
        
    }
    
    public static SVMRegressor SVMRegressor(TypeElement resultType, Value X, java.util.Optional<String> kernel_type, java.util.Optional<float[]> kernel_params, java.util.Optional<Integer> n_supports, java.util.Optional<float[]> rho, java.util.Optional<String> post_transform, java.util.Optional<float[]> coefficients, java.util.Optional<float[]> support_vectors, java.util.Optional<Integer> one_class) {
        return new SVMRegressor(resultType, X, kernel_type, kernel_params, n_supports, rho, post_transform, coefficients, support_vectors, one_class);
    }

    @OpFactory.OpDeclaration(Scaler.NAME)
    public static final class Scaler extends OnnxOp {
        public static final String NAME = "Scaler";
        
        public enum Attribute implements OnnxAttribute {
            offset(float[].class, true, null),
            scale(float[].class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<float>, tensor<double>, tensor<int64>, tensor<int32>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            Y(null /* @@@ tensor<float> */, Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public Scaler(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        Scaler(Scaler that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public Scaler transform(CopyContext cc, OpTransformer ot) {
            return new Scaler(this, cc);
        }
        
        Scaler(TypeElement resultType, Value X, java.util.Optional<float[]> offset, java.util.Optional<float[]> scale) {
            super(SCHEMA, resultType, Set.of(), List.of(X), List.of(offset, scale));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X()));
        }
        
        public Value X() {
            return operands().get(0);
        }
        
        public java.util.Optional<float[]> offset() {
            float[] offset = Attribute.offset.access(float[].class, onnxAttributes);
            return java.util.Optional.ofNullable(offset).map(float[]::clone);
        }
        
        public java.util.Optional<float[]> scale() {
            float[] scale = Attribute.scale.access(float[].class, onnxAttributes);
            return java.util.Optional.ofNullable(scale).map(float[]::clone);
        }
        
    }
    
    public static Scaler Scaler(TypeElement resultType, Value X, java.util.Optional<float[]> offset, java.util.Optional<float[]> scale) {
        return new Scaler(resultType, X, offset, scale);
    }

    @OpFactory.OpDeclaration(Scatter.NAME)
    public static final class Scatter extends OnnxOp {
        public static final String NAME = "Scatter";
        
        public enum Attribute implements OnnxAttribute {
            axis(Integer.class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<uint8>, tensor<uint16>, tensor<uint32>, tensor<uint64>, tensor<int8>, tensor<int16>, tensor<int32>, tensor<int64>, tensor<float16>, tensor<float>, tensor<double>, tensor<string>, tensor<bool>, tensor<complex64>, tensor<complex128>] */))),
            Tind(new OnnxType.TypeVariable("Tind", List.of(/* @@@ [tensor<int32>, tensor<int64>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            data(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            indices(TypeConstraint.Tind.typeVariable(), Quantifier.REQUIRED),
            updates(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public Scatter(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        Scatter(Scatter that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public Scatter transform(CopyContext cc, OpTransformer ot) {
            return new Scatter(this, cc);
        }
        
        Scatter(TypeElement resultType, Value data, Value indices, Value updates, java.util.Optional<Integer> axis) {
            super(SCHEMA, resultType, Set.of(), List.of(data, indices, updates), List.of(axis));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(data(), indices(), updates()));
        }
        
        public Value data() {
            return operands().get(0);
        }
        
        public Value indices() {
            return operands().get(1);
        }
        
        public Value updates() {
            return operands().get(2);
        }
        
        public java.util.Optional<Integer> axis() {
            Integer axis = Attribute.axis.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(axis);
        }
        
    }
    
    public static Scatter Scatter(TypeElement resultType, Value data, Value indices, Value updates, java.util.Optional<Integer> axis) {
        return new Scatter(resultType, data, indices, updates, axis);
    }

    @OpFactory.OpDeclaration(ScatterElements.NAME)
    public static final class ScatterElements extends OnnxOp {
        public static final String NAME = "ScatterElements";
        
        public enum Attribute implements OnnxAttribute {
            reduction(String.class, true, null),
            axis(Integer.class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<uint8>, tensor<uint16>, tensor<uint32>, tensor<uint64>, tensor<int8>, tensor<int16>, tensor<int32>, tensor<int64>, tensor<bfloat16>, tensor<float16>, tensor<float>, tensor<double>, tensor<string>, tensor<bool>, tensor<complex64>, tensor<complex128>] */))),
            Tind(new OnnxType.TypeVariable("Tind", List.of(/* @@@ [tensor<int32>, tensor<int64>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            data(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            indices(TypeConstraint.Tind.typeVariable(), Quantifier.REQUIRED),
            updates(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public ScatterElements(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        ScatterElements(ScatterElements that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public ScatterElements transform(CopyContext cc, OpTransformer ot) {
            return new ScatterElements(this, cc);
        }
        
        ScatterElements(TypeElement resultType, Value data, Value indices, Value updates, java.util.Optional<String> reduction, java.util.Optional<Integer> axis) {
            super(SCHEMA, resultType, Set.of(), List.of(data, indices, updates), List.of(reduction, axis));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(data(), indices(), updates()));
        }
        
        public Value data() {
            return operands().get(0);
        }
        
        public Value indices() {
            return operands().get(1);
        }
        
        public Value updates() {
            return operands().get(2);
        }
        
        public java.util.Optional<String> reduction() {
            String reduction = Attribute.reduction.access(String.class, onnxAttributes);
            return java.util.Optional.ofNullable(reduction);
        }
        
        public java.util.Optional<Integer> axis() {
            Integer axis = Attribute.axis.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(axis);
        }
        
    }
    
    public static ScatterElements ScatterElements(TypeElement resultType, Value data, Value indices, Value updates, java.util.Optional<String> reduction, java.util.Optional<Integer> axis) {
        return new ScatterElements(resultType, data, indices, updates, reduction, axis);
    }

    @OpFactory.OpDeclaration(ScatterND.NAME)
    public static final class ScatterND extends OnnxOp {
        public static final String NAME = "ScatterND";
        
        public enum Attribute implements OnnxAttribute {
            reduction(String.class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<uint8>, tensor<uint16>, tensor<uint32>, tensor<uint64>, tensor<int8>, tensor<int16>, tensor<int32>, tensor<int64>, tensor<bfloat16>, tensor<float16>, tensor<float>, tensor<double>, tensor<string>, tensor<bool>, tensor<complex64>, tensor<complex128>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            data(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            indices(null /* @@@ tensor<int64> */, Quantifier.REQUIRED),
            updates(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public ScatterND(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        ScatterND(ScatterND that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public ScatterND transform(CopyContext cc, OpTransformer ot) {
            return new ScatterND(this, cc);
        }
        
        ScatterND(TypeElement resultType, Value data, Value indices, Value updates, java.util.Optional<String> reduction) {
            super(SCHEMA, resultType, Set.of(), List.of(data, indices, updates), List.of(reduction));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(data(), indices(), updates()));
        }
        
        public Value data() {
            return operands().get(0);
        }
        
        public Value indices() {
            return operands().get(1);
        }
        
        public Value updates() {
            return operands().get(2);
        }
        
        public java.util.Optional<String> reduction() {
            String reduction = Attribute.reduction.access(String.class, onnxAttributes);
            return java.util.Optional.ofNullable(reduction);
        }
        
    }
    
    public static ScatterND ScatterND(TypeElement resultType, Value data, Value indices, Value updates, java.util.Optional<String> reduction) {
        return new ScatterND(resultType, data, indices, updates, reduction);
    }

    @OpFactory.OpDeclaration(Selu.NAME)
    public static final class Selu extends OnnxOp {
        public static final String NAME = "Selu";
        
        public enum Attribute implements OnnxAttribute {
            alpha(Float.class, true, null),
            gamma(Float.class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<bfloat16>, tensor<float16>, tensor<float>, tensor<double>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public Selu(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        Selu(Selu that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public Selu transform(CopyContext cc, OpTransformer ot) {
            return new Selu(this, cc);
        }
        
        Selu(TypeElement resultType, Value X, java.util.Optional<Float> alpha, java.util.Optional<Float> gamma) {
            super(SCHEMA, resultType, Set.of(), List.of(X), List.of(alpha, gamma));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X()));
        }
        
        public Value X() {
            return operands().get(0);
        }
        
        public java.util.Optional<Float> alpha() {
            Float alpha = Attribute.alpha.access(Float.class, onnxAttributes);
            return java.util.Optional.ofNullable(alpha);
        }
        
        public java.util.Optional<Float> gamma() {
            Float gamma = Attribute.gamma.access(Float.class, onnxAttributes);
            return java.util.Optional.ofNullable(gamma);
        }
        
    }
    
    public static Selu Selu(TypeElement resultType, Value X, java.util.Optional<Float> alpha, java.util.Optional<Float> gamma) {
        return new Selu(resultType, X, alpha, gamma);
    }

    @OpFactory.OpDeclaration(SequenceAt.NAME)
    public static final class SequenceAt extends OnnxOp {
        public static final String NAME = "SequenceAt";
        
        public enum Attribute implements OnnxAttribute.None { }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            S(new OnnxType.TypeVariable("S", List.of(/* @@@ [seq<tensor<uint8>>, seq<tensor<uint16>>, seq<tensor<uint32>>, seq<tensor<uint64>>, seq<tensor<int8>>, seq<tensor<int16>>, seq<tensor<int32>>, seq<tensor<int64>>, seq<tensor<float16>>, seq<tensor<float>>, seq<tensor<double>>, seq<tensor<string>>, seq<tensor<bool>>, seq<tensor<complex64>>, seq<tensor<complex128>>] */))),
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<uint8>, tensor<uint16>, tensor<uint32>, tensor<uint64>, tensor<int8>, tensor<int16>, tensor<int32>, tensor<int64>, tensor<float16>, tensor<float>, tensor<double>, tensor<string>, tensor<bool>, tensor<complex64>, tensor<complex128>] */))),
            I(new OnnxType.TypeVariable("I", List.of(/* @@@ [tensor<int32>, tensor<int64>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            input_sequence(TypeConstraint.S.typeVariable(), Quantifier.REQUIRED),
            position(TypeConstraint.I.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            tensor(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public SequenceAt(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        SequenceAt(SequenceAt that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public SequenceAt transform(CopyContext cc, OpTransformer ot) {
            return new SequenceAt(this, cc);
        }
        
        SequenceAt(TypeElement resultType, Value input_sequence, Value position) {
            super(SCHEMA, resultType, Set.of(), List.of(input_sequence, position), List.of());
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(input_sequence(), position()));
        }
        
        public Value input_sequence() {
            return operands().get(0);
        }
        
        public Value position() {
            return operands().get(1);
        }
        
    }
    
    public static SequenceAt SequenceAt(TypeElement resultType, Value input_sequence, Value position) {
        return new SequenceAt(resultType, input_sequence, position);
    }

    @OpFactory.OpDeclaration(SequenceConstruct.NAME)
    public static final class SequenceConstruct extends OnnxOp {
        public static final String NAME = "SequenceConstruct";
        
        public enum Attribute implements OnnxAttribute.None { }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<uint8>, tensor<uint16>, tensor<uint32>, tensor<uint64>, tensor<int8>, tensor<int16>, tensor<int32>, tensor<int64>, tensor<float16>, tensor<float>, tensor<double>, tensor<string>, tensor<bool>, tensor<complex64>, tensor<complex128>] */))),
            S(new OnnxType.TypeVariable("S", List.of(/* @@@ [seq<tensor<uint8>>, seq<tensor<uint16>>, seq<tensor<uint32>>, seq<tensor<uint64>>, seq<tensor<int8>>, seq<tensor<int16>>, seq<tensor<int32>>, seq<tensor<int64>>, seq<tensor<float16>>, seq<tensor<float>>, seq<tensor<double>>, seq<tensor<string>>, seq<tensor<bool>>, seq<tensor<complex64>>, seq<tensor<complex128>>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            inputs(TypeConstraint.T.typeVariable(), Quantifier.VARIADIC),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            output_sequence(TypeConstraint.S.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public SequenceConstruct(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        SequenceConstruct(SequenceConstruct that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public SequenceConstruct transform(CopyContext cc, OpTransformer ot) {
            return new SequenceConstruct(this, cc);
        }
        
        SequenceConstruct(TypeElement resultType, List<Value> inputs) {
            super(SCHEMA, resultType, Set.of(), List.of(inputs), List.of());
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(inputs()));
        }
        
        public List<Value> inputs() {
            return operands();
        }
        
    }
    
    public static SequenceConstruct SequenceConstruct(TypeElement resultType, List<Value> inputs) {
        return new SequenceConstruct(resultType, inputs);
    }

    @OpFactory.OpDeclaration(SequenceEmpty.NAME)
    public static final class SequenceEmpty extends OnnxOp {
        public static final String NAME = "SequenceEmpty";
        
        public enum Attribute implements OnnxAttribute {
            dtype(Integer.class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            S(new OnnxType.TypeVariable("S", List.of(/* @@@ [seq<tensor<uint8>>, seq<tensor<uint16>>, seq<tensor<uint32>>, seq<tensor<uint64>>, seq<tensor<int8>>, seq<tensor<int16>>, seq<tensor<int32>>, seq<tensor<int64>>, seq<tensor<float16>>, seq<tensor<float>>, seq<tensor<double>>, seq<tensor<string>>, seq<tensor<bool>>, seq<tensor<complex64>>, seq<tensor<complex128>>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter.None { }
        
        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.S.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public SequenceEmpty(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        SequenceEmpty(SequenceEmpty that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public SequenceEmpty transform(CopyContext cc, OpTransformer ot) {
            return new SequenceEmpty(this, cc);
        }
        
        SequenceEmpty(TypeElement resultType, java.util.Optional<Integer> dtype) {
            super(SCHEMA, resultType, Set.of(), List.of(), List.of(dtype));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of());
        }
        
        public java.util.Optional<Integer> dtype() {
            Integer dtype = Attribute.dtype.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(dtype);
        }
        
    }
    
    public static SequenceEmpty SequenceEmpty(TypeElement resultType, java.util.Optional<Integer> dtype) {
        return new SequenceEmpty(resultType, dtype);
    }

    @OpFactory.OpDeclaration(SequenceErase.NAME)
    public static final class SequenceErase extends OnnxOp {
        public static final String NAME = "SequenceErase";
        
        public enum Attribute implements OnnxAttribute.None { }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            S(new OnnxType.TypeVariable("S", List.of(/* @@@ [seq<tensor<uint8>>, seq<tensor<uint16>>, seq<tensor<uint32>>, seq<tensor<uint64>>, seq<tensor<int8>>, seq<tensor<int16>>, seq<tensor<int32>>, seq<tensor<int64>>, seq<tensor<float16>>, seq<tensor<float>>, seq<tensor<double>>, seq<tensor<string>>, seq<tensor<bool>>, seq<tensor<complex64>>, seq<tensor<complex128>>] */))),
            I(new OnnxType.TypeVariable("I", List.of(/* @@@ [tensor<int32>, tensor<int64>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            input_sequence(TypeConstraint.S.typeVariable(), Quantifier.REQUIRED),
            position(TypeConstraint.I.typeVariable(), Quantifier.OPTIONAL),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            output_sequence(TypeConstraint.S.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public SequenceErase(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        SequenceErase(SequenceErase that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public SequenceErase transform(CopyContext cc, OpTransformer ot) {
            return new SequenceErase(this, cc);
        }
        
        SequenceErase(TypeElement resultType, Value input_sequence, java.util.Optional<Value> position) {
            super(SCHEMA, resultType, Set.of(), List.of(input_sequence, position), List.of());
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(input_sequence(), position()));
        }
        
        public Value input_sequence() {
            return operands().get(0);
        }
        
        public java.util.Optional<Value> position() {
            int i = optionalInputArguments.indexOf(InputParameter.position);
            return i != -1 ? java.util.Optional.of(operands().get(1 + i)) : java.util.Optional.empty();
        }
        
    }
    
    public static SequenceErase SequenceErase(TypeElement resultType, Value input_sequence, java.util.Optional<Value> position) {
        return new SequenceErase(resultType, input_sequence, position);
    }

    @OpFactory.OpDeclaration(SequenceInsert.NAME)
    public static final class SequenceInsert extends OnnxOp {
        public static final String NAME = "SequenceInsert";
        
        public enum Attribute implements OnnxAttribute.None { }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<uint8>, tensor<uint16>, tensor<uint32>, tensor<uint64>, tensor<int8>, tensor<int16>, tensor<int32>, tensor<int64>, tensor<float16>, tensor<float>, tensor<double>, tensor<string>, tensor<bool>, tensor<complex64>, tensor<complex128>] */))),
            S(new OnnxType.TypeVariable("S", List.of(/* @@@ [seq<tensor<uint8>>, seq<tensor<uint16>>, seq<tensor<uint32>>, seq<tensor<uint64>>, seq<tensor<int8>>, seq<tensor<int16>>, seq<tensor<int32>>, seq<tensor<int64>>, seq<tensor<float16>>, seq<tensor<float>>, seq<tensor<double>>, seq<tensor<string>>, seq<tensor<bool>>, seq<tensor<complex64>>, seq<tensor<complex128>>] */))),
            I(new OnnxType.TypeVariable("I", List.of(/* @@@ [tensor<int32>, tensor<int64>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            input_sequence(TypeConstraint.S.typeVariable(), Quantifier.REQUIRED),
            tensor(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            position(TypeConstraint.I.typeVariable(), Quantifier.OPTIONAL),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            output_sequence(TypeConstraint.S.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public SequenceInsert(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        SequenceInsert(SequenceInsert that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public SequenceInsert transform(CopyContext cc, OpTransformer ot) {
            return new SequenceInsert(this, cc);
        }
        
        SequenceInsert(TypeElement resultType, Value input_sequence, Value tensor, java.util.Optional<Value> position) {
            super(SCHEMA, resultType, Set.of(), List.of(input_sequence, tensor, position), List.of());
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(input_sequence(), tensor(), position()));
        }
        
        public Value input_sequence() {
            return operands().get(0);
        }
        
        public Value tensor() {
            return operands().get(1);
        }
        
        public java.util.Optional<Value> position() {
            int i = optionalInputArguments.indexOf(InputParameter.position);
            return i != -1 ? java.util.Optional.of(operands().get(2 + i)) : java.util.Optional.empty();
        }
        
    }
    
    public static SequenceInsert SequenceInsert(TypeElement resultType, Value input_sequence, Value tensor, java.util.Optional<Value> position) {
        return new SequenceInsert(resultType, input_sequence, tensor, position);
    }

    @OpFactory.OpDeclaration(SequenceLength.NAME)
    public static final class SequenceLength extends OnnxOp {
        public static final String NAME = "SequenceLength";
        
        public enum Attribute implements OnnxAttribute.None { }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            S(new OnnxType.TypeVariable("S", List.of(/* @@@ [seq<tensor<uint8>>, seq<tensor<uint16>>, seq<tensor<uint32>>, seq<tensor<uint64>>, seq<tensor<int8>>, seq<tensor<int16>>, seq<tensor<int32>>, seq<tensor<int64>>, seq<tensor<float16>>, seq<tensor<float>>, seq<tensor<double>>, seq<tensor<string>>, seq<tensor<bool>>, seq<tensor<complex64>>, seq<tensor<complex128>>] */))),
            I(new OnnxType.TypeVariable("I", List.of(/* @@@ [tensor<int64>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            input_sequence(TypeConstraint.S.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            length(TypeConstraint.I.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public SequenceLength(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        SequenceLength(SequenceLength that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public SequenceLength transform(CopyContext cc, OpTransformer ot) {
            return new SequenceLength(this, cc);
        }
        
        SequenceLength(TypeElement resultType, Value input_sequence) {
            super(SCHEMA, resultType, Set.of(), List.of(input_sequence), List.of());
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(input_sequence()));
        }
        
        public Value input_sequence() {
            return operands().get(0);
        }
        
    }
    
    public static SequenceLength SequenceLength(TypeElement resultType, Value input_sequence) {
        return new SequenceLength(resultType, input_sequence);
    }

    @OpFactory.OpDeclaration(Shape.NAME)
    public static final class Shape extends OnnxOp {
        public static final String NAME = "Shape";
        
        public enum Attribute implements OnnxAttribute {
            start(Integer.class, true, null),
            end(Integer.class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<uint8>, tensor<uint16>, tensor<uint32>, tensor<uint64>, tensor<int8>, tensor<int16>, tensor<int32>, tensor<int64>, tensor<bfloat16>, tensor<float16>, tensor<float>, tensor<double>, tensor<string>, tensor<bool>, tensor<complex64>, tensor<complex128>, tensor<float8e4m3fn>, tensor<float8e4m3fnuz>, tensor<float8e5m2>, tensor<float8e5m2fnuz>, tensor<uint4>, tensor<int4>, tensor<float4e2m1>] */))),
            T1(new OnnxType.TypeVariable("T1", List.of(/* @@@ [tensor<int64>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            data(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            shape(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public Shape(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        Shape(Shape that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public Shape transform(CopyContext cc, OpTransformer ot) {
            return new Shape(this, cc);
        }
        
        Shape(TypeElement resultType, Value data, java.util.Optional<Integer> start, java.util.Optional<Integer> end) {
            super(SCHEMA, resultType, Set.of(), List.of(data), List.of(start, end));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(data()));
        }
        
        public Value data() {
            return operands().get(0);
        }
        
        public java.util.Optional<Integer> start() {
            Integer start = Attribute.start.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(start);
        }
        
        public java.util.Optional<Integer> end() {
            Integer end = Attribute.end.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(end);
        }
        
    }
    
    public static Shape Shape(TypeElement resultType, Value data, java.util.Optional<Integer> start, java.util.Optional<Integer> end) {
        return new Shape(resultType, data, start, end);
    }

    @OpFactory.OpDeclaration(Shrink.NAME)
    public static final class Shrink extends OnnxOp {
        public static final String NAME = "Shrink";
        
        public enum Attribute implements OnnxAttribute {
            lambd(Float.class, true, null),
            bias(Float.class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<uint8>, tensor<uint16>, tensor<uint32>, tensor<uint64>, tensor<int8>, tensor<int16>, tensor<int32>, tensor<int64>, tensor<float16>, tensor<float>, tensor<double>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            input(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public Shrink(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        Shrink(Shrink that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public Shrink transform(CopyContext cc, OpTransformer ot) {
            return new Shrink(this, cc);
        }
        
        Shrink(TypeElement resultType, Value input, java.util.Optional<Float> lambd, java.util.Optional<Float> bias) {
            super(SCHEMA, resultType, Set.of(), List.of(input), List.of(lambd, bias));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(input()));
        }
        
        public Value input() {
            return operands().get(0);
        }
        
        public java.util.Optional<Float> lambd() {
            Float lambd = Attribute.lambd.access(Float.class, onnxAttributes);
            return java.util.Optional.ofNullable(lambd);
        }
        
        public java.util.Optional<Float> bias() {
            Float bias = Attribute.bias.access(Float.class, onnxAttributes);
            return java.util.Optional.ofNullable(bias);
        }
        
    }
    
    public static Shrink Shrink(TypeElement resultType, Value input, java.util.Optional<Float> lambd, java.util.Optional<Float> bias) {
        return new Shrink(resultType, input, lambd, bias);
    }

    @OpFactory.OpDeclaration(Sigmoid.NAME)
    public static final class Sigmoid extends OnnxOp {
        public static final String NAME = "Sigmoid";
        
        public enum Attribute implements OnnxAttribute.None { }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<float16>, tensor<float>, tensor<double>, tensor<bfloat16>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public Sigmoid(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        Sigmoid(Sigmoid that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public Sigmoid transform(CopyContext cc, OpTransformer ot) {
            return new Sigmoid(this, cc);
        }
        
        Sigmoid(TypeElement resultType, Value X) {
            super(SCHEMA, resultType, Set.of(), List.of(X), List.of());
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X()));
        }
        
        public Value X() {
            return operands().get(0);
        }
        
    }
    
    public static Sigmoid Sigmoid(TypeElement resultType, Value X) {
        return new Sigmoid(resultType, X);
    }

    @OpFactory.OpDeclaration(Sign.NAME)
    public static final class Sign extends OnnxOp {
        public static final String NAME = "Sign";
        
        public enum Attribute implements OnnxAttribute.None { }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<uint8>, tensor<uint16>, tensor<uint32>, tensor<uint64>, tensor<int8>, tensor<int16>, tensor<int32>, tensor<int64>, tensor<float16>, tensor<float>, tensor<double>, tensor<bfloat16>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            input(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public Sign(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        Sign(Sign that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public Sign transform(CopyContext cc, OpTransformer ot) {
            return new Sign(this, cc);
        }
        
        Sign(TypeElement resultType, Value input) {
            super(SCHEMA, resultType, Set.of(), List.of(input), List.of());
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(input()));
        }
        
        public Value input() {
            return operands().get(0);
        }
        
    }
    
    public static Sign Sign(TypeElement resultType, Value input) {
        return new Sign(resultType, input);
    }

    @OpFactory.OpDeclaration(Sin.NAME)
    public static final class Sin extends OnnxOp {
        public static final String NAME = "Sin";
        
        public enum Attribute implements OnnxAttribute.None { }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<bfloat16>, tensor<float16>, tensor<float>, tensor<double>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            input(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public Sin(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        Sin(Sin that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public Sin transform(CopyContext cc, OpTransformer ot) {
            return new Sin(this, cc);
        }
        
        Sin(TypeElement resultType, Value input) {
            super(SCHEMA, resultType, Set.of(), List.of(input), List.of());
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(input()));
        }
        
        public Value input() {
            return operands().get(0);
        }
        
    }
    
    public static Sin Sin(TypeElement resultType, Value input) {
        return new Sin(resultType, input);
    }

    @OpFactory.OpDeclaration(Sinh.NAME)
    public static final class Sinh extends OnnxOp {
        public static final String NAME = "Sinh";
        
        public enum Attribute implements OnnxAttribute.None { }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<bfloat16>, tensor<float16>, tensor<float>, tensor<double>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            input(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public Sinh(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        Sinh(Sinh that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public Sinh transform(CopyContext cc, OpTransformer ot) {
            return new Sinh(this, cc);
        }
        
        Sinh(TypeElement resultType, Value input) {
            super(SCHEMA, resultType, Set.of(), List.of(input), List.of());
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(input()));
        }
        
        public Value input() {
            return operands().get(0);
        }
        
    }
    
    public static Sinh Sinh(TypeElement resultType, Value input) {
        return new Sinh(resultType, input);
    }

    @OpFactory.OpDeclaration(Size.NAME)
    public static final class Size extends OnnxOp {
        public static final String NAME = "Size";
        
        public enum Attribute implements OnnxAttribute.None { }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<uint8>, tensor<uint16>, tensor<uint32>, tensor<uint64>, tensor<int8>, tensor<int16>, tensor<int32>, tensor<int64>, tensor<bfloat16>, tensor<float16>, tensor<float>, tensor<double>, tensor<string>, tensor<bool>, tensor<complex64>, tensor<complex128>, tensor<float8e4m3fn>, tensor<float8e4m3fnuz>, tensor<float8e5m2>, tensor<float8e5m2fnuz>, tensor<uint4>, tensor<int4>, tensor<float4e2m1>] */))),
            T1(new OnnxType.TypeVariable("T1", List.of(/* @@@ [tensor<int64>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            data(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            size(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public Size(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        Size(Size that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public Size transform(CopyContext cc, OpTransformer ot) {
            return new Size(this, cc);
        }
        
        Size(TypeElement resultType, Value data) {
            super(SCHEMA, resultType, Set.of(), List.of(data), List.of());
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(data()));
        }
        
        public Value data() {
            return operands().get(0);
        }
        
    }
    
    public static Size Size(TypeElement resultType, Value data) {
        return new Size(resultType, data);
    }

    @OpFactory.OpDeclaration(Slice.NAME)
    public static final class Slice extends OnnxOp {
        public static final String NAME = "Slice";
        
        public enum Attribute implements OnnxAttribute.None { }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<uint8>, tensor<uint16>, tensor<uint32>, tensor<uint64>, tensor<int8>, tensor<int16>, tensor<int32>, tensor<int64>, tensor<bfloat16>, tensor<float16>, tensor<float>, tensor<double>, tensor<string>, tensor<bool>, tensor<complex64>, tensor<complex128>] */))),
            Tind(new OnnxType.TypeVariable("Tind", List.of(/* @@@ [tensor<int32>, tensor<int64>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            data(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            starts(TypeConstraint.Tind.typeVariable(), Quantifier.REQUIRED),
            ends(TypeConstraint.Tind.typeVariable(), Quantifier.REQUIRED),
            axes(TypeConstraint.Tind.typeVariable(), Quantifier.OPTIONAL),
            steps(TypeConstraint.Tind.typeVariable(), Quantifier.OPTIONAL),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public Slice(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        Slice(Slice that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public Slice transform(CopyContext cc, OpTransformer ot) {
            return new Slice(this, cc);
        }
        
        Slice(TypeElement resultType, Value data, Value starts, Value ends, java.util.Optional<Value> axes, java.util.Optional<Value> steps) {
            super(SCHEMA, resultType, Set.of(), List.of(data, starts, ends, axes, steps), List.of());
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(data(), starts(), ends(), axes(), steps()));
        }
        
        public Value data() {
            return operands().get(0);
        }
        
        public Value starts() {
            return operands().get(1);
        }
        
        public Value ends() {
            return operands().get(2);
        }
        
        public java.util.Optional<Value> axes() {
            int i = optionalInputArguments.indexOf(InputParameter.axes);
            return i != -1 ? java.util.Optional.of(operands().get(3 + i)) : java.util.Optional.empty();
        }
        
        public java.util.Optional<Value> steps() {
            int i = optionalInputArguments.indexOf(InputParameter.steps);
            return i != -1 ? java.util.Optional.of(operands().get(3 + i)) : java.util.Optional.empty();
        }
        
    }
    
    public static Slice Slice(TypeElement resultType, Value data, Value starts, Value ends, java.util.Optional<Value> axes, java.util.Optional<Value> steps) {
        return new Slice(resultType, data, starts, ends, axes, steps);
    }

    @OpFactory.OpDeclaration(Softmax.NAME)
    public static final class Softmax extends OnnxOp {
        public static final String NAME = "Softmax";
        
        public enum Attribute implements OnnxAttribute {
            axis(Integer.class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<float16>, tensor<float>, tensor<double>, tensor<bfloat16>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            input(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public Softmax(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        Softmax(Softmax that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public Softmax transform(CopyContext cc, OpTransformer ot) {
            return new Softmax(this, cc);
        }
        
        Softmax(TypeElement resultType, Value input, java.util.Optional<Integer> axis) {
            super(SCHEMA, resultType, Set.of(), List.of(input), List.of(axis));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(input()));
        }
        
        public Value input() {
            return operands().get(0);
        }
        
        public java.util.Optional<Integer> axis() {
            Integer axis = Attribute.axis.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(axis);
        }
        
    }
    
    public static Softmax Softmax(TypeElement resultType, Value input, java.util.Optional<Integer> axis) {
        return new Softmax(resultType, input, axis);
    }

    @OpFactory.OpDeclaration(SoftmaxCrossEntropyLoss.NAME)
    public static final class SoftmaxCrossEntropyLoss extends OnnxOp {
        public static final String NAME = "SoftmaxCrossEntropyLoss";
        
        public enum Attribute implements OnnxAttribute {
            ignore_index(Integer.class, true, null),
            reduction(String.class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<float16>, tensor<float>, tensor<double>, tensor<bfloat16>] */))),
            Tind(new OnnxType.TypeVariable("Tind", List.of(/* @@@ [tensor<int32>, tensor<int64>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            scores(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            labels(TypeConstraint.Tind.typeVariable(), Quantifier.REQUIRED),
            weights(TypeConstraint.T.typeVariable(), Quantifier.OPTIONAL),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            log_prob(TypeConstraint.T.typeVariable(), Quantifier.OPTIONAL),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public SoftmaxCrossEntropyLoss(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        SoftmaxCrossEntropyLoss(SoftmaxCrossEntropyLoss that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public SoftmaxCrossEntropyLoss transform(CopyContext cc, OpTransformer ot) {
            return new SoftmaxCrossEntropyLoss(this, cc);
        }
        
        SoftmaxCrossEntropyLoss(TypeElement resultType, Value scores, Value labels, java.util.Optional<Value> weights, java.util.Optional<Integer> ignore_index, java.util.Optional<String> reduction) {
            super(SCHEMA, resultType, Set.of(), List.of(scores, labels, weights), List.of(ignore_index, reduction));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(scores(), labels(), weights()));
        }
        
        public Value scores() {
            return operands().get(0);
        }
        
        public Value labels() {
            return operands().get(1);
        }
        
        public java.util.Optional<Value> weights() {
            int i = optionalInputArguments.indexOf(InputParameter.weights);
            return i != -1 ? java.util.Optional.of(operands().get(2 + i)) : java.util.Optional.empty();
        }
        
        public java.util.Optional<Integer> ignore_index() {
            Integer ignore_index = Attribute.ignore_index.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(ignore_index);
        }
        
        public java.util.Optional<String> reduction() {
            String reduction = Attribute.reduction.access(String.class, onnxAttributes);
            return java.util.Optional.ofNullable(reduction);
        }
        
    }
    
    public static SoftmaxCrossEntropyLoss SoftmaxCrossEntropyLoss(TypeElement resultType, Value scores, Value labels, java.util.Optional<Value> weights, java.util.Optional<Integer> ignore_index, java.util.Optional<String> reduction) {
        return new SoftmaxCrossEntropyLoss(resultType, scores, labels, weights, ignore_index, reduction);
    }

    @OpFactory.OpDeclaration(Softplus.NAME)
    public static final class Softplus extends OnnxOp {
        public static final String NAME = "Softplus";
        
        public enum Attribute implements OnnxAttribute.None { }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<bfloat16>, tensor<float16>, tensor<float>, tensor<double>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public Softplus(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        Softplus(Softplus that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public Softplus transform(CopyContext cc, OpTransformer ot) {
            return new Softplus(this, cc);
        }
        
        Softplus(TypeElement resultType, Value X) {
            super(SCHEMA, resultType, Set.of(), List.of(X), List.of());
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X()));
        }
        
        public Value X() {
            return operands().get(0);
        }
        
    }
    
    public static Softplus Softplus(TypeElement resultType, Value X) {
        return new Softplus(resultType, X);
    }

    @OpFactory.OpDeclaration(Softsign.NAME)
    public static final class Softsign extends OnnxOp {
        public static final String NAME = "Softsign";
        
        public enum Attribute implements OnnxAttribute.None { }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<bfloat16>, tensor<float16>, tensor<float>, tensor<double>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            input(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public Softsign(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        Softsign(Softsign that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public Softsign transform(CopyContext cc, OpTransformer ot) {
            return new Softsign(this, cc);
        }
        
        Softsign(TypeElement resultType, Value input) {
            super(SCHEMA, resultType, Set.of(), List.of(input), List.of());
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(input()));
        }
        
        public Value input() {
            return operands().get(0);
        }
        
    }
    
    public static Softsign Softsign(TypeElement resultType, Value input) {
        return new Softsign(resultType, input);
    }

    @OpFactory.OpDeclaration(SpaceToDepth.NAME)
    public static final class SpaceToDepth extends OnnxOp {
        public static final String NAME = "SpaceToDepth";
        
        public enum Attribute implements OnnxAttribute {
            blocksize(Integer.class, false, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<uint8>, tensor<uint16>, tensor<uint32>, tensor<uint64>, tensor<int8>, tensor<int16>, tensor<int32>, tensor<int64>, tensor<bfloat16>, tensor<float16>, tensor<float>, tensor<double>, tensor<string>, tensor<bool>, tensor<complex64>, tensor<complex128>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            input(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public SpaceToDepth(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        SpaceToDepth(SpaceToDepth that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public SpaceToDepth transform(CopyContext cc, OpTransformer ot) {
            return new SpaceToDepth(this, cc);
        }
        
        SpaceToDepth(TypeElement resultType, Value input, int blocksize) {
            super(SCHEMA, resultType, Set.of(), List.of(input), List.of(blocksize));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(input()));
        }
        
        public Value input() {
            return operands().get(0);
        }
        
        public int blocksize() {
            int blocksize = Attribute.blocksize.access(int.class, onnxAttributes);
            return blocksize;
        }
        
    }
    
    public static SpaceToDepth SpaceToDepth(TypeElement resultType, Value input, int blocksize) {
        return new SpaceToDepth(resultType, input, blocksize);
    }

    @OpFactory.OpDeclaration(Split.NAME)
    public static final class Split extends OnnxOp {
        public static final String NAME = "Split";
        
        public enum Attribute implements OnnxAttribute {
            num_outputs(Integer.class, true, null),
            axis(Integer.class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<uint8>, tensor<uint16>, tensor<uint32>, tensor<uint64>, tensor<int8>, tensor<int16>, tensor<int32>, tensor<int64>, tensor<bfloat16>, tensor<float16>, tensor<float>, tensor<double>, tensor<string>, tensor<bool>, tensor<complex64>, tensor<complex128>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            input(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            split(null /* @@@ tensor<int64> */, Quantifier.OPTIONAL),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            outputs(TypeConstraint.T.typeVariable(), Quantifier.VARIADIC),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public Split(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        Split(Split that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public Split transform(CopyContext cc, OpTransformer ot) {
            return new Split(this, cc);
        }
        
        Split(TypeElement resultType, Value input, java.util.Optional<Value> split, java.util.Optional<Integer> num_outputs, java.util.Optional<Integer> axis) {
            super(SCHEMA, resultType, Set.of(), List.of(input, split), List.of(num_outputs, axis));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(input(), split()));
        }
        
        public Value input() {
            return operands().get(0);
        }
        
        public java.util.Optional<Value> split() {
            int i = optionalInputArguments.indexOf(InputParameter.split);
            return i != -1 ? java.util.Optional.of(operands().get(1 + i)) : java.util.Optional.empty();
        }
        
        public java.util.Optional<Integer> num_outputs() {
            Integer num_outputs = Attribute.num_outputs.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(num_outputs);
        }
        
        public java.util.Optional<Integer> axis() {
            Integer axis = Attribute.axis.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(axis);
        }
        
    }
    
    public static Split Split(TypeElement resultType, Value input, java.util.Optional<Value> split, java.util.Optional<Integer> num_outputs, java.util.Optional<Integer> axis) {
        return new Split(resultType, input, split, num_outputs, axis);
    }

    @OpFactory.OpDeclaration(SplitToSequence.NAME)
    public static final class SplitToSequence extends OnnxOp {
        public static final String NAME = "SplitToSequence";
        
        public enum Attribute implements OnnxAttribute {
            keepdims(Integer.class, true, null),
            axis(Integer.class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<uint8>, tensor<uint16>, tensor<uint32>, tensor<uint64>, tensor<int8>, tensor<int16>, tensor<int32>, tensor<int64>, tensor<float16>, tensor<float>, tensor<double>, tensor<string>, tensor<bool>, tensor<complex64>, tensor<complex128>] */))),
            I(new OnnxType.TypeVariable("I", List.of(/* @@@ [tensor<int32>, tensor<int64>] */))),
            S(new OnnxType.TypeVariable("S", List.of(/* @@@ [seq<tensor<uint8>>, seq<tensor<uint16>>, seq<tensor<uint32>>, seq<tensor<uint64>>, seq<tensor<int8>>, seq<tensor<int16>>, seq<tensor<int32>>, seq<tensor<int64>>, seq<tensor<float16>>, seq<tensor<float>>, seq<tensor<double>>, seq<tensor<string>>, seq<tensor<bool>>, seq<tensor<complex64>>, seq<tensor<complex128>>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            input(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            split(TypeConstraint.I.typeVariable(), Quantifier.OPTIONAL),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            output_sequence(TypeConstraint.S.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public SplitToSequence(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        SplitToSequence(SplitToSequence that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public SplitToSequence transform(CopyContext cc, OpTransformer ot) {
            return new SplitToSequence(this, cc);
        }
        
        SplitToSequence(TypeElement resultType, Value input, java.util.Optional<Value> split, java.util.Optional<Integer> keepdims, java.util.Optional<Integer> axis) {
            super(SCHEMA, resultType, Set.of(), List.of(input, split), List.of(keepdims, axis));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(input(), split()));
        }
        
        public Value input() {
            return operands().get(0);
        }
        
        public java.util.Optional<Value> split() {
            int i = optionalInputArguments.indexOf(InputParameter.split);
            return i != -1 ? java.util.Optional.of(operands().get(1 + i)) : java.util.Optional.empty();
        }
        
        public java.util.Optional<Integer> keepdims() {
            Integer keepdims = Attribute.keepdims.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(keepdims);
        }
        
        public java.util.Optional<Integer> axis() {
            Integer axis = Attribute.axis.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(axis);
        }
        
    }
    
    public static SplitToSequence SplitToSequence(TypeElement resultType, Value input, java.util.Optional<Value> split, java.util.Optional<Integer> keepdims, java.util.Optional<Integer> axis) {
        return new SplitToSequence(resultType, input, split, keepdims, axis);
    }

    @OpFactory.OpDeclaration(Sqrt.NAME)
    public static final class Sqrt extends OnnxOp {
        public static final String NAME = "Sqrt";
        
        public enum Attribute implements OnnxAttribute.None { }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<float16>, tensor<float>, tensor<double>, tensor<bfloat16>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public Sqrt(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        Sqrt(Sqrt that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public Sqrt transform(CopyContext cc, OpTransformer ot) {
            return new Sqrt(this, cc);
        }
        
        Sqrt(TypeElement resultType, Value X) {
            super(SCHEMA, resultType, Set.of(), List.of(X), List.of());
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X()));
        }
        
        public Value X() {
            return operands().get(0);
        }
        
    }
    
    public static Sqrt Sqrt(TypeElement resultType, Value X) {
        return new Sqrt(resultType, X);
    }

    @OpFactory.OpDeclaration(Squeeze.NAME)
    public static final class Squeeze extends OnnxOp {
        public static final String NAME = "Squeeze";
        
        public enum Attribute implements OnnxAttribute.None { }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<uint8>, tensor<uint16>, tensor<uint32>, tensor<uint64>, tensor<int8>, tensor<int16>, tensor<int32>, tensor<int64>, tensor<bfloat16>, tensor<float16>, tensor<float>, tensor<double>, tensor<string>, tensor<bool>, tensor<complex64>, tensor<complex128>, tensor<float8e4m3fn>, tensor<float8e4m3fnuz>, tensor<float8e5m2>, tensor<float8e5m2fnuz>, tensor<uint4>, tensor<int4>, tensor<float4e2m1>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            data(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            axes(null /* @@@ tensor<int64> */, Quantifier.OPTIONAL),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            squeezed(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public Squeeze(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        Squeeze(Squeeze that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public Squeeze transform(CopyContext cc, OpTransformer ot) {
            return new Squeeze(this, cc);
        }
        
        Squeeze(TypeElement resultType, Value data, java.util.Optional<Value> axes) {
            super(SCHEMA, resultType, Set.of(), List.of(data, axes), List.of());
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(data(), axes()));
        }
        
        public Value data() {
            return operands().get(0);
        }
        
        public java.util.Optional<Value> axes() {
            int i = optionalInputArguments.indexOf(InputParameter.axes);
            return i != -1 ? java.util.Optional.of(operands().get(1 + i)) : java.util.Optional.empty();
        }
        
    }
    
    public static Squeeze Squeeze(TypeElement resultType, Value data, java.util.Optional<Value> axes) {
        return new Squeeze(resultType, data, axes);
    }

    @OpFactory.OpDeclaration(StringConcat.NAME)
    public static final class StringConcat extends OnnxOp {
        public static final String NAME = "StringConcat";
        
        public enum Attribute implements OnnxAttribute.None { }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<string>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            Z(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public StringConcat(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        StringConcat(StringConcat that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public StringConcat transform(CopyContext cc, OpTransformer ot) {
            return new StringConcat(this, cc);
        }
        
        StringConcat(TypeElement resultType, Value X, Value Y) {
            super(SCHEMA, resultType, Set.of(), List.of(X, Y), List.of());
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X(), Y()));
        }
        
        public Value X() {
            return operands().get(0);
        }
        
        public Value Y() {
            return operands().get(1);
        }
        
    }
    
    public static StringConcat StringConcat(TypeElement resultType, Value X, Value Y) {
        return new StringConcat(resultType, X, Y);
    }

    @OpFactory.OpDeclaration(StringNormalizer.NAME)
    public static final class StringNormalizer extends OnnxOp {
        public static final String NAME = "StringNormalizer";
        
        public enum Attribute implements OnnxAttribute {
            is_case_sensitive(Integer.class, true, null),
            locale(String.class, true, null),
            stopwords(String[].class, true, null),
            case_change_action(String.class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint.None { }
        
        public enum InputParameter implements OnnxParameter {
            X(null /* @@@ tensor<string> */, Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            Y(null /* @@@ tensor<string> */, Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public StringNormalizer(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        StringNormalizer(StringNormalizer that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public StringNormalizer transform(CopyContext cc, OpTransformer ot) {
            return new StringNormalizer(this, cc);
        }
        
        StringNormalizer(TypeElement resultType, Value X, java.util.Optional<Integer> is_case_sensitive, java.util.Optional<String> locale, java.util.Optional<String[]> stopwords, java.util.Optional<String> case_change_action) {
            super(SCHEMA, resultType, Set.of(), List.of(X), List.of(is_case_sensitive, locale, stopwords, case_change_action));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X()));
        }
        
        public Value X() {
            return operands().get(0);
        }
        
        public java.util.Optional<Integer> is_case_sensitive() {
            Integer is_case_sensitive = Attribute.is_case_sensitive.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(is_case_sensitive);
        }
        
        public java.util.Optional<String> locale() {
            String locale = Attribute.locale.access(String.class, onnxAttributes);
            return java.util.Optional.ofNullable(locale);
        }
        
        public java.util.Optional<String[]> stopwords() {
            String[] stopwords = Attribute.stopwords.access(String[].class, onnxAttributes);
            return java.util.Optional.ofNullable(stopwords).map(String[]::clone);
        }
        
        public java.util.Optional<String> case_change_action() {
            String case_change_action = Attribute.case_change_action.access(String.class, onnxAttributes);
            return java.util.Optional.ofNullable(case_change_action);
        }
        
    }
    
    public static StringNormalizer StringNormalizer(TypeElement resultType, Value X, java.util.Optional<Integer> is_case_sensitive, java.util.Optional<String> locale, java.util.Optional<String[]> stopwords, java.util.Optional<String> case_change_action) {
        return new StringNormalizer(resultType, X, is_case_sensitive, locale, stopwords, case_change_action);
    }

    @OpFactory.OpDeclaration(StringSplit.NAME)
    public static final class StringSplit extends OnnxOp {
        public static final String NAME = "StringSplit";
        
        public enum Attribute implements OnnxAttribute {
            delimiter(String.class, true, null),
            maxsplit(Integer.class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T1(new OnnxType.TypeVariable("T1", List.of(/* @@@ [tensor<string>] */))),
            T2(new OnnxType.TypeVariable("T2", List.of(/* @@@ [tensor<string>] */))),
            T3(new OnnxType.TypeVariable("T3", List.of(/* @@@ [tensor<int64>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),
            Z(TypeConstraint.T3.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public StringSplit(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        StringSplit(StringSplit that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public StringSplit transform(CopyContext cc, OpTransformer ot) {
            return new StringSplit(this, cc);
        }
        
        StringSplit(TypeElement resultType, Value X, java.util.Optional<String> delimiter, java.util.Optional<Integer> maxsplit) {
            super(SCHEMA, resultType, Set.of(), List.of(X), List.of(delimiter, maxsplit));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X()));
        }
        
        public Value X() {
            return operands().get(0);
        }
        
        public java.util.Optional<String> delimiter() {
            String delimiter = Attribute.delimiter.access(String.class, onnxAttributes);
            return java.util.Optional.ofNullable(delimiter);
        }
        
        public java.util.Optional<Integer> maxsplit() {
            Integer maxsplit = Attribute.maxsplit.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(maxsplit);
        }
        
    }
    
    public static StringSplit StringSplit(TypeElement resultType, Value X, java.util.Optional<String> delimiter, java.util.Optional<Integer> maxsplit) {
        return new StringSplit(resultType, X, delimiter, maxsplit);
    }

    @OpFactory.OpDeclaration(Sub.NAME)
    public static final class Sub extends OnnxOp {
        public static final String NAME = "Sub";
        
        public enum Attribute implements OnnxAttribute.None { }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<uint8>, tensor<uint16>, tensor<uint32>, tensor<uint64>, tensor<int8>, tensor<int16>, tensor<int32>, tensor<int64>, tensor<float16>, tensor<float>, tensor<double>, tensor<bfloat16>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            A(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            B(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            C(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public Sub(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        Sub(Sub that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public Sub transform(CopyContext cc, OpTransformer ot) {
            return new Sub(this, cc);
        }
        
        Sub(TypeElement resultType, Value A, Value B) {
            super(SCHEMA, resultType, Set.of(), List.of(A, B), List.of());
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(A(), B()));
        }
        
        public Value A() {
            return operands().get(0);
        }
        
        public Value B() {
            return operands().get(1);
        }
        
    }
    
    public static Sub Sub(TypeElement resultType, Value A, Value B) {
        return new Sub(resultType, A, B);
    }

    @OpFactory.OpDeclaration(Sum.NAME)
    public static final class Sum extends OnnxOp {
        public static final String NAME = "Sum";
        
        public enum Attribute implements OnnxAttribute.None { }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<float16>, tensor<float>, tensor<double>, tensor<bfloat16>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            data_0(TypeConstraint.T.typeVariable(), Quantifier.VARIADIC),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            sum(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public Sum(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        Sum(Sum that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public Sum transform(CopyContext cc, OpTransformer ot) {
            return new Sum(this, cc);
        }
        
        Sum(TypeElement resultType, List<Value> data_0) {
            super(SCHEMA, resultType, Set.of(), List.of(data_0), List.of());
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(data_0()));
        }
        
        public List<Value> data_0() {
            return operands();
        }
        
    }
    
    public static Sum Sum(TypeElement resultType, List<Value> data_0) {
        return new Sum(resultType, data_0);
    }

    @OpFactory.OpDeclaration(Tan.NAME)
    public static final class Tan extends OnnxOp {
        public static final String NAME = "Tan";
        
        public enum Attribute implements OnnxAttribute.None { }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<bfloat16>, tensor<float16>, tensor<float>, tensor<double>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            input(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public Tan(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        Tan(Tan that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public Tan transform(CopyContext cc, OpTransformer ot) {
            return new Tan(this, cc);
        }
        
        Tan(TypeElement resultType, Value input) {
            super(SCHEMA, resultType, Set.of(), List.of(input), List.of());
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(input()));
        }
        
        public Value input() {
            return operands().get(0);
        }
        
    }
    
    public static Tan Tan(TypeElement resultType, Value input) {
        return new Tan(resultType, input);
    }

    @OpFactory.OpDeclaration(Tanh.NAME)
    public static final class Tanh extends OnnxOp {
        public static final String NAME = "Tanh";
        
        public enum Attribute implements OnnxAttribute.None { }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<bfloat16>, tensor<float16>, tensor<float>, tensor<double>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            input(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public Tanh(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        Tanh(Tanh that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public Tanh transform(CopyContext cc, OpTransformer ot) {
            return new Tanh(this, cc);
        }
        
        Tanh(TypeElement resultType, Value input) {
            super(SCHEMA, resultType, Set.of(), List.of(input), List.of());
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(input()));
        }
        
        public Value input() {
            return operands().get(0);
        }
        
    }
    
    public static Tanh Tanh(TypeElement resultType, Value input) {
        return new Tanh(resultType, input);
    }

    @OpFactory.OpDeclaration(TfIdfVectorizer.NAME)
    public static final class TfIdfVectorizer extends OnnxOp {
        public static final String NAME = "TfIdfVectorizer";
        
        public enum Attribute implements OnnxAttribute {
            ngram_counts(int[].class, false, null),
            min_gram_length(Integer.class, false, null),
            pool_strings(String[].class, true, null),
            mode(String.class, false, null),
            max_gram_length(Integer.class, false, null),
            max_skip_count(Integer.class, false, null),
            pool_int64s(int[].class, true, null),
            weights(float[].class, true, null),
            ngram_indexes(int[].class, false, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<string>, tensor<int32>, tensor<int64>] */))),
            T1(new OnnxType.TypeVariable("T1", List.of(/* @@@ [tensor<float>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public TfIdfVectorizer(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        TfIdfVectorizer(TfIdfVectorizer that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public TfIdfVectorizer transform(CopyContext cc, OpTransformer ot) {
            return new TfIdfVectorizer(this, cc);
        }
        
        TfIdfVectorizer(TypeElement resultType, Value X, int[] ngram_counts, int min_gram_length, java.util.Optional<String[]> pool_strings, String mode, int max_gram_length, int max_skip_count, java.util.Optional<int[]> pool_int64s, java.util.Optional<float[]> weights, int[] ngram_indexes) {
            super(SCHEMA, resultType, Set.of(), List.of(X), List.of(ngram_counts, min_gram_length, pool_strings, mode, max_gram_length, max_skip_count, pool_int64s, weights, ngram_indexes));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X()));
        }
        
        public Value X() {
            return operands().get(0);
        }
        
        public int[] ngram_counts() {
            int[] ngram_counts = Attribute.ngram_counts.access(int[].class, onnxAttributes);
            return ngram_counts.clone();
        }
        
        public int min_gram_length() {
            int min_gram_length = Attribute.min_gram_length.access(int.class, onnxAttributes);
            return min_gram_length;
        }
        
        public java.util.Optional<String[]> pool_strings() {
            String[] pool_strings = Attribute.pool_strings.access(String[].class, onnxAttributes);
            return java.util.Optional.ofNullable(pool_strings).map(String[]::clone);
        }
        
        public String mode() {
            String mode = Attribute.mode.access(String.class, onnxAttributes);
            return mode;
        }
        
        public int max_gram_length() {
            int max_gram_length = Attribute.max_gram_length.access(int.class, onnxAttributes);
            return max_gram_length;
        }
        
        public int max_skip_count() {
            int max_skip_count = Attribute.max_skip_count.access(int.class, onnxAttributes);
            return max_skip_count;
        }
        
        public java.util.Optional<int[]> pool_int64s() {
            int[] pool_int64s = Attribute.pool_int64s.access(int[].class, onnxAttributes);
            return java.util.Optional.ofNullable(pool_int64s).map(int[]::clone);
        }
        
        public java.util.Optional<float[]> weights() {
            float[] weights = Attribute.weights.access(float[].class, onnxAttributes);
            return java.util.Optional.ofNullable(weights).map(float[]::clone);
        }
        
        public int[] ngram_indexes() {
            int[] ngram_indexes = Attribute.ngram_indexes.access(int[].class, onnxAttributes);
            return ngram_indexes.clone();
        }
        
    }
    
    public static TfIdfVectorizer TfIdfVectorizer(TypeElement resultType, Value X, int[] ngram_counts, int min_gram_length, java.util.Optional<String[]> pool_strings, String mode, int max_gram_length, int max_skip_count, java.util.Optional<int[]> pool_int64s, java.util.Optional<float[]> weights, int[] ngram_indexes) {
        return new TfIdfVectorizer(resultType, X, ngram_counts, min_gram_length, pool_strings, mode, max_gram_length, max_skip_count, pool_int64s, weights, ngram_indexes);
    }

    @OpFactory.OpDeclaration(ThresholdedRelu.NAME)
    public static final class ThresholdedRelu extends OnnxOp {
        public static final String NAME = "ThresholdedRelu";
        
        public enum Attribute implements OnnxAttribute {
            alpha(Float.class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<bfloat16>, tensor<float16>, tensor<float>, tensor<double>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public ThresholdedRelu(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        ThresholdedRelu(ThresholdedRelu that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public ThresholdedRelu transform(CopyContext cc, OpTransformer ot) {
            return new ThresholdedRelu(this, cc);
        }
        
        ThresholdedRelu(TypeElement resultType, Value X, java.util.Optional<Float> alpha) {
            super(SCHEMA, resultType, Set.of(), List.of(X), List.of(alpha));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X()));
        }
        
        public Value X() {
            return operands().get(0);
        }
        
        public java.util.Optional<Float> alpha() {
            Float alpha = Attribute.alpha.access(Float.class, onnxAttributes);
            return java.util.Optional.ofNullable(alpha);
        }
        
    }
    
    public static ThresholdedRelu ThresholdedRelu(TypeElement resultType, Value X, java.util.Optional<Float> alpha) {
        return new ThresholdedRelu(resultType, X, alpha);
    }

    @OpFactory.OpDeclaration(Tile.NAME)
    public static final class Tile extends OnnxOp {
        public static final String NAME = "Tile";
        
        public enum Attribute implements OnnxAttribute.None { }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<uint8>, tensor<uint16>, tensor<uint32>, tensor<uint64>, tensor<int8>, tensor<int16>, tensor<int32>, tensor<int64>, tensor<bfloat16>, tensor<float16>, tensor<float>, tensor<double>, tensor<string>, tensor<bool>, tensor<complex64>, tensor<complex128>] */))),
            T1(new OnnxType.TypeVariable("T1", List.of(/* @@@ [tensor<int64>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            input(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            repeats(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public Tile(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        Tile(Tile that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public Tile transform(CopyContext cc, OpTransformer ot) {
            return new Tile(this, cc);
        }
        
        Tile(TypeElement resultType, Value input, Value repeats) {
            super(SCHEMA, resultType, Set.of(), List.of(input, repeats), List.of());
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(input(), repeats()));
        }
        
        public Value input() {
            return operands().get(0);
        }
        
        public Value repeats() {
            return operands().get(1);
        }
        
    }
    
    public static Tile Tile(TypeElement resultType, Value input, Value repeats) {
        return new Tile(resultType, input, repeats);
    }

    @OpFactory.OpDeclaration(TopK.NAME)
    public static final class TopK extends OnnxOp {
        public static final String NAME = "TopK";
        
        public enum Attribute implements OnnxAttribute {
            largest(Integer.class, true, null),
            sorted(Integer.class, true, null),
            axis(Integer.class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<uint8>, tensor<uint16>, tensor<uint32>, tensor<uint64>, tensor<int8>, tensor<int16>, tensor<int32>, tensor<int64>, tensor<float16>, tensor<float>, tensor<double>] */))),
            I(new OnnxType.TypeVariable("I", List.of(/* @@@ [tensor<int64>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            K(null /* @@@ tensor<int64> */, Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            Values(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            Indices(TypeConstraint.I.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public TopK(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        TopK(TopK that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public TopK transform(CopyContext cc, OpTransformer ot) {
            return new TopK(this, cc);
        }
        
        TopK(TypeElement resultType, Value X, Value K, java.util.Optional<Integer> largest, java.util.Optional<Integer> sorted, java.util.Optional<Integer> axis) {
            super(SCHEMA, resultType, Set.of(), List.of(X, K), List.of(largest, sorted, axis));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X(), K()));
        }
        
        public Value X() {
            return operands().get(0);
        }
        
        public Value K() {
            return operands().get(1);
        }
        
        public java.util.Optional<Integer> largest() {
            Integer largest = Attribute.largest.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(largest);
        }
        
        public java.util.Optional<Integer> sorted() {
            Integer sorted = Attribute.sorted.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(sorted);
        }
        
        public java.util.Optional<Integer> axis() {
            Integer axis = Attribute.axis.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(axis);
        }
        
    }
    
    public static TopK TopK(TypeElement resultType, Value X, Value K, java.util.Optional<Integer> largest, java.util.Optional<Integer> sorted, java.util.Optional<Integer> axis) {
        return new TopK(resultType, X, K, largest, sorted, axis);
    }

    @OpFactory.OpDeclaration(Transpose.NAME)
    public static final class Transpose extends OnnxOp {
        public static final String NAME = "Transpose";
        
        public enum Attribute implements OnnxAttribute {
            perm(int[].class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<uint8>, tensor<uint16>, tensor<uint32>, tensor<uint64>, tensor<int8>, tensor<int16>, tensor<int32>, tensor<int64>, tensor<bfloat16>, tensor<float16>, tensor<float>, tensor<double>, tensor<string>, tensor<bool>, tensor<complex64>, tensor<complex128>, tensor<float8e4m3fn>, tensor<float8e4m3fnuz>, tensor<float8e5m2>, tensor<float8e5m2fnuz>, tensor<uint4>, tensor<int4>, tensor<float4e2m1>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            data(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            transposed(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public Transpose(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        Transpose(Transpose that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public Transpose transform(CopyContext cc, OpTransformer ot) {
            return new Transpose(this, cc);
        }
        
        Transpose(TypeElement resultType, Value data, java.util.Optional<int[]> perm) {
            super(SCHEMA, resultType, Set.of(), List.of(data), List.of(perm));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(data()));
        }
        
        public Value data() {
            return operands().get(0);
        }
        
        public java.util.Optional<int[]> perm() {
            int[] perm = Attribute.perm.access(int[].class, onnxAttributes);
            return java.util.Optional.ofNullable(perm).map(int[]::clone);
        }
        
    }
    
    public static Transpose Transpose(TypeElement resultType, Value data, java.util.Optional<int[]> perm) {
        return new Transpose(resultType, data, perm);
    }

    @OpFactory.OpDeclaration(TreeEnsemble.NAME)
    public static final class TreeEnsemble extends OnnxOp {
        public static final String NAME = "TreeEnsemble";
        
        public enum Attribute implements OnnxAttribute {
            aggregate_function(Integer.class, true, null),
            nodes_hitrates(Tensor.class, true, null),
            nodes_featureids(int[].class, false, null),
            nodes_falseleafs(int[].class, false, null),
            post_transform(Integer.class, true, null),
            nodes_trueleafs(int[].class, false, null),
            nodes_modes(Tensor.class, false, null),
            nodes_falsenodeids(int[].class, false, null),
            nodes_truenodeids(int[].class, false, null),
            leaf_weights(Tensor.class, false, null),
            leaf_targetids(int[].class, false, null),
            tree_roots(int[].class, false, null),
            n_targets(Integer.class, true, null),
            nodes_missing_value_tracks_true(int[].class, true, null),
            membership_values(Tensor.class, true, null),
            nodes_splits(Tensor.class, false, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<float>, tensor<double>, tensor<float16>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public TreeEnsemble(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        TreeEnsemble(TreeEnsemble that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public TreeEnsemble transform(CopyContext cc, OpTransformer ot) {
            return new TreeEnsemble(this, cc);
        }
        
        TreeEnsemble(TypeElement resultType, Value X, java.util.Optional<Integer> aggregate_function, java.util.Optional<Tensor<?>> nodes_hitrates, int[] nodes_featureids, int[] nodes_falseleafs, java.util.Optional<Integer> post_transform, int[] nodes_trueleafs, Tensor<?> nodes_modes, int[] nodes_falsenodeids, int[] nodes_truenodeids, Tensor<?> leaf_weights, int[] leaf_targetids, int[] tree_roots, java.util.Optional<Integer> n_targets, java.util.Optional<int[]> nodes_missing_value_tracks_true, java.util.Optional<Tensor<?>> membership_values, Tensor<?> nodes_splits) {
            super(SCHEMA, resultType, Set.of(), List.of(X), List.of(aggregate_function, nodes_hitrates, nodes_featureids, nodes_falseleafs, post_transform, nodes_trueleafs, nodes_modes, nodes_falsenodeids, nodes_truenodeids, leaf_weights, leaf_targetids, tree_roots, n_targets, nodes_missing_value_tracks_true, membership_values, nodes_splits));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X()));
        }
        
        public Value X() {
            return operands().get(0);
        }
        
        public java.util.Optional<Integer> aggregate_function() {
            Integer aggregate_function = Attribute.aggregate_function.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(aggregate_function);
        }
        
        public java.util.Optional<Tensor<?>> nodes_hitrates() {
            Tensor<?> nodes_hitrates = Attribute.nodes_hitrates.access(Tensor.class, onnxAttributes);
            return java.util.Optional.ofNullable(nodes_hitrates);
        }
        
        public int[] nodes_featureids() {
            int[] nodes_featureids = Attribute.nodes_featureids.access(int[].class, onnxAttributes);
            return nodes_featureids.clone();
        }
        
        public int[] nodes_falseleafs() {
            int[] nodes_falseleafs = Attribute.nodes_falseleafs.access(int[].class, onnxAttributes);
            return nodes_falseleafs.clone();
        }
        
        public java.util.Optional<Integer> post_transform() {
            Integer post_transform = Attribute.post_transform.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(post_transform);
        }
        
        public int[] nodes_trueleafs() {
            int[] nodes_trueleafs = Attribute.nodes_trueleafs.access(int[].class, onnxAttributes);
            return nodes_trueleafs.clone();
        }
        
        public Tensor<?> nodes_modes() {
            Tensor<?> nodes_modes = Attribute.nodes_modes.access(Tensor.class, onnxAttributes);
            return nodes_modes;
        }
        
        public int[] nodes_falsenodeids() {
            int[] nodes_falsenodeids = Attribute.nodes_falsenodeids.access(int[].class, onnxAttributes);
            return nodes_falsenodeids.clone();
        }
        
        public int[] nodes_truenodeids() {
            int[] nodes_truenodeids = Attribute.nodes_truenodeids.access(int[].class, onnxAttributes);
            return nodes_truenodeids.clone();
        }
        
        public Tensor<?> leaf_weights() {
            Tensor<?> leaf_weights = Attribute.leaf_weights.access(Tensor.class, onnxAttributes);
            return leaf_weights;
        }
        
        public int[] leaf_targetids() {
            int[] leaf_targetids = Attribute.leaf_targetids.access(int[].class, onnxAttributes);
            return leaf_targetids.clone();
        }
        
        public int[] tree_roots() {
            int[] tree_roots = Attribute.tree_roots.access(int[].class, onnxAttributes);
            return tree_roots.clone();
        }
        
        public java.util.Optional<Integer> n_targets() {
            Integer n_targets = Attribute.n_targets.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(n_targets);
        }
        
        public java.util.Optional<int[]> nodes_missing_value_tracks_true() {
            int[] nodes_missing_value_tracks_true = Attribute.nodes_missing_value_tracks_true.access(int[].class, onnxAttributes);
            return java.util.Optional.ofNullable(nodes_missing_value_tracks_true).map(int[]::clone);
        }
        
        public java.util.Optional<Tensor<?>> membership_values() {
            Tensor<?> membership_values = Attribute.membership_values.access(Tensor.class, onnxAttributes);
            return java.util.Optional.ofNullable(membership_values);
        }
        
        public Tensor<?> nodes_splits() {
            Tensor<?> nodes_splits = Attribute.nodes_splits.access(Tensor.class, onnxAttributes);
            return nodes_splits;
        }
        
    }
    
    public static TreeEnsemble TreeEnsemble(TypeElement resultType, Value X, java.util.Optional<Integer> aggregate_function, java.util.Optional<Tensor<?>> nodes_hitrates, int[] nodes_featureids, int[] nodes_falseleafs, java.util.Optional<Integer> post_transform, int[] nodes_trueleafs, Tensor<?> nodes_modes, int[] nodes_falsenodeids, int[] nodes_truenodeids, Tensor<?> leaf_weights, int[] leaf_targetids, int[] tree_roots, java.util.Optional<Integer> n_targets, java.util.Optional<int[]> nodes_missing_value_tracks_true, java.util.Optional<Tensor<?>> membership_values, Tensor<?> nodes_splits) {
        return new TreeEnsemble(resultType, X, aggregate_function, nodes_hitrates, nodes_featureids, nodes_falseleafs, post_transform, nodes_trueleafs, nodes_modes, nodes_falsenodeids, nodes_truenodeids, leaf_weights, leaf_targetids, tree_roots, n_targets, nodes_missing_value_tracks_true, membership_values, nodes_splits);
    }

    @OpFactory.OpDeclaration(TreeEnsembleClassifier.NAME)
    public static final class TreeEnsembleClassifier extends OnnxOp {
        public static final String NAME = "TreeEnsembleClassifier";
        
        public enum Attribute implements OnnxAttribute {
            classlabels_int64s(int[].class, true, null),
            class_ids(int[].class, true, null),
            nodes_hitrates(float[].class, true, null),
            nodes_featureids(int[].class, true, null),
            nodes_treeids(int[].class, true, null),
            class_weights_as_tensor(Tensor.class, true, null),
            post_transform(String.class, true, null),
            nodes_modes(String[].class, true, null),
            nodes_falsenodeids(int[].class, true, null),
            classlabels_strings(String[].class, true, null),
            nodes_truenodeids(int[].class, true, null),
            nodes_nodeids(int[].class, true, null),
            nodes_hitrates_as_tensor(Tensor.class, true, null),
            class_weights(float[].class, true, null),
            base_values_as_tensor(Tensor.class, true, null),
            nodes_missing_value_tracks_true(int[].class, true, null),
            class_nodeids(int[].class, true, null),
            class_treeids(int[].class, true, null),
            base_values(float[].class, true, null),
            nodes_values(float[].class, true, null),
            nodes_values_as_tensor(Tensor.class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T1(new OnnxType.TypeVariable("T1", List.of(/* @@@ [tensor<float>, tensor<double>, tensor<int64>, tensor<int32>] */))),
            T2(new OnnxType.TypeVariable("T2", List.of(/* @@@ [tensor<string>, tensor<int64>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),
            Z(null /* @@@ tensor<float> */, Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public TreeEnsembleClassifier(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        TreeEnsembleClassifier(TreeEnsembleClassifier that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public TreeEnsembleClassifier transform(CopyContext cc, OpTransformer ot) {
            return new TreeEnsembleClassifier(this, cc);
        }
        
        TreeEnsembleClassifier(TypeElement resultType, Value X, java.util.Optional<int[]> classlabels_int64s, java.util.Optional<int[]> class_ids, java.util.Optional<float[]> nodes_hitrates, java.util.Optional<int[]> nodes_featureids, java.util.Optional<int[]> nodes_treeids, java.util.Optional<Tensor<?>> class_weights_as_tensor, java.util.Optional<String> post_transform, java.util.Optional<String[]> nodes_modes, java.util.Optional<int[]> nodes_falsenodeids, java.util.Optional<String[]> classlabels_strings, java.util.Optional<int[]> nodes_truenodeids, java.util.Optional<int[]> nodes_nodeids, java.util.Optional<Tensor<?>> nodes_hitrates_as_tensor, java.util.Optional<float[]> class_weights, java.util.Optional<Tensor<?>> base_values_as_tensor, java.util.Optional<int[]> nodes_missing_value_tracks_true, java.util.Optional<int[]> class_nodeids, java.util.Optional<int[]> class_treeids, java.util.Optional<float[]> base_values, java.util.Optional<float[]> nodes_values, java.util.Optional<Tensor<?>> nodes_values_as_tensor) {
            super(SCHEMA, resultType, Set.of(), List.of(X), List.of(classlabels_int64s, class_ids, nodes_hitrates, nodes_featureids, nodes_treeids, class_weights_as_tensor, post_transform, nodes_modes, nodes_falsenodeids, classlabels_strings, nodes_truenodeids, nodes_nodeids, nodes_hitrates_as_tensor, class_weights, base_values_as_tensor, nodes_missing_value_tracks_true, class_nodeids, class_treeids, base_values, nodes_values, nodes_values_as_tensor));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X()));
        }
        
        public Value X() {
            return operands().get(0);
        }
        
        public java.util.Optional<int[]> classlabels_int64s() {
            int[] classlabels_int64s = Attribute.classlabels_int64s.access(int[].class, onnxAttributes);
            return java.util.Optional.ofNullable(classlabels_int64s).map(int[]::clone);
        }
        
        public java.util.Optional<int[]> class_ids() {
            int[] class_ids = Attribute.class_ids.access(int[].class, onnxAttributes);
            return java.util.Optional.ofNullable(class_ids).map(int[]::clone);
        }
        
        public java.util.Optional<float[]> nodes_hitrates() {
            float[] nodes_hitrates = Attribute.nodes_hitrates.access(float[].class, onnxAttributes);
            return java.util.Optional.ofNullable(nodes_hitrates).map(float[]::clone);
        }
        
        public java.util.Optional<int[]> nodes_featureids() {
            int[] nodes_featureids = Attribute.nodes_featureids.access(int[].class, onnxAttributes);
            return java.util.Optional.ofNullable(nodes_featureids).map(int[]::clone);
        }
        
        public java.util.Optional<int[]> nodes_treeids() {
            int[] nodes_treeids = Attribute.nodes_treeids.access(int[].class, onnxAttributes);
            return java.util.Optional.ofNullable(nodes_treeids).map(int[]::clone);
        }
        
        public java.util.Optional<Tensor<?>> class_weights_as_tensor() {
            Tensor<?> class_weights_as_tensor = Attribute.class_weights_as_tensor.access(Tensor.class, onnxAttributes);
            return java.util.Optional.ofNullable(class_weights_as_tensor);
        }
        
        public java.util.Optional<String> post_transform() {
            String post_transform = Attribute.post_transform.access(String.class, onnxAttributes);
            return java.util.Optional.ofNullable(post_transform);
        }
        
        public java.util.Optional<String[]> nodes_modes() {
            String[] nodes_modes = Attribute.nodes_modes.access(String[].class, onnxAttributes);
            return java.util.Optional.ofNullable(nodes_modes).map(String[]::clone);
        }
        
        public java.util.Optional<int[]> nodes_falsenodeids() {
            int[] nodes_falsenodeids = Attribute.nodes_falsenodeids.access(int[].class, onnxAttributes);
            return java.util.Optional.ofNullable(nodes_falsenodeids).map(int[]::clone);
        }
        
        public java.util.Optional<String[]> classlabels_strings() {
            String[] classlabels_strings = Attribute.classlabels_strings.access(String[].class, onnxAttributes);
            return java.util.Optional.ofNullable(classlabels_strings).map(String[]::clone);
        }
        
        public java.util.Optional<int[]> nodes_truenodeids() {
            int[] nodes_truenodeids = Attribute.nodes_truenodeids.access(int[].class, onnxAttributes);
            return java.util.Optional.ofNullable(nodes_truenodeids).map(int[]::clone);
        }
        
        public java.util.Optional<int[]> nodes_nodeids() {
            int[] nodes_nodeids = Attribute.nodes_nodeids.access(int[].class, onnxAttributes);
            return java.util.Optional.ofNullable(nodes_nodeids).map(int[]::clone);
        }
        
        public java.util.Optional<Tensor<?>> nodes_hitrates_as_tensor() {
            Tensor<?> nodes_hitrates_as_tensor = Attribute.nodes_hitrates_as_tensor.access(Tensor.class, onnxAttributes);
            return java.util.Optional.ofNullable(nodes_hitrates_as_tensor);
        }
        
        public java.util.Optional<float[]> class_weights() {
            float[] class_weights = Attribute.class_weights.access(float[].class, onnxAttributes);
            return java.util.Optional.ofNullable(class_weights).map(float[]::clone);
        }
        
        public java.util.Optional<Tensor<?>> base_values_as_tensor() {
            Tensor<?> base_values_as_tensor = Attribute.base_values_as_tensor.access(Tensor.class, onnxAttributes);
            return java.util.Optional.ofNullable(base_values_as_tensor);
        }
        
        public java.util.Optional<int[]> nodes_missing_value_tracks_true() {
            int[] nodes_missing_value_tracks_true = Attribute.nodes_missing_value_tracks_true.access(int[].class, onnxAttributes);
            return java.util.Optional.ofNullable(nodes_missing_value_tracks_true).map(int[]::clone);
        }
        
        public java.util.Optional<int[]> class_nodeids() {
            int[] class_nodeids = Attribute.class_nodeids.access(int[].class, onnxAttributes);
            return java.util.Optional.ofNullable(class_nodeids).map(int[]::clone);
        }
        
        public java.util.Optional<int[]> class_treeids() {
            int[] class_treeids = Attribute.class_treeids.access(int[].class, onnxAttributes);
            return java.util.Optional.ofNullable(class_treeids).map(int[]::clone);
        }
        
        public java.util.Optional<float[]> base_values() {
            float[] base_values = Attribute.base_values.access(float[].class, onnxAttributes);
            return java.util.Optional.ofNullable(base_values).map(float[]::clone);
        }
        
        public java.util.Optional<float[]> nodes_values() {
            float[] nodes_values = Attribute.nodes_values.access(float[].class, onnxAttributes);
            return java.util.Optional.ofNullable(nodes_values).map(float[]::clone);
        }
        
        public java.util.Optional<Tensor<?>> nodes_values_as_tensor() {
            Tensor<?> nodes_values_as_tensor = Attribute.nodes_values_as_tensor.access(Tensor.class, onnxAttributes);
            return java.util.Optional.ofNullable(nodes_values_as_tensor);
        }
        
    }
    
    public static TreeEnsembleClassifier TreeEnsembleClassifier(TypeElement resultType, Value X, java.util.Optional<int[]> classlabels_int64s, java.util.Optional<int[]> class_ids, java.util.Optional<float[]> nodes_hitrates, java.util.Optional<int[]> nodes_featureids, java.util.Optional<int[]> nodes_treeids, java.util.Optional<Tensor<?>> class_weights_as_tensor, java.util.Optional<String> post_transform, java.util.Optional<String[]> nodes_modes, java.util.Optional<int[]> nodes_falsenodeids, java.util.Optional<String[]> classlabels_strings, java.util.Optional<int[]> nodes_truenodeids, java.util.Optional<int[]> nodes_nodeids, java.util.Optional<Tensor<?>> nodes_hitrates_as_tensor, java.util.Optional<float[]> class_weights, java.util.Optional<Tensor<?>> base_values_as_tensor, java.util.Optional<int[]> nodes_missing_value_tracks_true, java.util.Optional<int[]> class_nodeids, java.util.Optional<int[]> class_treeids, java.util.Optional<float[]> base_values, java.util.Optional<float[]> nodes_values, java.util.Optional<Tensor<?>> nodes_values_as_tensor) {
        return new TreeEnsembleClassifier(resultType, X, classlabels_int64s, class_ids, nodes_hitrates, nodes_featureids, nodes_treeids, class_weights_as_tensor, post_transform, nodes_modes, nodes_falsenodeids, classlabels_strings, nodes_truenodeids, nodes_nodeids, nodes_hitrates_as_tensor, class_weights, base_values_as_tensor, nodes_missing_value_tracks_true, class_nodeids, class_treeids, base_values, nodes_values, nodes_values_as_tensor);
    }

    @OpFactory.OpDeclaration(TreeEnsembleRegressor.NAME)
    public static final class TreeEnsembleRegressor extends OnnxOp {
        public static final String NAME = "TreeEnsembleRegressor";
        
        public enum Attribute implements OnnxAttribute {
            aggregate_function(String.class, true, null),
            nodes_hitrates(float[].class, true, null),
            target_weights_as_tensor(Tensor.class, true, null),
            nodes_featureids(int[].class, true, null),
            target_treeids(int[].class, true, null),
            nodes_treeids(int[].class, true, null),
            post_transform(String.class, true, null),
            nodes_modes(String[].class, true, null),
            target_weights(float[].class, true, null),
            nodes_falsenodeids(int[].class, true, null),
            target_ids(int[].class, true, null),
            nodes_truenodeids(int[].class, true, null),
            target_nodeids(int[].class, true, null),
            nodes_nodeids(int[].class, true, null),
            nodes_hitrates_as_tensor(Tensor.class, true, null),
            base_values_as_tensor(Tensor.class, true, null),
            n_targets(Integer.class, true, null),
            nodes_missing_value_tracks_true(int[].class, true, null),
            base_values(float[].class, true, null),
            nodes_values(float[].class, true, null),
            nodes_values_as_tensor(Tensor.class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<float>, tensor<double>, tensor<int64>, tensor<int32>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            Y(null /* @@@ tensor<float> */, Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public TreeEnsembleRegressor(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        TreeEnsembleRegressor(TreeEnsembleRegressor that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public TreeEnsembleRegressor transform(CopyContext cc, OpTransformer ot) {
            return new TreeEnsembleRegressor(this, cc);
        }
        
        TreeEnsembleRegressor(TypeElement resultType, Value X, java.util.Optional<String> aggregate_function, java.util.Optional<float[]> nodes_hitrates, java.util.Optional<Tensor<?>> target_weights_as_tensor, java.util.Optional<int[]> nodes_featureids, java.util.Optional<int[]> target_treeids, java.util.Optional<int[]> nodes_treeids, java.util.Optional<String> post_transform, java.util.Optional<String[]> nodes_modes, java.util.Optional<float[]> target_weights, java.util.Optional<int[]> nodes_falsenodeids, java.util.Optional<int[]> target_ids, java.util.Optional<int[]> nodes_truenodeids, java.util.Optional<int[]> target_nodeids, java.util.Optional<int[]> nodes_nodeids, java.util.Optional<Tensor<?>> nodes_hitrates_as_tensor, java.util.Optional<Tensor<?>> base_values_as_tensor, java.util.Optional<Integer> n_targets, java.util.Optional<int[]> nodes_missing_value_tracks_true, java.util.Optional<float[]> base_values, java.util.Optional<float[]> nodes_values, java.util.Optional<Tensor<?>> nodes_values_as_tensor) {
            super(SCHEMA, resultType, Set.of(), List.of(X), List.of(aggregate_function, nodes_hitrates, target_weights_as_tensor, nodes_featureids, target_treeids, nodes_treeids, post_transform, nodes_modes, target_weights, nodes_falsenodeids, target_ids, nodes_truenodeids, target_nodeids, nodes_nodeids, nodes_hitrates_as_tensor, base_values_as_tensor, n_targets, nodes_missing_value_tracks_true, base_values, nodes_values, nodes_values_as_tensor));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X()));
        }
        
        public Value X() {
            return operands().get(0);
        }
        
        public java.util.Optional<String> aggregate_function() {
            String aggregate_function = Attribute.aggregate_function.access(String.class, onnxAttributes);
            return java.util.Optional.ofNullable(aggregate_function);
        }
        
        public java.util.Optional<float[]> nodes_hitrates() {
            float[] nodes_hitrates = Attribute.nodes_hitrates.access(float[].class, onnxAttributes);
            return java.util.Optional.ofNullable(nodes_hitrates).map(float[]::clone);
        }
        
        public java.util.Optional<Tensor<?>> target_weights_as_tensor() {
            Tensor<?> target_weights_as_tensor = Attribute.target_weights_as_tensor.access(Tensor.class, onnxAttributes);
            return java.util.Optional.ofNullable(target_weights_as_tensor);
        }
        
        public java.util.Optional<int[]> nodes_featureids() {
            int[] nodes_featureids = Attribute.nodes_featureids.access(int[].class, onnxAttributes);
            return java.util.Optional.ofNullable(nodes_featureids).map(int[]::clone);
        }
        
        public java.util.Optional<int[]> target_treeids() {
            int[] target_treeids = Attribute.target_treeids.access(int[].class, onnxAttributes);
            return java.util.Optional.ofNullable(target_treeids).map(int[]::clone);
        }
        
        public java.util.Optional<int[]> nodes_treeids() {
            int[] nodes_treeids = Attribute.nodes_treeids.access(int[].class, onnxAttributes);
            return java.util.Optional.ofNullable(nodes_treeids).map(int[]::clone);
        }
        
        public java.util.Optional<String> post_transform() {
            String post_transform = Attribute.post_transform.access(String.class, onnxAttributes);
            return java.util.Optional.ofNullable(post_transform);
        }
        
        public java.util.Optional<String[]> nodes_modes() {
            String[] nodes_modes = Attribute.nodes_modes.access(String[].class, onnxAttributes);
            return java.util.Optional.ofNullable(nodes_modes).map(String[]::clone);
        }
        
        public java.util.Optional<float[]> target_weights() {
            float[] target_weights = Attribute.target_weights.access(float[].class, onnxAttributes);
            return java.util.Optional.ofNullable(target_weights).map(float[]::clone);
        }
        
        public java.util.Optional<int[]> nodes_falsenodeids() {
            int[] nodes_falsenodeids = Attribute.nodes_falsenodeids.access(int[].class, onnxAttributes);
            return java.util.Optional.ofNullable(nodes_falsenodeids).map(int[]::clone);
        }
        
        public java.util.Optional<int[]> target_ids() {
            int[] target_ids = Attribute.target_ids.access(int[].class, onnxAttributes);
            return java.util.Optional.ofNullable(target_ids).map(int[]::clone);
        }
        
        public java.util.Optional<int[]> nodes_truenodeids() {
            int[] nodes_truenodeids = Attribute.nodes_truenodeids.access(int[].class, onnxAttributes);
            return java.util.Optional.ofNullable(nodes_truenodeids).map(int[]::clone);
        }
        
        public java.util.Optional<int[]> target_nodeids() {
            int[] target_nodeids = Attribute.target_nodeids.access(int[].class, onnxAttributes);
            return java.util.Optional.ofNullable(target_nodeids).map(int[]::clone);
        }
        
        public java.util.Optional<int[]> nodes_nodeids() {
            int[] nodes_nodeids = Attribute.nodes_nodeids.access(int[].class, onnxAttributes);
            return java.util.Optional.ofNullable(nodes_nodeids).map(int[]::clone);
        }
        
        public java.util.Optional<Tensor<?>> nodes_hitrates_as_tensor() {
            Tensor<?> nodes_hitrates_as_tensor = Attribute.nodes_hitrates_as_tensor.access(Tensor.class, onnxAttributes);
            return java.util.Optional.ofNullable(nodes_hitrates_as_tensor);
        }
        
        public java.util.Optional<Tensor<?>> base_values_as_tensor() {
            Tensor<?> base_values_as_tensor = Attribute.base_values_as_tensor.access(Tensor.class, onnxAttributes);
            return java.util.Optional.ofNullable(base_values_as_tensor);
        }
        
        public java.util.Optional<Integer> n_targets() {
            Integer n_targets = Attribute.n_targets.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(n_targets);
        }
        
        public java.util.Optional<int[]> nodes_missing_value_tracks_true() {
            int[] nodes_missing_value_tracks_true = Attribute.nodes_missing_value_tracks_true.access(int[].class, onnxAttributes);
            return java.util.Optional.ofNullable(nodes_missing_value_tracks_true).map(int[]::clone);
        }
        
        public java.util.Optional<float[]> base_values() {
            float[] base_values = Attribute.base_values.access(float[].class, onnxAttributes);
            return java.util.Optional.ofNullable(base_values).map(float[]::clone);
        }
        
        public java.util.Optional<float[]> nodes_values() {
            float[] nodes_values = Attribute.nodes_values.access(float[].class, onnxAttributes);
            return java.util.Optional.ofNullable(nodes_values).map(float[]::clone);
        }
        
        public java.util.Optional<Tensor<?>> nodes_values_as_tensor() {
            Tensor<?> nodes_values_as_tensor = Attribute.nodes_values_as_tensor.access(Tensor.class, onnxAttributes);
            return java.util.Optional.ofNullable(nodes_values_as_tensor);
        }
        
    }
    
    public static TreeEnsembleRegressor TreeEnsembleRegressor(TypeElement resultType, Value X, java.util.Optional<String> aggregate_function, java.util.Optional<float[]> nodes_hitrates, java.util.Optional<Tensor<?>> target_weights_as_tensor, java.util.Optional<int[]> nodes_featureids, java.util.Optional<int[]> target_treeids, java.util.Optional<int[]> nodes_treeids, java.util.Optional<String> post_transform, java.util.Optional<String[]> nodes_modes, java.util.Optional<float[]> target_weights, java.util.Optional<int[]> nodes_falsenodeids, java.util.Optional<int[]> target_ids, java.util.Optional<int[]> nodes_truenodeids, java.util.Optional<int[]> target_nodeids, java.util.Optional<int[]> nodes_nodeids, java.util.Optional<Tensor<?>> nodes_hitrates_as_tensor, java.util.Optional<Tensor<?>> base_values_as_tensor, java.util.Optional<Integer> n_targets, java.util.Optional<int[]> nodes_missing_value_tracks_true, java.util.Optional<float[]> base_values, java.util.Optional<float[]> nodes_values, java.util.Optional<Tensor<?>> nodes_values_as_tensor) {
        return new TreeEnsembleRegressor(resultType, X, aggregate_function, nodes_hitrates, target_weights_as_tensor, nodes_featureids, target_treeids, nodes_treeids, post_transform, nodes_modes, target_weights, nodes_falsenodeids, target_ids, nodes_truenodeids, target_nodeids, nodes_nodeids, nodes_hitrates_as_tensor, base_values_as_tensor, n_targets, nodes_missing_value_tracks_true, base_values, nodes_values, nodes_values_as_tensor);
    }

    @OpFactory.OpDeclaration(Trilu.NAME)
    public static final class Trilu extends OnnxOp {
        public static final String NAME = "Trilu";
        
        public enum Attribute implements OnnxAttribute {
            upper(Integer.class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<uint8>, tensor<uint16>, tensor<uint32>, tensor<uint64>, tensor<int8>, tensor<int16>, tensor<int32>, tensor<int64>, tensor<bfloat16>, tensor<float16>, tensor<float>, tensor<double>, tensor<string>, tensor<bool>, tensor<complex64>, tensor<complex128>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            input(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            k(null /* @@@ tensor<int64> */, Quantifier.OPTIONAL),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public Trilu(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        Trilu(Trilu that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public Trilu transform(CopyContext cc, OpTransformer ot) {
            return new Trilu(this, cc);
        }
        
        Trilu(TypeElement resultType, Value input, java.util.Optional<Value> k, java.util.Optional<Integer> upper) {
            super(SCHEMA, resultType, Set.of(), List.of(input, k), List.of(upper));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(input(), k()));
        }
        
        public Value input() {
            return operands().get(0);
        }
        
        public java.util.Optional<Value> k() {
            int i = optionalInputArguments.indexOf(InputParameter.k);
            return i != -1 ? java.util.Optional.of(operands().get(1 + i)) : java.util.Optional.empty();
        }
        
        public java.util.Optional<Integer> upper() {
            Integer upper = Attribute.upper.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(upper);
        }
        
    }
    
    public static Trilu Trilu(TypeElement resultType, Value input, java.util.Optional<Value> k, java.util.Optional<Integer> upper) {
        return new Trilu(resultType, input, k, upper);
    }

    @OpFactory.OpDeclaration(Unique.NAME)
    public static final class Unique extends OnnxOp {
        public static final String NAME = "Unique";
        
        public enum Attribute implements OnnxAttribute {
            sorted(Integer.class, true, null),
            axis(Integer.class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<uint8>, tensor<uint16>, tensor<uint32>, tensor<uint64>, tensor<int8>, tensor<int16>, tensor<int32>, tensor<int64>, tensor<float16>, tensor<float>, tensor<double>, tensor<string>, tensor<bool>, tensor<complex64>, tensor<complex128>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            indices(null /* @@@ tensor<int64> */, Quantifier.OPTIONAL),
            inverse_indices(null /* @@@ tensor<int64> */, Quantifier.OPTIONAL),
            counts(null /* @@@ tensor<int64> */, Quantifier.OPTIONAL),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public Unique(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        Unique(Unique that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public Unique transform(CopyContext cc, OpTransformer ot) {
            return new Unique(this, cc);
        }
        
        Unique(TypeElement resultType, Value X, java.util.Optional<Integer> sorted, java.util.Optional<Integer> axis) {
            super(SCHEMA, resultType, Set.of(), List.of(X), List.of(sorted, axis));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X()));
        }
        
        public Value X() {
            return operands().get(0);
        }
        
        public java.util.Optional<Integer> sorted() {
            Integer sorted = Attribute.sorted.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(sorted);
        }
        
        public java.util.Optional<Integer> axis() {
            Integer axis = Attribute.axis.access(Integer.class, onnxAttributes);
            return java.util.Optional.ofNullable(axis);
        }
        
    }
    
    public static Unique Unique(TypeElement resultType, Value X, java.util.Optional<Integer> sorted, java.util.Optional<Integer> axis) {
        return new Unique(resultType, X, sorted, axis);
    }

    @OpFactory.OpDeclaration(Unsqueeze.NAME)
    public static final class Unsqueeze extends OnnxOp {
        public static final String NAME = "Unsqueeze";
        
        public enum Attribute implements OnnxAttribute.None { }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<uint8>, tensor<uint16>, tensor<uint32>, tensor<uint64>, tensor<int8>, tensor<int16>, tensor<int32>, tensor<int64>, tensor<bfloat16>, tensor<float16>, tensor<float>, tensor<double>, tensor<string>, tensor<bool>, tensor<complex64>, tensor<complex128>, tensor<float8e4m3fn>, tensor<float8e4m3fnuz>, tensor<float8e5m2>, tensor<float8e5m2fnuz>, tensor<uint4>, tensor<int4>, tensor<float4e2m1>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            data(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            axes(null /* @@@ tensor<int64> */, Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            expanded(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public Unsqueeze(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        Unsqueeze(Unsqueeze that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public Unsqueeze transform(CopyContext cc, OpTransformer ot) {
            return new Unsqueeze(this, cc);
        }
        
        Unsqueeze(TypeElement resultType, Value data, Value axes) {
            super(SCHEMA, resultType, Set.of(), List.of(data, axes), List.of());
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(data(), axes()));
        }
        
        public Value data() {
            return operands().get(0);
        }
        
        public Value axes() {
            return operands().get(1);
        }
        
    }
    
    public static Unsqueeze Unsqueeze(TypeElement resultType, Value data, Value axes) {
        return new Unsqueeze(resultType, data, axes);
    }

    @OpFactory.OpDeclaration(Upsample.NAME)
    public static final class Upsample extends OnnxOp {
        public static final String NAME = "Upsample";
        
        public enum Attribute implements OnnxAttribute {
            mode(String.class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<uint8>, tensor<uint16>, tensor<uint32>, tensor<uint64>, tensor<int8>, tensor<int16>, tensor<int32>, tensor<int64>, tensor<float16>, tensor<float>, tensor<double>, tensor<string>, tensor<bool>, tensor<complex64>, tensor<complex128>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            scales(null /* @@@ tensor<float> */, Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public Upsample(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        Upsample(Upsample that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public Upsample transform(CopyContext cc, OpTransformer ot) {
            return new Upsample(this, cc);
        }
        
        Upsample(TypeElement resultType, Value X, Value scales, java.util.Optional<String> mode) {
            super(SCHEMA, resultType, Set.of(), List.of(X, scales), List.of(mode));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X(), scales()));
        }
        
        public Value X() {
            return operands().get(0);
        }
        
        public Value scales() {
            return operands().get(1);
        }
        
        public java.util.Optional<String> mode() {
            String mode = Attribute.mode.access(String.class, onnxAttributes);
            return java.util.Optional.ofNullable(mode);
        }
        
    }
    
    public static Upsample Upsample(TypeElement resultType, Value X, Value scales, java.util.Optional<String> mode) {
        return new Upsample(resultType, X, scales, mode);
    }

    @OpFactory.OpDeclaration(Where.NAME)
    public static final class Where extends OnnxOp {
        public static final String NAME = "Where";
        
        public enum Attribute implements OnnxAttribute.None { }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            B(new OnnxType.TypeVariable("B", List.of(/* @@@ [tensor<bool>] */))),
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<uint8>, tensor<uint16>, tensor<uint32>, tensor<uint64>, tensor<int8>, tensor<int16>, tensor<int32>, tensor<int64>, tensor<bfloat16>, tensor<float16>, tensor<float>, tensor<double>, tensor<string>, tensor<bool>, tensor<complex64>, tensor<complex128>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            condition(TypeConstraint.B.typeVariable(), Quantifier.REQUIRED),
            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            output(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public Where(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        Where(Where that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public Where transform(CopyContext cc, OpTransformer ot) {
            return new Where(this, cc);
        }
        
        Where(TypeElement resultType, Value condition, Value X, Value Y) {
            super(SCHEMA, resultType, Set.of(), List.of(condition, X, Y), List.of());
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(condition(), X(), Y()));
        }
        
        public Value condition() {
            return operands().get(0);
        }
        
        public Value X() {
            return operands().get(1);
        }
        
        public Value Y() {
            return operands().get(2);
        }
        
    }
    
    public static Where Where(TypeElement resultType, Value condition, Value X, Value Y) {
        return new Where(resultType, condition, X, Y);
    }

    @OpFactory.OpDeclaration(Xor.NAME)
    public static final class Xor extends OnnxOp {
        public static final String NAME = "Xor";
        
        public enum Attribute implements OnnxAttribute.None { }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [tensor<bool>] */))),
            T1(new OnnxType.TypeVariable("T1", List.of(/* @@@ [tensor<bool>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            A(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            B(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            C(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public Xor(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        Xor(Xor that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public Xor transform(CopyContext cc, OpTransformer ot) {
            return new Xor(this, cc);
        }
        
        Xor(TypeElement resultType, Value A, Value B) {
            super(SCHEMA, resultType, Set.of(), List.of(A, B), List.of());
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(A(), B()));
        }
        
        public Value A() {
            return operands().get(0);
        }
        
        public Value B() {
            return operands().get(1);
        }
        
    }
    
    public static Xor Xor(TypeElement resultType, Value A, Value B) {
        return new Xor(resultType, A, B);
    }

    @OpFactory.OpDeclaration(ZipMap.NAME)
    public static final class ZipMap extends OnnxOp {
        public static final String NAME = "ZipMap";
        
        public enum Attribute implements OnnxAttribute {
            classlabels_int64s(int[].class, true, null),
            classlabels_strings(String[].class, true, null),
            ;
            
                final Class<?> t;
                final boolean optional;
                final Object defaultValue;
            
                Attribute(Class<?> type, boolean optional, Object defaultValue) {
                    this.t = type;
                    this.optional = optional;
                    this.defaultValue = defaultValue;
                    assert optional || defaultValue == null;
                }
            
                public Class<?> type() {
                    return t;
                }
            
                public boolean isOptional() {
                    return optional;
                }
            
                public Object defaultValue() {
                    return defaultValue;
                }
        }
        
        public enum TypeConstraint implements OnnxTypeConstraint {
            T(new OnnxType.TypeVariable("T", List.of(/* @@@ [seq<map<string, float>>, seq<map<int64, float>>] */))),
            ;
            
            final OnnxType.TypeVariable typeVariable;
            
            TypeConstraint(OnnxType.TypeVariable typeVariable) {
                assert typeVariable.name().equals(name());
                this.typeVariable = typeVariable;
            }
            
            @Override
            public OnnxType.TypeVariable typeVariable() {
                return typeVariable;
            }
        }
        
        public enum InputParameter implements OnnxParameter {
            X(null /* @@@ tensor<float> */, Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            InputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public enum OutputParameter implements OnnxParameter {
            Z(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),
            ;
            
            final OnnxType type;
            final Quantifier quantifier;
            
            OutputParameter(OnnxType type, Quantifier quantifier) {
                this.type = type;
                this.quantifier = quantifier;
            }
            
            @Override
            public OnnxType type() {
                return type;
            }
            
            @Override
            public Quantifier quantifier() {
                return quantifier;
            }
        }
        
        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(
                NAME,
                List.of(Attribute.values()),
                List.of(TypeConstraint.values()),
                List.of(InputParameter.values()),
                List.of(OutputParameter.values())
        );
        
        public ZipMap(ExternalizedOp def) {
            super(SCHEMA, def);
        }
        
        ZipMap(ZipMap that, CopyContext cc) {
            super(that, cc);
        }
        
        @Override
        public ZipMap transform(CopyContext cc, OpTransformer ot) {
            return new ZipMap(this, cc);
        }
        
        ZipMap(TypeElement resultType, Value X, java.util.Optional<int[]> classlabels_int64s, java.util.Optional<String[]> classlabels_strings) {
            super(SCHEMA, resultType, Set.of(), List.of(X), List.of(classlabels_int64s, classlabels_strings));
        }
        
        @Override
        public SequencedSet<OnnxParameter> onnxOutputs() {
            return onnxOutputs(SCHEMA);
        }
        
        @Override
        public SequencedMap<OnnxParameter, Object> onnxInputs() {
            return onnxInputs(SCHEMA, List.of(X()));
        }
        
        public Value X() {
            return operands().get(0);
        }
        
        public java.util.Optional<int[]> classlabels_int64s() {
            int[] classlabels_int64s = Attribute.classlabels_int64s.access(int[].class, onnxAttributes);
            return java.util.Optional.ofNullable(classlabels_int64s).map(int[]::clone);
        }
        
        public java.util.Optional<String[]> classlabels_strings() {
            String[] classlabels_strings = Attribute.classlabels_strings.access(String[].class, onnxAttributes);
            return java.util.Optional.ofNullable(classlabels_strings).map(String[]::clone);
        }
        
    }
    
    public static ZipMap ZipMap(TypeElement resultType, Value X, java.util.Optional<int[]> classlabels_int64s, java.util.Optional<String[]> classlabels_strings) {
        return new ZipMap(resultType, X, classlabels_int64s, classlabels_strings);
    }

}
