/*
 * Copyright (c) 2024, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the "Classpath" exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package shade;

import hat.types.F32;
import jdk.incubator.code.Reflect;
import jdk.incubator.code.dialect.java.JavaType;
import jdk.incubator.code.dialect.java.PrimitiveType;
import optkl.IfaceValue;
import optkl.IfaceValue.vec.Shape;
import optkl.codebuilders.JavaCodeBuilder;

import java.io.IOException;
import java.lang.invoke.MethodHandles;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.List;
import java.util.Map;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.function.BiConsumer;
import java.util.function.Consumer;

public class VecAndMatBuilder extends JavaCodeBuilder<VecAndMatBuilder> {

    VecAndMatBuilder() {
        super(MethodHandles.lookup(), null);
    }

    VecAndMatBuilder shape(Shape shape) {
        return dotted("Shape", "of").paren(_ -> {
                    typeName("JavaType").dot();
                    if (shape.typeElement() instanceof PrimitiveType primitiveType) {
                        if (JavaType.FLOAT.equals(primitiveType)) {
                            typeName("FLOAT");
                        } else {
                            typeName("INT");
                        }
                    } else {
                        blockInlineComment("WHAT");
                    }
                    commaSpace().intValue(shape.lanes());
                }
        );
    }

    VecAndMatBuilder type(IfaceValue.vec.Shape shape) {
        return type((JavaType) shape.typeElement());
    }

    VecAndMatBuilder typeAndName(String typeName, String identifierName) {
        return typeName(typeName).space().identifier(identifierName);
    }
    VecAndMatBuilder typeAndName(Shape shape, String identifierName) {
        return type(shape).space().identifier(identifierName);
    }
    <I> VecAndMatBuilder css(Iterable<I> iterable, Consumer<I> consumer) {
        return commaSpaceSeparated(iterable,consumer);
    }
    <I> VecAndMatBuilder cssX2(Iterable<I> iterable1, Iterable<I> iterable2, BiConsumer<I,I> consumer) {
        return commaSpaceSeparated(iterable1,iterable2,consumer);
    }
     VecAndMatBuilder cssLaneNames(Shape shape, Consumer<String> consumer) {
        return css(shape.laneNames(),consumer);
    }
    VecAndMatBuilder dotCall(String identifier, String identifier2, Consumer<VecAndMatBuilder> consumer) {
        return identifier(identifier).dot().call(identifier2,consumer);
    }
    VecAndMatBuilder dotCall(String identifier, String identifier2) {
        return dotCall(identifier,identifier2,_->{});
    }

    VecAndMatBuilder newKeyword( String identifier, Consumer<VecAndMatBuilder> consumer) {
        return newKeyword().space().call(identifier,consumer);
    }

    VecAndMatBuilder callOf(  Consumer<VecAndMatBuilder> consumer) {
        return call("of",consumer);
    }

    VecAndMatBuilder returnThis( ) {
        return  returnKeyword("this").semicolon();
    }

    VecAndMatBuilder semicolonNlSeparatedLaneNames(Shape shape, Consumer<String> consumer){
        return semicolonNlSeparated(shape.laneNames(),consumer).semicolonNl();
    }


    VecAndMatBuilder vec(String vectorName, Shape shape) {
        final String lhs = "l";
        final String rhs = "r";
        oracleCopyright();
        packageName(F32.class.getPackage());
        autoGenerated();
        importClasses(Reflect.class, JavaType.class, AtomicInteger.class, AtomicBoolean.class, IfaceValue.class);
        importStatic(F32.class, "*");
        nl();
        interfaceKeyword(vectorName).space().extendsKeyword().space().dotted(IfaceValue.class.getSimpleName(), "vec").body(_ -> {
            typeAndName(Shape.class.getSimpleName(),"shape").equals().shape(shape).semicolonNl().nl();
            semicolonNlSeparatedLaneNames(shape,n-> type(shape).space().call(n)).nl();

            typeAndName(AtomicInteger.class.getSimpleName(), "count").equals().newKeyword(AtomicInteger.class.getSimpleName(), _->intConstZero()).semicolonNl();
            typeAndName(AtomicBoolean.class.getSimpleName(), "collect").equals().newKeyword(AtomicBoolean.class.getSimpleName(), _->constant("false")).semicolonNl();

            AtomicInteger count = new AtomicInteger(0);
            AtomicBoolean collect = new AtomicBoolean(false);
              /*
             interface Field extends vec3 {
                 @Reflect
                 default void schema(){x();y();z();}
                 void x(float x);
                 void y(float y);
                 void z(float z);
                 default vec3 of(float x, float y, float z){
                    x(x);y(y);z(z);
                     return this;
                 }
                 default vec3 of(vec3 vec3){
                     of(vec3.x(),vec3.y(),vec3.z());
                     return this;
                 }
            }
            */

            blockComment("This allows us to add this type to interface mapped segments ");
            interfaceKeyword("Field").space().extendsKeyword().space().identifier(vectorName).body(_->
                    semicolonNlSeparatedLaneNames(shape, n->voidType().space().call(n,_->typeAndName(shape,n)))
                            .defaultKeyword().space().func(_->typeName(vectorName), "of", _->cssLaneNames(shape,n->typeAndName(shape,n)),
                                    _->semicolonNlSeparatedLaneNames(shape, n-> call(n, _ -> identifier(n))).returnThis()
                            )
                            .defaultKeyword().space().func(_->typeName(vectorName), "of", _->typeAndName(vectorName,vectorName),
                                    _->callOf(_-> cssLaneNames(shape,n-> dotCall(vectorName,n))).semicolonNl().returnThis()
                            )
            ).nl().nl();

            /*
               float vec4(float x, float y, float z, float w){
                  record Impl(float x, float y, float z, float w){}
                  return new Impl(x,y,z,w);
               }
             */
            staticKeyword().space().func(_ -> typeName(vectorName),
                    vectorName,
                    _ -> cssLaneNames(shape, n -> typeAndName(shape,n)),
                    _ -> record("Impl",
                                _ -> cssLaneNames(shape, n -> typeAndName(shape,n)),
                                _ -> identifier(vectorName),
                                _ -> {}
                        )
                            .lineComment("Uncomment to collect stats")
                            .lineComment("   if (collect.get())count.getAndIncrement();")
                            .returnKeyword(_ -> newKeyword("Impl", _ -> cssLaneNames(shape, this::identifier)))
            );

            Map.of(
                    "add", "+",
                    "sub", "-",
                    "mul", "*",
                    "div", "/"
            ).forEach((fName, sym) -> {
                        /*
                             vec4 add(float lx, float ly, float lz, float lw, float rx, float ry, float rz, float rw){
                                 return vec4(lx+rx, ly+ry, lz+rz, lw+rw);
                             }
                        */
                        staticKeyword().space().func(
                                _ -> typeName(vectorName),
                                fName,
                                _ -> cssX2(List.of(lhs, rhs), shape.laneNames(), (side, n) -> typeAndName(shape,side + n)),
                                _ -> returnCallResult(vectorName, _ -> cssLaneNames(shape, n -> identifier(lhs + n).symbol(sym).identifier(rhs + n)))
                        );
                        /*
                           vec4 add(vec4 l, vec4 r){
                              return add(l.x(), r.x(), l.y(), r.y(), l.z(), r.z(), l.w(), r.w());
                           }
                        */
                        staticKeyword().space().func(
                                _ -> typeName(vectorName),
                                fName,
                                _ -> css(List.of(lhs, rhs), side -> typeAndName(vectorName,side)),
                                _ -> returnCallResult(fName, _-> cssX2(shape.laneNames(), List.of(lhs, rhs), (n, side) -> dotCall(side,n)))
                        );
                         /*
                           vec4 add(float l, vec4 r){
                              return add(l, r.x(), l, r.y(), l, r.z(), l, r.w());
                           }
                        */
                        staticKeyword().space().func(
                                _ -> typeName(vectorName),
                                fName,
                                _ -> typeAndName(shape,lhs).commaSpace().typeAndName(vectorName,rhs),
                                _ -> returnCallResult(fName, _ -> cssLaneNames(shape, n -> identifier(lhs).comma().space().dotCall(rhs,n)))
                        );
                         /*
                           vec4 add(vec4 l, float r){
                              return add( l.x(), r, l.y(), r, l.z(), r, l.w(), r);
                           }
                        */
                        staticKeyword().space().func(
                                _ -> typeName(vectorName), // vec4
                                fName,                      // add
                                _ -> typeAndName(vectorName,lhs).commaSpace().typeAndName(shape,rhs), // vec4 l, float r
                                _ -> returnCallResult(fName, _ -> cssLaneNames(shape,n -> dotCall(lhs,n).commaSpace().identifier(rhs)))
                        );

                    }
            );
            List.of("neg", "sin", "cos", "tan", "sqrt", "inversesqrt").forEach(fName ->
                    /*
                       vec4 sin(vec4 v){
                          return vec4(F32.sin(v.x()), F32.sin(v.y()), F32.sin(v.z()), F32.sin(v.w()));
                       }
                     */
                    staticKeyword().space().func(
                            _ -> typeName(vectorName), // type
                            fName,                    // name
                            _ -> typeAndName(vectorName,"v"),
                            _ -> returnCallResult(vectorName, _ -> cssLaneNames(shape, n -> dotCall("F32", fName,_ -> dotCall("v", n))))
                    )
            );

            /*
            List.of("length").forEach(functionName ->
                     /*
                       float length(vec4 v){
                          return F32.length(v.x(), v.y(),v.z(),v.w());
                       }

                    staticKeyword().space().func(_ -> type(shape), // type
                            functionName,               // name
                            _ -> identifier(vectorName).space().identifier("v"),
                            _ -> returnCallResult(vectorName, _ ->
                                    commaSpaceSeparated(shape.laneNames(), laneName ->
                                            dotted("F32", functionName).paren(_ ->
                                                    dotted("v", laneName).ocparen()
                                            )
                                    )
                            )
                    )
            );*/
        });
        return self();
    }

    static String createVec(String vectorName, Shape shape) {
        return new VecAndMatBuilder().vec(vectorName, shape).toString();
    }

    static void writeVec(Path path, String vectorName, Shape shape) throws IOException {
        String text = createVec(vectorName, shape);
        Files.writeString(path.resolve(vectorName + ".java"), text);
    }


    static void main(String[] argv) throws IOException {
        Path path = Path.of("/Users/grfrost/github/babylon-grfrost-fork/hat/vecs/java/hat/types");
        Files.createDirectories(path);

        // writeVec(path,"ivec2", Shape.of(JavaType.INT, 2));
        //        writeVec(path,"ivec3", Shape.of(JavaType.INT, 3));
        writeVec(path, "vec2", Shape.of(JavaType.FLOAT, 2));
        writeVec(path, "vec3", Shape.of(JavaType.FLOAT, 3));
        writeVec(path, "vec4", Shape.of(JavaType.FLOAT, 4));


    }
}
