/*
 * Copyright (c) 2024, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the "Classpath" exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package shade;

import hat.types.F32;
import jdk.incubator.code.Reflect;
import jdk.incubator.code.dialect.java.JavaType;
import jdk.incubator.code.dialect.java.PrimitiveType;
import optkl.IfaceValue;
import optkl.IfaceValue.vec.Shape;
import optkl.codebuilders.JavaCodeBuilder;

import java.io.IOException;
import java.lang.invoke.MethodHandles;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.List;
import java.util.Map;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.function.BiConsumer;
import java.util.function.Consumer;

public class VecAndMatBuilder extends JavaCodeBuilder<VecAndMatBuilder> {

    VecAndMatBuilder() {
        super(MethodHandles.lookup(), null);
    }

    VecAndMatBuilder shape(Shape shape) {
        return dotted("Shape", "of").paren(_ -> {
                    typeName("JavaType").dot();
                    if (shape.typeElement() instanceof PrimitiveType primitiveType) {
                        if (JavaType.FLOAT.equals(primitiveType)) {
                            typeName("FLOAT");
                        } else {
                            typeName("INT");
                        }
                    } else {
                        blockInlineComment("WHAT");
                    }
                    commaSpace().intValue(shape.lanes());
                }
        );
    }

    VecAndMatBuilder type(IfaceValue.vec.Shape shape) {
        return type((JavaType) shape.typeElement());
    }

    VecAndMatBuilder typeAndName(String typeName, String identifierName) {
        return typeName(typeName).space().identifier(identifierName);
    }
    VecAndMatBuilder typeAndName(Shape shape, String identifierName) {
        return type(shape).space().identifier(identifierName);
    }
    <I> VecAndMatBuilder css(Iterable<I> iterable, Consumer<I> consumer) {
        return commaSpaceSeparated(iterable,consumer);
    }
    <I> VecAndMatBuilder cssX2(Iterable<I> iterable1, Iterable<I> iterable2, BiConsumer<I,I> consumer) {
        return commaSpaceSeparated(iterable1,iterable2,consumer);
    }
     VecAndMatBuilder cssLaneNames(Shape shape, Consumer<String> consumer) {
        return css(shape.laneNames(),consumer);
    }
    VecAndMatBuilder dotCall(String identifier, String identifier2, Consumer<VecAndMatBuilder> consumer) {
        return identifier(identifier).dot().call(identifier2,consumer);
    }
    VecAndMatBuilder dotCall(String identifier, String identifier2) {
        return dotCall(identifier,identifier2,_->{});
    }

    VecAndMatBuilder newKeyword( String identifier, Consumer<VecAndMatBuilder> consumer) {
        return newKeyword().space().call(identifier,consumer);
    }

    VecAndMatBuilder callOf(  Consumer<VecAndMatBuilder> consumer) {
        return call("of",consumer);
    }

    VecAndMatBuilder returnThis( ) {
        return  returnKeyword("this").semicolon();
    }

    VecAndMatBuilder semicolonNlSeparatedLaneNames(Shape shape, Consumer<String> consumer){
        return semicolonNlSeparated(shape.laneNames(),consumer).semicolonNl();
    }


    VecAndMatBuilder vec(String vectorName, Shape shape) {
        final String lhs = "l";
        final String rhs = "r";
        oracleCopyright();
        packageName(F32.class.getPackage());
        autoGenerated();
        importClasses(Reflect.class, JavaType.class, AtomicInteger.class, AtomicBoolean.class, IfaceValue.class);
        importStatic(F32.class, "*");
        nl();
        publicKeyword().space().interfaceKeyword(vectorName).space().extendsKeyword().space().dotted(IfaceValue.class.getSimpleName(), "vec").body(_ -> {
            typeAndName(Shape.class.getSimpleName(),"shape").equals().shape(shape).semicolonNl().nl();
            semicolonNlSeparatedLaneNames(shape,n-> type(shape).space().call(n)).nl();

            typeAndName(AtomicInteger.class.getSimpleName(), "count").equals().newKeyword(AtomicInteger.class.getSimpleName(), _->intConstZero()).semicolonNl();
            typeAndName(AtomicBoolean.class.getSimpleName(), "collect").equals().newKeyword(AtomicBoolean.class.getSimpleName(), _->constant("false")).semicolonNl();

            AtomicInteger count = new AtomicInteger(0);
            AtomicBoolean collect = new AtomicBoolean(false);
              /*
             interface Field extends vec3 {
                 @Reflect
                 default void schema(){x();y();z();}
                 void x(float x);
                 void y(float y);
                 void z(float z);
                 default vec3 of(float x, float y, float z){
                    x(x);y(y);z(z);
                     return this;
                 }
                 default vec3 of(vec3 vec3){
                     of(vec3.x(),vec3.y(),vec3.z());
                     return this;
                 }
            }
            */

            blockComment("This allows us to add this type to interface mapped segments ");
            interfaceKeyword("Field").space().extendsKeyword().space().identifier(vectorName).body(_->
                    semicolonNlSeparatedLaneNames(shape, n->voidType().space().call(n,_->typeAndName(shape,n)))
                            .defaultKeyword().space().func(_->typeName(vectorName), "of", _->cssLaneNames(shape,n->typeAndName(shape,n)),
                                    _->semicolonNlSeparatedLaneNames(shape, n-> call(n, _ -> identifier(n))).returnThis()
                            )
                            .defaultKeyword().space().func(_->typeName(vectorName), "of", _->typeAndName(vectorName,vectorName),
                                    _->callOf(_-> cssLaneNames(shape,n-> dotCall(vectorName,n))).semicolonNl().returnThis()
                            )
            ).nl().nl();

            /*
               float vec4(float x, float y, float z, float w){
                  record Impl(float x, float y, float z, float w){}
                  return new Impl(x,y,z,w);
               }
             */
            staticKeyword().space().func(_ -> typeName(vectorName),
                    vectorName,
                    _ -> cssLaneNames(shape, n -> typeAndName(shape,n)),
                    _ -> record("Impl",
                                _ -> cssLaneNames(shape, n -> typeAndName(shape,n)),
                                _ -> identifier(vectorName),
                                _ -> {}
                        )
                            .lineComment("Uncomment to collect stats")
                            .lineComment("   if (collect.get())count.getAndIncrement();")
                            .returnKeyword(_ -> newKeyword("Impl", _ -> cssLaneNames(shape, this::identifier)))
            );

            /*
            static vec3 vec3(float scalar) {return vec3(scalar,scalar,scalar);}
             */
            staticKeyword().space().func(_ -> typeName(vectorName),
                    vectorName,
                    _-> typeAndName(shape,"scalar"),
                    _->
                        returnKeyword().space().call(vectorName, _ -> {
                            for (int i = 0; i < shape.lanes() - 1; i++) {
                                identifier("scalar").commaSpace();
                            }
                            identifier("scalar");
                        }).semicolon()
                    );
            Map.of(
                    "add", "+",
                    "sub", "-",
                    "mul", "*",
                    "div", "/"
            ).forEach((fName, sym) -> {
                        /*
                             vec4 add(float lx, float ly, float lz, float lw, float rx, float ry, float rz, float rw){
                                 return vec4(lx+rx, ly+ry, lz+rz, lw+rw);
                             }
                        */
                        staticKeyword().space().func(
                                _ -> typeName(vectorName),
                                fName,
                                _ -> cssX2( shape.laneNames(),List.of(lhs, rhs), (side, n) -> typeAndName(shape,side + n)),
                                _ -> returnCallResult(vectorName, _ -> cssLaneNames(shape, n -> identifier(n+lhs).symbol(sym).identifier(n+rhs)))
                        );
                        /*
                           vec4 add(vec4 l, vec4 r){
                              return add(l.x(), r.x(), l.y(), r.y(), l.z(), r.z(), l.w(), r.w());
                           }
                        */
                        staticKeyword().space().func(
                                _ -> typeName(vectorName),
                                fName,
                                _ -> css(List.of(lhs, rhs), side -> typeAndName(vectorName,side)),
                                _ -> returnCallResult(fName, _-> cssX2(shape.laneNames(), List.of(lhs, rhs), (n, side) -> dotCall(side,n)))
                        );
                         /*
                           vec4 add(float l, vec4 r){
                              return add(l, r.x(), l, r.y(), l, r.z(), l, r.w());
                           }
                        */
                        staticKeyword().space().func(
                                _ -> typeName(vectorName),
                                fName,
                                _ -> typeAndName(shape,lhs).commaSpace().typeAndName(vectorName,rhs),
                                _ -> returnCallResult(fName, _ -> cssLaneNames(shape, n -> identifier(lhs).comma().space().dotCall(rhs,n)))
                        );
                         /*
                           vec4 add(vec4 l, float r){
                              return add( l.x(), r, l.y(), r, l.z(), r, l.w(), r);
                           }
                        */
                        staticKeyword().space().func(
                                _ -> typeName(vectorName), // vec4
                                fName,                      // add
                                _ -> typeAndName(vectorName,lhs).commaSpace().typeAndName(shape,rhs), // vec4 l, float r
                                _ -> returnCallResult(fName, _ -> cssLaneNames(shape,n -> dotCall(lhs,n).commaSpace().identifier(rhs)))
                        );

                    }
            );

            List.of(
                    "pow","min","max"
            ).forEach(fName -> {
                        /*
                              static vec2 pow(vec2 l, vec2 r){
                                return vec2(F32.pow(l.x(),r.x()),F32.pow(l.y(),r.y()));
                              }
                        */

                        staticKeyword().space().func(
                                _ -> typeName(vectorName),
                                fName,
                                _ ->  css(List.of(lhs, rhs), side -> typeAndName(vectorName,side)),
                                _ ->returnCallResult(vectorName, _-> css(shape.laneNames(), n ->
                                        identifier("F32").dot().call(fName,_->css(List.of(lhs, rhs),side-> dotCall(side,n))))
                                )
                        );

                    }
            );


            List.of( "floor", "round","fract","abs","log", "sin", "cos", "tan", "sqrt", "inversesqrt").forEach(fName ->
                    /*
                       vec4 sin(vec4 v){
                          return vec4(F32.sin(v.x()), F32.sin(v.y()), F32.sin(v.z()), F32.sin(v.w()));
                       }
                     */
                    staticKeyword().space().func(
                            _ -> typeName(vectorName), // type
                            fName,                    // name
                            _ -> typeAndName(vectorName,"v"),
                            _ -> returnCallResult(vectorName, _ -> cssLaneNames(shape, n -> dotCall("F32", fName,_ -> dotCall("v", n))))
                    )
            );
            //     static vec3 neg(vec3 vec3) {return vec3(0-vec3.x(),0-vec3.y(), 0-vec3.z());}


                    staticKeyword().space().func(
                            _ -> typeName(vectorName), // type
                            "neg",                    // name
                            _ -> typeAndName(vectorName,"v"),
                            _ -> returnCallResult(vectorName, _ -> cssLaneNames(shape, n -> floatConstZero().minus().dotCall("v",n)))
                    );

                    /*
                     static vec4 vec4(vec3 vec3, float w) {return vec4(vec3.x(), vec3.y(), vec3.z(), w);}
                     static vec4 vec4(vec2 vec2, float z,float w) {return vec4(vec2.x(), vec2.y(), z, w);}
                    */

            for (int lane=2;lane<shape.lanes();lane++){
                final int flane = lane;
                var argVecName = vectorName.substring(0,vectorName.length()-1)+lane; // vec2,vec3 etc
                List<String> trailingArgs = shape.laneNames().subList(flane,shape.lanes());
                staticKeyword().space().func(
                        _ -> typeName(vectorName), // type
                        vectorName,                    // name
                        _ -> typeAndName(argVecName,argVecName).commaSpace().css(trailingArgs,n-> typeAndName(shape,n)),
                        _ -> returnCallResult(vectorName, _ ->{
                               for (int argPos = 0; argPos<shape.lanes(); argPos++){
                                   if (argPos>0){
                                       commaSpace();
                                   }
                                   if (argPos<flane){
                                       typeName(argVecName).dot().call(shape.laneNames().get(argPos));
                                   }else{
                                       identifier(shape.laneNames().get(argPos));
                                   }
                               }

                        })
                );

            }
            /*
              static float dot(vec4 lhs, vec4 rhs) {
                  return lhs.x()*rhs.x()+lhs.y()*rhs.y()+lhs.z()*rhs.z()+lhs.w()*rhs.w();
                  }
   */
            staticKeyword().space().func(
                    _ -> type(shape), // type
                    "dot",                    // name
                    _ -> css(List.of(lhs,rhs),side->typeAndName(vectorName,side)),
                    _ -> returnKeyword().space().separated(shape.laneNames(),_->add(),n-> dotCall(lhs,n).mul().dotCall(rhs,n)).semicolon()
            );

            /* static float sumOfSquares(vec4 v) { return dot(v,v);} */
            staticKeyword().space().func(
                    _ -> type(shape), // type
                    "sumOfSquares",                    // name
                    _ -> typeAndName(vectorName,"v"),
                    _ -> returnCallResult("dot",_->identifier("v").commaSpace().identifier("v"))
            );
            /*
             static float length(vec4 vec4){
                return F32.sqrt(sumOfSquares(vec4));
              }
             */
            staticKeyword().space().func(
                    _ -> type(shape), // type
                    "length",                    // name
                    _ -> typeAndName(vectorName,"v"),
                    _ -> returnKeyword().space().dotCall("F32","sqrt",_->
                            call("sumOfSquares",_->identifier("v"))
                    ).semicolon()
            );
            /*
    static float distance(vec4 lhs, vec4 rhs){
        var dx = rhs.x()-lhs.x();
        var dy = rhs.y()-lhs.y();
        var dz = rhs.z()-lhs.z();
        var dw = rhs.w()-lhs.w();
        return F32.sqrt(dx*dx+dy*dy+dz*dz+dw*dw);
    }
    static float length(vec4 vec4){
        return F32.sqrt(sumOfSquares(vec4));
    }
    static vec4 clamp(vec4 rhs,float min, float max){
        return vec4(Math.clamp(rhs.x(),min,max),Math.clamp(rhs.y(),min,max),Math.clamp(rhs.z(),min,max),Math.clamp(rhs.w(),min,max));
    }

    static vec4 smoothstep(vec4 edge0, vec4 edge1, vec4 vec4){
        return vec4(
                F32.smoothstep(edge0.x(),edge1.x(), vec4.x()),
                F32.smoothstep(edge0.y(),edge1.y(), vec4.y()),
                F32.smoothstep(edge0.z(),edge1.z(), vec4.z()),
                F32.smoothstep(edge0.w(),edge1.w(), vec4.w())
        );
    }
                     */

        });
        return self();
    }

    static String createVec(String vectorName, Shape shape) {
        return new VecAndMatBuilder().vec(vectorName, shape).toString();
    }

    static void writeVec(Path path, String vectorName, Shape shape) throws IOException {
        String text = createVec(vectorName, shape);
        Files.writeString(path.resolve(vectorName + ".java"), text);
    }


    static void main(String[] argv) throws IOException {
        Path path = Path.of("/Users/grfrost/github/babylon-grfrost-fork/hat/vecs/java/hat/types");
        Files.createDirectories(path);
        writeVec(path, "vec2", Shape.of(JavaType.FLOAT, 2));
        writeVec(path, "vec3", Shape.of(JavaType.FLOAT, 3));
        writeVec(path, "vec4", Shape.of(JavaType.FLOAT, 4));


    }
}
