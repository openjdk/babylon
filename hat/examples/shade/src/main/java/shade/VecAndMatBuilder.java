/*
 * Copyright (c) 2024, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the "Classpath" exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package shade;

import hat.types.F32;
import jdk.incubator.code.Reflect;
import jdk.incubator.code.dialect.java.JavaType;
import optkl.IfaceValue;
import optkl.IfaceValue.vec.Shape;
import optkl.codebuilders.JavaCodeBuilder;

import java.io.IOException;
import java.lang.invoke.MethodHandles;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.List;
import java.util.Map;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.function.Consumer;
import java.util.stream.IntStream;

public class VecAndMatBuilder extends JavaCodeBuilder<VecAndMatBuilder> {

    final String vectorName;
    final Shape shape;
    final boolean collectStats;
    final boolean addField;
    VecAndMatBuilder(String vectorName, Shape shape, boolean collectStats, boolean addField) {
        super(MethodHandles.lookup(), null);
        this.vectorName = vectorName;
        this.shape = shape;
        this.collectStats = collectStats;
        this.addField = addField;
    }

    VecAndMatBuilder vName() {
        return id(vectorName);
    }

    List<String> laneNames(){
        return shape.laneNames();
    }

    int  lanes(){
        return shape.lanes();
    }

    VecAndMatBuilder vType() {
        return typeName(vectorName);
    }
    VecAndMatBuilder lType() {
        return type((JavaType)shape.typeElement());
    }
    VecAndMatBuilder vDecl(String id) {
        return vType().space().id(id);
    }
    VecAndMatBuilder lDecl(String id) {
        return lType().space().id(id);
    }
    VecAndMatBuilder simpleClassName(Class<?> clazz) {
        return typeName(clazz.getSimpleName());
    }
    VecAndMatBuilder cs() {return commaSpace();}

    VecAndMatBuilder id(String name) {return identifier(name);}
    VecAndMatBuilder idSp(String name) {return id(name).space();}
    VecAndMatBuilder idParen(String name,Consumer<VecAndMatBuilder> consumer) {return id(name).paren(consumer);}
    VecAndMatBuilder idParen(String n1, String n2) {return id(n1).dot().idParen(n2);}
    VecAndMatBuilder idParen(String name) {return id(name).ocparen();}
    VecAndMatBuilder snl() {return semicolonNl();}
    VecAndMatBuilder cnl() {return comma().nl();}


    VecAndMatBuilder f32Call(String name, Consumer<VecAndMatBuilder> consumer) {
        return simpleClassName(F32.class).dot().idParen(name, consumer);
    }
    VecAndMatBuilder f32Sqrt( Consumer<VecAndMatBuilder> consumer) {
        return f32Call("sqrt",consumer);
    }
    VecAndMatBuilder f32Clamp( Consumer<VecAndMatBuilder> consumer) {
        return f32Call("clamp",consumer);
    }
    VecAndMatBuilder f32Mix( Consumer<VecAndMatBuilder> consumer) {
        return f32Call("mix",consumer);
    }
    VecAndMatBuilder f32Smoothstep( Consumer<VecAndMatBuilder> consumer) {
        return f32Call("smoothstep",consumer);
    }
    VecAndMatBuilder f32Step( Consumer<VecAndMatBuilder> consumer) {
        return f32Call("step",consumer);
    }
    VecAndMatBuilder f32Inversesqrt( Consumer<VecAndMatBuilder> consumer) {
        return f32Call("inversesqrt",consumer);
    }



    VecAndMatBuilder staticLaneTypeFunc(
             String name, Consumer<VecAndMatBuilder> args, Consumer<VecAndMatBuilder> body) {
        return staticKwSp().func(_->lType(), name, args, body);
    }
    VecAndMatBuilder staticVecTypeFunc(
            String name, Consumer<VecAndMatBuilder> args, Consumer<VecAndMatBuilder> body) {
        return staticKwSp().func(_ -> vType(), name, args, body);
    }
    VecAndMatBuilder vec() {
        final String lhs = "l";
        final String rhs = "r";
        final var sides = List.of(lhs, rhs);
        oracleCopyright();
        packageName(F32.class.getPackage());
        autoGenerated();
      //  when(addField,_->importClasses(Reflect.class));
        importClasses(JavaType.class,  IfaceValue.class);
        when(collectStats,_->
             importClasses( AtomicInteger.class, AtomicBoolean.class)
        );
     //   importStatic(F32.class, "*");
        nl();
        publicKwSp().interfaceKwSp().vName().space().extendsKwSp().simpleClassName(IfaceValue.class).dot().id("vec").body(_ -> {
            statement(_->
                    assign(
                            _-> simpleClassName(Shape.class).space().id( "shape"),
                            _->typeName("Shape").dot().idParen("of",_-> {
                                simpleClassName(JavaType.class).dot();
                                either(shape.typeElement() instanceof JavaType t && JavaType.FLOAT.equals(t),
                                        _ -> typeName("FLOAT"),
                                        _ -> typeName("INT"));
                                cs().intValue(lanes());
                            })
                    )
            ).nl();
            statement(_->join(laneNames(),_->snl(), n -> lType().space().idParen(n))).nl(2);

            when(collectStats,_->
                statement(_->
                    assign(
                            _-> simpleClassName(AtomicInteger.class).space().id("count"),
                            _-> newKwSp().simpleClassName(AtomicInteger.class).paren(_ -> intConstZero())
                    )
               ).nl().statement(_->
                    assign(
                            _-> simpleClassName(AtomicBoolean.class).space().id("collect"),
                            _-> newKwSp().simpleClassName(AtomicBoolean.class).paren(_ -> booleanFalse())
                    )
               ).nl()
            );

              /*
             interface Field extends vec3 {
                 @Reflect
                 default void schema(){x();y();z();}
                 void x(float x);
                 void y(float y);
                 void z(float z);
                 default vec3 of(float x, float y, float z){
                    x(x);y(y);z(z);
                     return this;
                 }
                 default vec3 of(vec3 vec3){
                     of(vec3.x(),vec3.y(),vec3.z());
                     return this;
                 }
            }
            */

            when (addField,_-> {
                        blockComment("This allows us to add this type to interface mapped segments ");
                        interfaceKwSp().idSp("Field").extendsKwSp().vType().body(_ ->
                                statement(_ -> join(laneNames(), _ -> snl(), n -> voidType().space().idParen(n, _ -> lDecl(n)))).nl()
                                        .defaultKwSp().func(_ -> vType(), "of", _ -> join(laneNames(), _ -> cs(), this::lDecl),
                                                _ -> statement(_ -> join(laneNames(), _ -> snl(), n -> idParen(n, _ -> id(n))).snl()
                                                        .returnKwSp().id("this"))
                                        )
                                        .defaultKwSp().func(_ -> vType(), "of", _ -> vType().space().vName(),
                                                _ -> statement(_ -> idParen("of", _ -> join(laneNames(), _ -> cs(), n -> vName().dot().idParen(n))).snl()
                                                        .returnKwSp().id("this")
                                                )
                                        )
                        ).nl(2);
                    });

            /*
               float vec4(float x, float y, float z, float w){
                  record Impl(float x, float y, float z, float w){}
                  return new Impl(x,y,z,w);
               }
             */
            staticVecTypeFunc( vectorName, _ -> join(laneNames(),_->cs(), this::lDecl),
                    _ -> record("Impl",
                            _ -> join(laneNames(),_->cs(), this::lDecl),
                            _ -> vName(),
                            _ -> {}
                    )
                            .when(collectStats,_->
                                    ifKeyword().paren(_->idParen("collect","get")).braceNlIndented(_->statement(_->idParen("count","getAndIncrement")))).nl()
                              //  lineComment("Uncomment to collect stats").lineComment("   if (collect.get())count.getAndIncrement();")

                            .returnKeyword(_ -> newKwSp().typeName("Impl").paren( _ -> join(laneNames(),_->cs(), this::identifier)))
            );

            /*
            static vec3 vec3(float scalar) {return vec3(scalar,scalar,scalar);}
             */
           staticVecTypeFunc( vectorName, _ -> lDecl("scalar"),
                    _ -> statement(_->
                            returnKwSp().vName().paren(_ ->
                                join(laneNames(),_->cs(), _->id("scalar"))
                            )
                    )
            );
            Map.of(
                    "add", "+",
                    "sub", "-",
                    "mul", "*",
                    "div", "/"
            ).forEach((fName, sym) -> {
                        /*
                             vec4 add(float lx, float ly, float lz, float lw, float rx, float ry, float rz, float rw){
                                 return vec4(lx+rx, ly+ry, lz+rz, lw+rw);
                             }
                        */
                       staticVecTypeFunc( fName,
                                _ -> joinX2(laneNames(), sides,_->cs(), (side, n) -> lDecl( side + n)),
                                _ -> statement(_ ->
                                        returnKwSp().vName().paren( _ ->
                                                join(laneNames(),_->cs(), n -> id(n + lhs).symbol(sym).id(n + rhs))
                                        )
                                )
                        );
                        /*
                           vec4 add(vec4 l, vec4 r){
                              return add(l.x(), r.x(), l.y(), r.y(), l.z(), r.z(), l.w(), r.w());
                           }
                        */
                       staticVecTypeFunc( fName, _ -> join(sides,_->cs(), this::vDecl),
                                _ -> statement(_->
                                        returnKwSp().idParen(fName,_->
                                                joinX2(laneNames(), sides, _->cs(),(n, side) -> id(side).dot().idParen( n))
                                        )
                                )
                        );
                         /* Scaler left
                           vec4 add(float l, vec4 r){
                              return add(l, r.x(), l, r.y(), l, r.z(), l, r.w());
                           }
                        */
                       staticVecTypeFunc( fName, _ -> lDecl(lhs).cs().vDecl(rhs),
                                _ -> statement(_->
                                        returnKwSp().idParen(fName,_ ->
                                                join(laneNames(),_->cs(), n -> id(lhs).cs().id(rhs).dot().idParen( n))
                                        )
                                )
                        );
                         /*
                         Scaler right
                           vec4 add(vec4 l, float r){
                              return add( l.x(), r, l.y(), r, l.z(), r, l.w(), r);
                           }
                        */
                       staticVecTypeFunc( fName, _ -> vDecl( lhs).cs().lDecl( rhs),
                                _ -> statement(_->
                                        returnKwSp().idParen(fName,_ ->
                                                join(laneNames(),_->cs(), n -> id(lhs).dot().idParen( n).cs().id(rhs))
                                        )
                                )
                        );

                    }
            );

            List.of(
                    "pow", "min", "max"
            ).forEach(fName -> {
                        /*
                              static vec2 pow(vec2 l, vec2 r){
                                return vec2(F32.pow(l.x(),r.x()),F32.pow(l.y(),r.y()));
                              }
                        */
                       staticVecTypeFunc( fName, _ -> join(sides,_->cs(), this::vDecl),
                                _ -> statement(_->
                                        returnKwSp().vName().paren( _ -> join(laneNames(),_->cs(), n ->
                                                f32Call(fName, _ -> join(sides,_->cs(), side -> id(side).dot().idParen( n))))
                                        )
                                )
                        );
                         /*
                              static vec2 pow(float l, vec2 r){
                                return vec2(F32.pow(l,r.x()),F32.pow(l,r.y()));
                              }
                        */
                        //scalar l
                       staticVecTypeFunc( fName, _ -> lDecl( lhs).cs().vDecl( rhs),
                                _ -> statement(_->
                                        returnKwSp().vName().paren( _ -> join(laneNames(),_->cs(), n ->
                                                f32Call(fName, _ -> id(lhs).cs().id(rhs).dot().idParen( n)))
                                        )
                                )

                        );
                  /*
                              static vec2 pow(vec2 l, float r){
                                return vec2(F32.pow(l.x(),r),F32.pow(l.y(),r));
                              }
                        */
                        //scalar r
                       staticVecTypeFunc( fName, _ -> vDecl( lhs).cs().lDecl( rhs),
                                _ -> statement(_->
                                        returnKwSp().vName().paren( _ -> join(laneNames(),_->cs(), n ->
                                                f32Call(fName, _ -> id(lhs).dot().idParen( n).cs().id(rhs)))
                                        )
                                )

                        );

                    }
            );


            List.of("floor", "round", "fract", "abs", "log", "sin", "cos", "tan", "sqrt", "inversesqrt").forEach(fName ->
                    /*
                       vec4 sin(vec4 v){
                          return vec4(F32.sin(v.x()), F32.sin(v.y()), F32.sin(v.z()), F32.sin(v.w()));
                       }
                     */
                   staticVecTypeFunc( fName, _ -> vDecl( "v"),
                            _ -> statement(_->
                                    returnKwSp().vName().paren( _ ->
                                            join(laneNames(),_->cs(), n -> f32Call(fName, _ -> id("v").dot().idParen( n)))
                                    )
                            )
                    )
            );


            /*
                   static vec3 neg(vec3 vec3) {
                       return vec3(0f-vec3.x(),0f-vec3.y(), 0f-vec3.z());
                   }
            */
           staticVecTypeFunc( "neg", _ -> vDecl( "v"),
                    _ -> statement(_->
                            returnKwSp().vName().paren( _ ->
                                    join(laneNames(),_->cs(), n -> floatConstZero().minus().id("v").dot().idParen( n))
                            )
                    )
            );

                    /*
                     static vec4 vec4(vec3 vec3, float w) {return vec4(vec3.x(), vec3.y(), vec3.z(), w);}
                     static vec4 vec4(vec2 vec2, float z,float w) {return vec4(vec2.x(), vec2.y(), z, w);}
                    */

            IntStream.range(2,lanes()).forEach(flane-> {
                var argVecName = vectorName.substring(0, vectorName.length() - 1) + flane; //maps vec4 ->  vec2 ,vec3 etc
                var trailingArgs = laneNames().subList(flane, lanes());
               staticVecTypeFunc( vectorName,                    // name
                        _ -> typeName(argVecName).space().id(argVecName).cs().join(trailingArgs,_->cs(), this::lDecl),
                        _ -> statement(_->
                                returnKwSp().vName().paren( _ ->
                                    IntStream.range(0,lanes()).forEach(argPos->
                                        when(argPos>0,_->cs())
                                        .either(argPos < flane,
                                                _-> typeName(argVecName).dot().idParen(laneNames().get(argPos)),
                                                _-> id(laneNames().get(argPos))
                                        )
                                    )
                                )
                        )
                );

            });
            /*
              static float dot(vec4 lhs, vec4 rhs) {
                  return lhs.x()*rhs.x()+lhs.y()*rhs.y()+lhs.z()*rhs.z()+lhs.w()*rhs.w();
                  }
            */
           staticLaneTypeFunc("dot",_ -> join(sides,_->cs(), this::vDecl),
                    _ -> statement(_->
                            returnKwSp().join(laneNames(), _ -> add(), n ->
                                    id(lhs).dot().idParen( n).mul().id(rhs).dot().idParen( n)
                            )
                    )
            );

            /*
             static float sumOfSquares(vec4 v) {
                 return dot(v,v);
             }
            */
           staticLaneTypeFunc("sumOfSquares",_ -> vDecl( "v"),
                    _ -> statement(_->
                            returnKwSp().idParen("dot",_ ->
                                    id("v").cs().id("v")
                            )
                    )
            );
            /*
             static float length(vec4 vec4){
                return F32.sqrt(sumOfSquares(vec4));
              }
             */
           staticLaneTypeFunc("length", _ -> vDecl( "v"),
                    _ -> statement(_->
                            returnKwSp().f32Sqrt( _ ->
                                    idParen("sumOfSquares",_ -> id("v"))
                            )
                    )
            );

             /*
               static vec4 clamp(vec4 rhs,float min, float max){
                    return vec4(Math.clamp(rhs.x(),min,max),Math.clamp(rhs.y(),min,max),Math.clamp(rhs.z(),min,max),Math.clamp(rhs.w(),min,max));
                }
            */

           staticVecTypeFunc("clamp", _ -> vDecl( "v").cs().lDecl( "min").cs().lDecl( "max"),
                    _ -> statement(_->
                            returnKwSp().vName().paren( _ ->
                                    join(laneNames(),_->cs(), n -> f32Clamp( _ ->
                                            id("v").dot().idParen( n).cs().id("min").cs().id("max"))
                                    )
                            )
                    )
            );

            /*
             static vec4 normalize(vec4 vec4){
                float lenSq = sumOfSquares(vec4);
                 return (lenSq > 0.0f)?mul(vec4,F32.inversesqrt(lenSq)):vec4(0f);
             }
             */
           staticVecTypeFunc( "normalize", _-> vDecl( "v"),
                    _ -> {
                        statement(_->
                               assign(_->
                                       lDecl( "lenSq"),
                                       _->idParen("sumOfSquares",_ -> id("v"))
                               )
                        ).nl(2);
                        statement(_->
                                        returnKwSp().tern(
                                                _->idSp("lenSq").gt().space().floatConstZero(),
                                                _->idParen("mul",_ -> id("v").cs().f32Inversesqrt(_ -> id("lenSq"))),
                                                _->vName().paren( _ -> floatConstZero()))
                                );
                    });

/*
    static vec3 reflect(vec3 I, vec3 N) {
        // I - 2.0 * dot(N, I) * N
        return vec3.sub(I, vec3.mul(vec3.mul(N, dot(N,I)),2f));
    }
             */

           staticVecTypeFunc( "reflect", _ -> vDecl( lhs).cs().vDecl( rhs),
                    _ -> lineComment("lhs - 2f * dot(rhs, lhs) * rhs")
                            .statement(_->returnKwSp().vName().dot().idParen("sub",_ ->
                                id(lhs).cs().idParen("mul",_ ->
                                        idParen("mul",_ -> id(rhs).cs().id(lhs)).cs().constant("2f"))
                        ))
                    );


            /*
    static float distance(vec4 lhs, vec4 rhs){
        var dx = rhs.x()-lhs.x();
        var dy = rhs.y()-lhs.y();
        var dz = rhs.z()-lhs.z();
        var dw = rhs.w()-lhs.w();
        return F32.sqrt(dx*dx+dy*dy+dz*dz+dw*dw);
    } */
           staticLaneTypeFunc( "distance",_ -> join(sides,_->cs(), this::vDecl),
                    _ -> {
                        statement(_->join(laneNames(),_->snl(), n ->
                            assign(
                                    _->lDecl( "d" + n),
                                    _->id(rhs).dot().idParen( n).sub().id(lhs).dot().idParen( n)
                            )
                        )).nl();

                        statement(_->
                                returnKwSp().f32Sqrt( _ ->
                                   separated(laneNames(), _ -> add(), n -> id("d" + n).mul().id("d" + n))
                                )
                        );
                    });

            /*
    static vec4 smoothstep(vec4 edge0, vec4 edge1, vec4 vec4){
        return vec4(
                F32.smoothstep(edge0.x(),edge1.x(), vec4.x()),
                F32.smoothstep(edge0.y(),edge1.y(), vec4.y()),
                F32.smoothstep(edge0.z(),edge1.z(), vec4.z()),
                F32.smoothstep(edge0.w(),edge1.w(), vec4.w())
        );
    }
                     */
           staticVecTypeFunc( "smoothstep", _ -> join(List.of("e0","e1","v"),_->cs(), this::vDecl),
                    _ -> statement(_->
                            returnKwSp().vName().paren( _ ->
                                    indent(_ -> nl()
                                            .separated(laneNames(), _->
                                                            comma().nl(),
                                                            n -> f32Smoothstep( _-> id("e0").dot().idParen( n).cs()
                                                                            .id("e1").dot().idParen( n).cs()
                                                                            .id("v").dot().idParen( n)
                                                            )
                                                    ).nl()
                                    )
                            )
                    )
            );

           /*
             static vec3 step(vec3 e0, vec3 v){
        return vec3(
                F32.step(e0.x(), v.x()),
                F32.step(e0.y(), v.y()),
                F32.step(e0.z(), v.z())
        );
    }
            */
            staticVecTypeFunc( "step", _ -> join(List.of("e","v"),_->cs(), this::vDecl),
                    _ -> statement(_->
                            returnKwSp().vName().paren( _ ->
                                    indent(_ -> nl()
                                            .separated(laneNames(), _->
                                                            comma().nl(),
                                                    n -> f32Step( _-> id("e").dot().idParen( n).cs()
                                                            .id("v").dot().idParen( n)
                                                    )
                                            ).nl()
                                    )
                            )
                    )
            );
            /*
               static vec3 mix(vec3 l, vec3 r, float a) {
        return vec3(
                F32.mix(l.x(),r.x(),a),
                F32.mix(l.y(),r.y(),a),
                F32.mix(l.z(),r.z(),a)
        );
    } */
           staticVecTypeFunc( "mix", _ -> join(sides,_->cs(), this::vDecl).cs().lDecl( "v"),
                    _ ->statement(_->
                            returnKwSp().vName().paren( _ -> indent(_ ->
                                            nl()
                                                    .separated(laneNames(), _ ->
                                                            comma().nl(), n ->
                                                            f32Mix( _ ->
                                                                    id(lhs).dot().idParen( n).cs().id(rhs).dot().idParen( n).cs().id("v"))
                                                    )
                                    )
                                            .nl()
                            )
                    )

            );
            /*
            static vec2 mix(vec2 lhs,vec2 rhs, vec2 a){
                return vec2(
                        F32.mix(lhs.x(),rhs.x(),a.x()),
                        F32.mix(lhs.y(),rhs.y(),a.y()));
            }

            staticFunc(
                    _ -> vectorType(), // type
                    "mix",                    // name
                    _ -> vectorTypeDecl( lhs)
                            .cs().vectorTypeDecl( rhs)
                            .cs().laneTypeDecl( "v"),
                    _ ->
                            returnCallResult(vectorName, _ -> indent(_ ->
                                            nl()
                                                    .separated(laneNames(), _ ->
                                                            comma().nl(), n ->
                                                            dotCall("F32", "mix", _ ->
                                                                    dotCall(lhs, n).cs().dotCall(rhs, n).cs().id("v"))
                                                    )
                                    )
                                            .nl()
                            )

            );



*/
/*
            static vec2 mod(vec2 v, float r){
                return vec2(
                        F32.mod(v.x(),r),
                        F32.mod(v.y(),r)
                );
            }
            */

            if (lanes() == 2) {

                preformatted("""

                            static vec2 xy(vec3 vec3) {return vec2(vec3.x(), vec3.y());}
                            static vec2 xz(vec3 vec3) {return vec2(vec3.x(), vec3.z());}
                            static vec2 yz(vec3 vec3) {return vec2(vec3.y(), vec3.z());}


                            static vec2 mul(vec2 l, mat2 rhs) {return vec2(l.x()*rhs._00()+l.x()+rhs._01(),l.y()*rhs._10()+l.y()+rhs._11());}

                            static vec2 mod(vec2 v, float r){
                                return vec2(
                                        F32.mod(v.x(),r),
                                        F32.mod(v.y(),r)
                                );
                            }
                            static vec2 mix(vec2 lhs,vec2 rhs, vec2 a){
                                return vec2(
                                        F32.mix(lhs.x(),rhs.x(),a.x()),
                                        F32.mix(lhs.y(),rhs.y(),a.y()));
                            }


                           /*
                           We should be able to use vec16 for mat4


                                    float16 mat4_mul(float16 A, float16 B) {
                                        float16 C;

                                        // We compute C row by row
                                        // Each row of C is the sum of the rows of B scaled by the components of A

                                        // Row 0
                                        C.s0123 = A.s0 * B.s0123 + A.s1 * B.s4567 + A.s2 * B.s89ab + A.s3 * B.scdef;
                                        // Row 1
                                        C.s4567 = A.s4 * B.s0123 + A.s5 * B.s4567 + A.s6 * B.s89ab + A.s7 * B.scdef;
                                        // Row 2
                                        C.s89ab = A.s8 * B.s0123 + A.s9 * B.s4567 + A.sa * B.s89ab + A.sb * B.scdef;
                                        // Row 3
                                        C.scdef = A.sc * B.s0123 + A.sd * B.s4567 + A.se * B.s89ab + A.sf * B.scdef;

                                        return C;
                                    }


                                    #define TS 16 // Tile Size

                                    __kernel void mat4_mul_tiled(__global const float16* A,\\s
                                                                 __global const float16* B,\\s
                                                                 __global float16* C,
                                                                 const int Width) { // Width in terms of float16 units

                                        // Local memory for tiles of float16 matrices
                                        __local float16 tileA[TS][TS];
                                        __local float16 tileB[TS][TS];

                                        int row = get_local_id(1);
                                        int col = get_local_id(0);
                                        int globalRow = get_global_id(1);
                                        int globalCol = get_global_id(0);

                                        float16 accumulated = (float16)(0.0f);

                                        // Loop over tiles
                                        for (int t = 0; t < (Width / TS); t++) {

                                            // Cooperative Load: Each thread loads one float16 into local memory
                                            tileA[row][col] = A[globalRow * Width + (t * TS + col)];
                                            tileB[row][col] = B[(t * TS + row) * Width + globalCol];

                                            // Synchronize to ensure the tile is fully loaded
                                            barrier(CLK_LOCAL_MEM_FENCE);

                                            // Compute partial product for this tile
                                            for (int k = 0; k < TS; k++) {
                                                accumulated = mat4_mul_core(accumulated, tileA[row][k], tileB[k][col]);
                                            }

                                            // Synchronize before loading the next tile
                                            barrier(CLK_LOCAL_MEM_FENCE);
                                        }

                                        // Write result to global memory
                                        C[globalRow * Width + globalCol] = accumulated;
                                    }
                            */
                        """);


            } else if (lanes() == 3) {

            /*

    static vec3 cross(vec3 lhs, vec3 rhs) {
        return vec3(
                lhs.y() * rhs.z() - lhs.z() * rhs.y(),
                lhs.z() * rhs.x() - lhs.x() * rhs.z(),
                lhs.x() * rhs.y() - lhs.y() * rhs.x()
        );
    }

             */
                staticVecTypeFunc(
                        "cross",                    // name
                        _ -> join(List.of(lhs,rhs),_->cs(), this::vDecl),
                        _ -> statement(_->
                                returnKwSp().vName().paren( _ -> indent(_ -> nl()
                                                // lhs.y() * rhs.z() - lhs.z() * rhs.y(),
                                                .idParen(lhs,"y").mul().idParen(rhs,"z").sub().idParen(lhs,"z").mul().idParen(rhs,"y").cnl()
                                                //lhs.z() * rhs.x() - lhs.x() * rhs.z(),
                                                .idParen(lhs,"z").mul().idParen(rhs,"x").sub().idParen(lhs,"x").mul().idParen(rhs,"z").cnl()
                                                //lhs.x() * rhs.y() - lhs.y() * rhs.x()
                                                .idParen(lhs,"x").mul().idParen(rhs,"y").sub().idParen(lhs,"y").mul().idParen(rhs,"x")
                                        ).nl()
                                )
                        )

                );
                // Hack for vec3 until we have this working
             preformatted("""
                         static vec3 vec3(float x, vec2 yz) {return vec3(x, yz.x(), yz.y());}

                         static vec3 mul(vec3 lhs, mat3 rhs){return vec3(
                                 lhs.x()*rhs._00()+lhs.x()+rhs._01()+lhs.x()+rhs._02(),
                                 lhs.y()*rhs._10()+lhs.y()+rhs._11()+lhs.y()+rhs._12(),
                                 lhs.z()*rhs._20()+lhs.z()+rhs._21()+lhs.z()+rhs._22()
                         );}
                     """);

            }
        });
        return self();
    }

    static String createVec(String vectorName, Shape shape, boolean collectStats, boolean addField) {
        return new VecAndMatBuilder(vectorName, shape,collectStats,addField).vec().toString();
    }

    static void writeVec(Path path, String vectorName, Shape shape, boolean collectStats, boolean addField) throws IOException {
        String text = createVec(vectorName, shape,collectStats, addField);
        Files.writeString(path.resolve(vectorName + ".java"), text);
    }


    static void main(String[] argv) throws IOException {
        Path path = Path.of("/Users/grfrost/github/babylon-grfrost-fork/hat/core/src/main/java/hat/types");
        Files.createDirectories(path);
        boolean addField =true;
        boolean collectStats = false;

        writeVec(path, "vec2", Shape.of(JavaType.FLOAT, 2), collectStats,addField);
        writeVec(path, "vec3", Shape.of(JavaType.FLOAT, 3),collectStats,addField);
        writeVec(path, "vec4", Shape.of(JavaType.FLOAT, 4),collectStats,addField);
    }
}
